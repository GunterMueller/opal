name = {Java}
directory = /home/uebb/kd/ocs/src/lib/Tools/Java
SURVEY |
@c ========================================================================

@set JAVABIND JavaBind
@set javabind @code{javabind}
@set VERSION 1.1a
@set OPAL Opal
@set JAVA Java
@set DOSFOP Dosfop


@c ========================================================================

This is the technical documentation for the @value{JAVABIND} feature
(version @value{VERSION}).

@value{JAVABIND} provides a type-safe interface to @value{JAVA} software
in @value{OPAL}. For this purpose, a so-called @emph{binding compiler}
(command @value{javabind}) automatically produces @value{OPAL}
structures which connect to @value{JAVA} via the JNI (Java Native
Interface). The @value{OPAL} library-package @code{Java} supports the
code produced by the binding compiler and adds some generic
functionality such as catching exceptions and testing for @code{null}
objects.

For some examples of using @value{JAVABIND}, see
@file{/usr/ocs/examples/Java}.

@c ========================================================================
@section Mapping @value{JAVA} to @value{OPAL}

@value{JAVABIND} maps @value{JAVA} classes to @value{OPAL} in a
systematic way, as described in the following sections. The intention is that
it should not be necessary for a @value{JAVABIND} user to actually look
at the generated @value{OPAL} bindings; the documentation for the
@value{JAVA} classes together with knowledge of their representation
in @value{OPAL} should suffice.

@c --------------------------------------------------
@subsection Representing Subclassing

For any @value{JAVA} class @code{C} we have an @value{OPAL} sort
of the same name @code{C} with conversion functions mapping upwards and
downwards along the class hierarchy. The conversion functions correspond to
casting in @value{JAVA}, @code{(C)Obj}, and are
provided for any pair of classes which belong to the same path in the
inheritance tree. As in @value{JAVA}, casting downwards along the hierarchy is
a partial operation whose definedness can be tested with the function
@code{C?}, which corresponds to the @code{instanceof} primitive.


Consider the following Java classes (to illustrate the principle, the
inheritance from @code{Object} is made explicit):

@example
class A extends Object {...}
class B extends A {...} 
@end example

These classes and their inheritance relations are represented in Opal by
the following sorts, conversions and tests:

@example
SORT A
FUN Object   : A       -> Object
FUN A        : Object  -> A
FUN A?       : Object  -> bool

SORT B
FUN A        : B       -> A
FUN Object   : B       -> Object
FUN B        : Object  -> B
FUN B        : A       -> B
FUN B?       : Object  -> bool
FUN B?       : A       -> bool
@end example



@c --------------------------------------------------
@subsection Representing Fields

Public fields of objects are represented by commands which allow their
value to be retrieved and defined. Consider the class definition

@example
public class A @{public B field; ... @}
@end example  

@code{field} is represented in @value{OPAL} as follows:

@example
FUN field     : A -> com[B]
FUN :=_field  : A ** B -> com[void]
@end example


@c --------------------------------------------------
@subsection Representing Methods

Public methods of objects are represented by commands.  Consider the
class definition

@example
public class A @{public B method(B1 a1, ..., Bn an) @{ ... @} @}
@end example  

@code{method} is represented in @value{OPAL} as follows:

@example
FUN method : A ** B1 ** ... ** Bn -> com[B]
@end example

Note that the method overloading of @value{JAVA} is perfectly matched by
@value{OPAL}'s function overloading.


@c --------------------------------------------------
@subsection Inheritance and Overwriting

Inheritance of fields and methods of superclasses is modelled by
repeating their declarations in the subclass. Consider:

@example
public class A @{ public void method1 () @{ ... @}
                 public void method2 () @{ ... @} @}

public class B extends A
               @{ public void method2 () @{ ... @} @}
@end example

This is interfaced by the @value{OPAL} declarations:

@example
FUN method1 : A -> com[void]
FUN method2 : A -> com[void]

FUN method1 : B -> com[void]
FUN method2 : B -> com[void]
@end example

Let @code{ObjB} be an object of type @code{B}. Then @code{
  method1(ObjB)} invokes the method as it is defined in the superclass
@code{A}, and @code{method2(ObjB)} the overwritten version of
the method in @code{B}.

Dynamic dispatching is dealt with much as in @value{JAVA}.  Having an
object @code{ObjA} which is known in the context to be an instance
of class @code{A} but actually has class @code{B} and then calling
@code{method2(ObjA)} invokes the overwritten version from class
@code{B}. Henceforth, @code{method2(A(ObjB))} does @emph{not}
invoke the definition of @code{method2} from class @code{A}, but
from @code{B}.

A corresponding concept for @value{JAVA}'s @code{super} primitive, which
allows an overwritten method of a superclass to be invoked, is not
provided. In @value{JAVA}, @code{super} is only allowed inside the same
class definition where the overwriting happens. Such a context is
not present in @value{OPAL}'s view on @value{JAVA}, since classes are always
accessed from the outside.

@c --------------------------------------------------
@subsection Static Fields and Methods

Static fields and methods are treated in a similar way to normal
ones. Consider:

@example
public class A @{
   static public B field;
   static public B method(B1 a1, ..., Bn an) @{ ... @}
@}
@end example  

This is represented in @value{OPAL} as follows:

@example
FUN field  : com[B]
FUN method : B1 ** ... ** Bn -> com[B]
@end example


@c --------------------------------------------------
@subsection Interfaces

Interfaces are treated in a similar way to classes.


@c --------------------------------------------------
@subsection Exceptions

Exceptions thrown by @value{JAVA} methods lead to a failure of the
corresponding command execution. The structure @code{JavaCatch}
(@ref{@Overview{JavaCatch}}) provides a command combinator to check for such
failures and also to retrieve the object thrown by the exception:

@example
(... commands ...) catch (\\Throwable. ...)
@end example


@c --------------------------------------------------
@subsection Primitive Types, Strings and Arrays

The primitive @value{JAVA} types, strings and arrays are automatically
mapped to corresponding @value{OPAL} types. Consider:

@example
public class A @{
   static public int[] method(int k, String[] arr[]) @{ ... @}
@}
@end example  

This is represented in @value{OPAL} as:

@example
FUN method : int ** array[array[denotation]] -> array[int]
@end example

The mappings are as follows:

@table @code
@item boolean
is represented as @code{bool'BOOL}
@item byte
is represented as @code{byte'Byte} (@ref{@Overview{Byte}}), which is
just a wrapper around @code{int'Int} (@value{OPAL} currently has no
direct equivalent to @value{JAVA}'s byte type).
@item short
is represented as @code{short'Short} (@ref{@Overview{Short}}), which is
just a wrapper around @code{int'Int} (@value{OPAL} currently has no
direct equivalent to @value{JAVA}'s short type).
@item int
is represented as @code{int'Int}. Unfortunately, @value{OPAL}
integers have only 31-bit accuracy, so the highest bit is lost. We
currently prefer this pragmatic treatement instead of the inconvenience
of using a non-standard @value{OPAL} type for integers.
@item long
is represented as @code{long'Long} (@ref{@Overview{Long}}), which is just a
wrapper around @code{denotation'DENOTATION} (@value{OPAL} currently has
no direct equivalent to @value{JAVA}'s long type, and there is no type
which can simulate 64-bit integers - thus they are represented in their
textual form).
@item float 
is represented as @code{sreal'SmallReal}. Unfortunately, in @value{OPAL}
small reals have only 31-bit accuracy, so the highest bit is lost.
@item double 
is represented as @code{real'Real}. 
@item String 
is represented as @code{denotation'DENOTATION}. Null strings are
represented by empty denotations; a special test function allows one to
observe whether a denotation has been created from @code{null}
(@ref{@Overview{JavaNull}}).
@item C[] 
is represented as @code{array'Array}. Null arrays are
represented by empty arrays; a special test function allows one
to observe whether an array has been created from null (@ref{@Overview{JavaNullArray}}).
@end table


@c --------------------------------------------------
@subsection Mapping Classes to Structures

In @value{JAVA}, arbitrary cyclic dependencies between classes - even
across package boundaries - can appear. @value{OPAL} only allows
acyclic import relations. This problem is dealt with by
actually generating @emph{two} structures for each @value{JAVA} class:
the first one contains only the sorts and conversions, the second
the fields and methods. Consider:

@example
public class A @{ public B foo () @{ ... @} @}
puplic class B @{ public A bar () @{ ... @} @}
@end example

Schematically, the following structures are generated to interface
these classes:

@example
SIGNATURE A_SORT
  SORT A
  ...
SIGNATURE B_SORT    
  SORT B
  ...
SIGNATURE A
  IMPORT A_SORT COMPLETELY
  IMPORT B_SORT ONLY B
  FUN foo : A -> com[B]
SIGNATURE B
  IMPORT B_SORT COMPLETELY
  IMPORT A_SORT ONLY A
  FUN bar : B -> com[A]
@end example

In virtually all cases, the user does not need to know about this
treatment, since the structure containing the fields and methods also
re-exports the sorts and conversions. 


@c =======================================================================
@section Operation of the @value{javabind} tool

The @value{javabind} tool works on an input file which describes the
bindings to be generated and names the subsystem in which they should
be placed. Here is an examle of a @value{javabind} file:

@example
// name of the subsystem to generate
system "JavaLib" 
  // bind a class
  bind "java.io.BufferedInputStream"
@end example

Running @value{javabind} on this file produces the following output:

@example
javabind version 1.1a
class java.io.InputStream
  indirectly referred (requesting only sorts and casts)
  bounded in java_io_InputStream
  java_io_InputStream_SORT reused from /home/uebb/opal/2.3a/lib/opal_java
class java.io.BufferedInputStream
  bounded in java_io_BufferedInputStream
class java.io.FilterInputStream
  indirectly referred (requesting only sorts and casts)
  bounded in java_io_FilterInputStream
class java.lang.String
  indirectly referred (requesting only sorts and casts)
  bounded in java_lang_String
  java_lang_String_SORT reused from /home/uebb/opal/2.3a/lib/opal_java
interface java.io.Serializable
  indirectly referred (requesting only sorts and casts)
  bounded in java_io_Serializable
  java_io_Serializable_SORT reused from /home/uebb/opal/2.3a/lib/opal_java
class java.lang.Class
  indirectly referred (requesting only sorts and casts)
  bounded in java_lang_Class
  java_lang_Class_SORT reused from /home/uebb/opal/2.3a/lib/opal_java
  java_lang_Class reused from /home/uebb/opal/2.3a/lib/opal_java
class java.lang.Object
  indirectly referred (requesting only sorts and casts)
  bounded in java_lang_Object
  java_lang_Object_SORT reused from /home/uebb/opal/2.3a/lib/opal_java
  java_lang_Object reused from /home/uebb/opal/2.3a/lib/opal_java
@end example

As seen from the output, @value{javabind} not only generates bindings
for classes which are directly requested, but also for classes which
are indirectly referenced from the requested ones. These are superclasses
and interfaces of the requested classes, as well as classes referenced
from the member signatures.

In order to minimize the amount of bindings, for indirect referred
classes only the structure containing the sorts and conversions is 
generated (such as @code{java_io_InputStream_SORT}). Moreover,
bindings are @emph{reused} from existing libraries of @value{JAVA}
bindings, supporting the incremental construction of richer binding
sets from existing ones. A default set of bindings is available in the 
basic @value{OPAL}-Java library. This set is constructed by the 
@value{javabind} file:

@example
system "JavaDefault
  bind "java.lang.Object"
  bind "java.lang.Class"
  bind "java.lang.Throwable"
@end example

Note that these bindings imply a lot of other indirectly referred bindings
which are present in the standard library.

@sp 1

In order to base bindings on existing ones other then those of the
standard library, a binding file may contain a special directive
referring to the directory of an OCS subsystem generated by @value{javabind}:

@example
system "JavaExtendedLib"
  uses "./JavaLib"
  bind "..."
@end example

If an application uses several binding libraries, it is important that
they are hierarchically built as sketched above. Otherwise bindings
for the same class would be generated twice, leading to multiply
defined symbol errors at link time.


@sp 1
A special instruction in a @value{javabind} file allows a group of
structures to be clustered in a single structure which re-exports
them. For example:

@example
system "JavaLib"
  // bind a lot of stuff from java.io
  ...
  // cluster the structures generated for the java.io classes
  cluster "java.io.*" in "java_io"
@end example




@page

@page


|
