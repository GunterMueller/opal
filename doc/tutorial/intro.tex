% LAST EDIT: Wed May  4 11:39:31 1994 by Juergen Exner (hektor!jue) 
% LAST EDIT: Tue May  3 14:10:06 1994 by Juergen Exner (hektor!jue) 
% LAST EDIT: Wed Apr 27 15:20:51 1994 by Juergen Exner (hektor!jue) 
% LAST EDIT: Fri Apr 22 11:58:14 1994 by Juergen Exner (hektor!jue) 
% LAST EDIT: Mon Apr 18 17:52:13 1994 by Juergen Exner (hektor!jue) 
% LAST EDIT: Tue Feb 15 10:24:13 1994 by Juergen Exner (hektor!jue) 
% LAST EDIT: Sun Feb 13 14:08:42 1994 by Juergen Exner (hektor!jue) 
% LAST EDIT: Mon Nov 15 21:20:52 1993 by Juergen Exner (hektor!jue) 
% LAST EDIT: Wed Oct 20 13:37:31 1993 by Juergen Exner (hektor!jue) 
% LAST EDIT: Mon Oct 18 15:07:49 1993 by Juergen Exner (hektor!jue) 
% LAST EDIT: Mon Jan 11 16:28:25 1993 by Juergen Exner (hektor!jue) 
\chapter{Introduction}
\label{chap:intro}

\hfill\begin{minipage}[t]{7cm}
{\em
A language that does not affect the way you think about programming
is not worth knowing.}\\{\small \mbox{} \hfill \mbox{Author unknown}}
\end{minipage}

\bigskip

In the past programming has been dominated by the traditional style of
imperative programming.
Programming languages like Fortran, Cobol, Algol, Pascal, C and even
Assembler are familiar examples of the imperative 
programming paradigm.

These languages have been oriented towards the internal architecture of the
well-known 
\mbox{von-Neumann} Computer. This implies the main disadvantage of imperative
languages: programming must be oriented towards the architecture of the
computer instead of towards the structure of the problem to be solved.

As early as 1978 J. Backus asked in his Turing Award Lecture ``Can
Programming be Liberated from the von Neumann Style?'' 
Since then increasing effort has been invested in the development of
alternatives to 
imperative programming languages. 
Some of the results are known nowadays by the catchwords `logic
programming` (e.g. Prolog), `object oriented programming` (e.g.\ 
Smalltalk, C++) and `functional (or applicative) programming` (e.g. pure
LISP, ML, HOPE, Haskell).

The programming language \opal\  lies somewhere between  other modern functional
programming languages like ML, HOPE and  Miranda.
\opal\  is a pure functional language without any imperative relics.
In addition to higher-order functions, lambda abstraction and pattern-matching, \opal\ offers a comfortable modularization
(``programming in the large'') and a powerful, orthogonal type system
which includes
generic functions (realized by parameterized structures) and free types. 
 \opal\ also  supports overloading of names (together with a
concise and flexible method for annotation), object declarations,
non-deterministic case-distinctions and, in addition, a new way of
handling infix- and postfix-operators.

In the past functional programming languages have been accused of 
inefficiency with respect to time and space. 
The \opal\ research project has defeated this legend.
By using innovative techniques during compilation the runtime of the
generated object code is of the same magnitude as for hand-written C-code.
This has been proved in  several benchmark tests and sometimes, in very
special cases, the generated code is even more efficient than a
comparable hand-written C-program. 

In any case, the generated code is much faster than that of traditional
functional languages. There are orders of magnitudes between the
execution times of \opal\ and e.g.~ML
or HOPE (see \cite{SchGr} for details).
\medskip


This combination of features seems to be unique and we would
therefore like
to re\-commend the use of \opal\ in research, application programming and
education.
 

\section{Aim of this Tutorial}
\label{sec:aim}

In this tutorial we will not assume the reader to be familiar with
functional programming or any other programming paradigm.
In fact, being familiar with imperative languages , for example, may
be disadvantage, because you will have to alter your way of thinking
about programming,  whereas a novice user is spared this handicap.

Nevertheless, it might be helpful  to have some basic
knowledge about the theory of programming languages or at least about
programming in general. 

\smallskip

With a view to accommodating users from all fields  the goal of this
tutorial will be twofold:
\begin{itemize}
\item On the one hand, we will present a short, but complete
  introduction to the techniques and methods of functional
  programming.
\item On the other hand, we will give a complete introduction to
  programming with \opal.
\end{itemize}
After reading this tutorial a novice user without prior knowledge of
functional programming should be able to develop programs in
functional style using all the usual features of functional programming,
and to implement these programs in \opal.

But remember, you cannot learn a programming language only by reading
about it, you have to write your own programs and learn by use. 
We therefore advise the reader to try the examples in this tutorial, to
modify and enlarge them, and then to write original programs.


\section{Structure of this Tutorial}
\label{sec:structure}

Each chapter of this tutorial treats one aspect of \opal\  in depth.
In general we will use bottom-up methodology, i.e.~we will
start with the smallest parts of a program (the names) and finish by
combining complete libraries to programming systems.

The advantage of this scheme---the information on each topic will be
concentrated in one place and can be easily found by reference to  the
table of contents---unfortunately also implies a great 
disadvantage, particular for an  introductory tutorial.
A novice reader will be overwhelmed by a flood of information he
certainly does not need in the initial stages.

We try to avoid this  by using a second dimension in the structure. 
Each paragraph will be marked with a sign that indicates the target group
of this paragraph:

\novice A section marked with an $\cal N$ like this one addresses
a novice user with no prior knowledge of \opal\  or functional programming.
It contains fundamental information describing the most basic
features of \opal, which are  essential for trivial programs. 

After reading these sections a novice user without prior knowledge
should be able to write, compile and 
execute simple (indeed very simple) \opal\ programs.

These novice sections are really low-level. 
They do not explain any of those features which determine the
power of functional programming, or advanced features of \opal.

Nevertheless they contain vital information about \opal\  and should
therefore {\em not} be skipped by experienced users of functional languages.

\advanced The more advanced features will be explained in sections for
advanced users, marked with an $\cal A$ like this. 
A novice user should skip these sections on the first run, whereas a
user already familiar with functional programming may read them first
time round.

The advanced sections  contain all the information needed to harness 
the full power of functional programming and \opal. 
The concepts and features will be explained in detail, and restrictions
and circumventions will be noted.
In addition, topics only touched on in the novice sections will be discussed in
depth. 

In these sections we presume the reader to be familiar with the
basic concepts and notations of \opal. 
 Often there will be cross-references to other sections and topics,
 since, due to the relations between the different language concepts,
 individual parts of a programming language cannot always be explained
 in isolation
Therefore the reader should be aware that he will sometimes have to read a different
section first before being able to understand the current one.

This concept might be considered disadvantageous, but it is the only
way to get a concise and also complete reference for a
programming language.

\experienced The third kind of sections are those for experienced
users, marked with an $\cal E$ like this.
These sections can be skipped  by the normal user altogether, as they
are only for the experts.
They contain additional background information about special topics and
hints for very special features which won't be used by the average
application programmer.

\important Sometimes a paragraph will be preceded by an exclamation
mark like this. These paragraphs contain important information
and warnings.

\section{Notational Conventions and Terminology}
\label{sec:notation}
\novice 
In order to make this paper easier to read, we will use some
conventions for notations and terminology.
All these conventions will be detailed a second time as soon as  a notion or
notation is used in the following chapters.
So this section serves mainly as a kind of glossary and may
be skipped on a first reading.


\subsubsection{Notations}
\novice 
We will use different fonts to distinguish different objects.

\hspace{1em} The normal font, as used in  this chapter, will be used for flow
text, explanations, remarks and so on.

 Program text will be written in a tty-like font \pro{like this}.
We will also use this font in flow text for program fragments
(e.g.~names of functions), if they belong to a concrete program. 
% For convenience keywords are written in \key{boldface} tty-like style.

Note that the leading numbers  of programs in examples are {\em not}
part of the program. They are only used to reference lines
in the explanations.

In interactive examples the output of the computer will likewise be
denoted in \pro{tty-like style} while the user's input will also be
\underline{\pro{underlined}}.

When arguing about concepts we won't use the tty-like style, but prefer a
more mathematical notation in \spec{a\ font\ like\ this}. 


\subsubsection{Notions}
\novice 
 The notions declaration, definition, signature,
implementation and specification are sometimes applied imprecisely in
literature.
Let us explain their meanings as used in this tutorial by an example:

We want to write a function which doubles its argument.
This is already an (informal) specification.
A {\em specification\/} describes {\em what\/} should be done, e.g.~
doubling the argument.
Specifications are essential for arguing about programs, especially
for program verification.

The {\em signature declares\/} the formal frame:
\begin{prog}
\key{FUN} double : nat -> nat
\end{prog}

The function \pro{double} will take one natural number as argument and
deliver a natural number as the result.
The signature does not describe what a function does or how this will
be done.

The {\em implementation defines\/} how the function works:
\begin{prog}
\key{DEF} double(n) \key{==} n + n
\end{prog}

Sometimes we will use  declaration and definition as synonyms for
signature and implementation.

We won't deal with this topic in detail here, but will return to it
repeatedly in following chapters.

%\advanced The current release of \opal\  does not support specifications.
%We will add them only as comments.
%
%\advanced In  classical imperative languages signature and
%implementation are often mixed together, e.g.~in Modula-2 the procedure
%\begin{prog}
%\key{PROCEDURE} double(n:\key{CARDINAL}):\key{CARDINAL};\\
%\key{BEGIN}\\
%  \key{RETURN} n + n;\\
%\key{END} double;
%\end{prog}
%declares and defines the function \pro{double} in one step.


\section{Release Notes}
\label{sec:releasenotes}
\experienced This  tutorial describes \opal,  Version 2.1, released in
Spring 1994. 
There are some features in this new release, which are not supported
by former versions of \opal.  
These upgrades include:
\begin{itemize}
\item sections
\item enhanced infix notation
\item underscore as wildcard in pattern-matching
\item underscore as combinator for alpha-numerical and graphical
  identifiers
\item sequential guards
\item compiler now assumes right associate operators if brackets are missing
\end{itemize}

\noindent Consult the appropriate sections if you want to know more
about the new features.

 The examples in this tutorial are based on ``Bibliotheca Opalica''
of Spring 1994, as distributed together with the compiler.
This library has been considerably restructured and enhanced. 
See \cite{Di} for upgrading old programs to the new library.


% Local Variables: 
% mode: latex
% TeX-master: "tutorial"
% End: 

