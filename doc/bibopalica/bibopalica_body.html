<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51-kd-pl15
     from bibopalica.texi on 1 October 1998 -->

<TITLE>BIBLIOTHECA OPALICA</TITLE>
</HEAD>
<BODY bgcolor=#ffffff vlink=#008000 link=#0000ff>
<H1>BIBLIOTHECA OPALICA</H1>
<H2>A Document on Structured Use And Abuse</H2>
<ADDRESS>The OPAL Group</ADDRESS>
<ADDRESS>written by Klaus Didrich</ADDRESS>
<P>
<P><HR><P>

<P>
Copyright © 1994, 1995, 1996 The OPAL Group

</P>



<H1><A NAME="SEC1" HREF="bibopalica_toc.html#TOC1">Introduction</A></H1>

<P>
A library is one of the integral components of modern languages. Its
function is to relieve the user of the task of constantly redefining
standard structures. This is especially true for OPAL, since only two
structures, <CODE>BOOL</CODE> and <CODE>DENOTATION</CODE> are predefined. A library for
OPAL, containing most data types and functions needed for everyday use,
has been developed in recent years.

</P>

<P>
These structures do belong to the OPAL release, but they are not part
of the language. Most of them are written in OPAL and only some are
substituted by handwritten code (see  <A HREF="bibopalica_body.html#SEC26">Handcoded Structures</A>) for reasons of
efficiency (both space and time). This difference is not apparent to the
OPAL user.

</P>
<P>
This paper offers you an overview of BIBLIOTHECA OPALICA, so that you
will be able to use (and abuse) the structures in the library. That is, you
will not find explanations of the functions, but you will learn where these
explanations are located. If you need information about a particular
function, please have a look at the signature parts.

</P>
<P>
It is not the purpose of this paper to give you an introduction to
OPAL; for this you are referred to <CITE>The Programming Language
OPAL -- The Implementation Language</CITE> and <CITE>The OPAL
Tutorial</CITE>. Neither does the paper serve as an introduction to the
compilation system, which is explained in <CITE>A User's Guide to the
OPAL Compilation System</CITE>.

</P>
<P>
We first outline the structuring principles which were used in the
design of the library. Then, we proceed through the library
structures explaining what types are defined and what additional structures
are available. Last, we turn to some particularities of BIBLIOTHECA
OPALICA. The appendix contains, among other topics, a list of the currently
known bugs and an aid to converting programs from the old library to
BIBLIOTHECA OPALICA.

</P>
<P>
The OPAL library has matured in recent years and summarizes the
experience of several years of functional programming. We would like to
also include <EM>your</EM> experience in BIBLIOTHECA OPALICA. So, if you
have any suggestions or contributions to make, please do not hesitate to
drop us a line or send us a piece of code which may appear in the next
release of BIBLIOTHECA OPALICA.

</P>
<P>
The OPAL Group is reachable via email: <CODE>opal@.cs.tu-berlin.de</CODE>.

</P>
<P>
The OPAL distribution is available via <CODE>WWW</CODE>
at the URL <CODE>http://uebb.cs.tu-berlin.de/~opal/</CODE>

</P>


<H1><A NAME="SEC2" HREF="bibopalica_toc.html#TOC2">Structuring Principles</A></H1>

<P>
BIBLIOTHECA OPALICA consists of more than 100 different
structures. Lest the user get lost, this multitude of structures clearly
requires a structure of its own.

</P>
<P>
The first principle of structuring is of course the division of structures
according to their kind, i.e. predefined structures, parameterized
structures, environment access structures and the like. This is detailed in
 <A HREF="bibopalica_body.html#SEC5">Survey of Structures</A>.

</P>
<P>
There are, however, other structuring principles which are valid across
these divisions. One of them is the naming of structures which follows
certain principles and allows you to conclude some information about a
structure from its name.

</P>
<P>
The other is the principle that similar functions have the same name in
OPAL, even if they work on different data types. Typical examples of
such functions are functions for converting data types to textual
representation.

</P>

<UL>
<LI><A HREF="bibopalica_body.html#SEC3">Naming of Structures</A>
<LI><A HREF="bibopalica_body.html#SEC4">Orthogonality</A>
</UL>



<H2><A NAME="SEC3" HREF="bibopalica_toc.html#TOC3">What's in a Name? -- Naming of Structures</A></H2>

<P>
Roses smell as sweet by any other name, and likewise the semantics of a
structure is not affected by its name. To the user, however, the name of a
structure provides valuable clues about the content. By adhering to naming
principles, the task of remembering the existing structures is also made
easier.

</P>
<P>
In BIBLIOTHECA OPALICA the following principles are used:

</P>
<DL COMPACT>

<DT><VAR>Type</VAR>
<DD>
This is always the basic structure for the mentioned <VAR>type</VAR>. It contains
the type definition, if possible with a free type declaration, and the most
basic functions that are needed for using this <VAR>type</VAR>. Note that types
always start with lowercase (e.g. <CODE>nat</CODE>), while structure names are
capitalized (e.g. <CODE>Nat</CODE>).

<DT><VAR>Type</VAR>Conv
<DD>
These structures (e.g. <CODE>CharConv</CODE>, <CODE>SetConv</CODE>) contain functions
that convert from data type <VAR>type</VAR> into another type, while preserving
information; i.e. they are (in principle) invertible. Typical examples are
conversions to text or converting different types of numbers.

This also works the other way round: If you are looking for a function which
converts members of type <VAR>type</VAR>, it is usually found in Structure
<VAR>Type</VAR>Conv. There are, however, exceptions to this rule:

There is no Structure <CODE>DenotationConv</CODE>. Conversions from
<CODE>denotation</CODE> to <VAR>type</VAR> are considered to be a kind of 
"pseudo-constructor" and are therefore placed in Structure <VAR>Type</VAR>.

Conversions from sequences to another aggregate type
(see  <A HREF="bibopalica_body.html#SEC13">AggregateTypes</A>) are likewise not included in <CODE>SeqConv</CODE> but in
<VAR>Type</VAR>Conv. 

<DT><VAR>Type</VAR>Filter
<DD>
Functions in these kind of structures (like <CODE>SetFilter</CODE>) take a
bool-valued function and an aggregate type and remove those elements which
--- as required -- either fulfill or do not fulfill the given predicate.

<DT><VAR>Type</VAR>Fold
<DD>
<DT><VAR>Type</VAR>Reduce
<DD>
These structures (<CODE>SeqFold</CODE>, <CODE>SeqReduce</CODE>, and so on) contain
functions which connect every element of an aggregate type with a given
function. Reducing requires a start value while folding does not, but the
latter is more restrictive, e.g. it is not defined on empty objects.

<DT><VAR>Type</VAR>Map
<DD>
In structures like <CODE>SeqMap</CODE>, <CODE>SetMap</CODE>, and their counterparts for
other aggregate types, we find functions for applying one or several
functions to every element of the aggregate type.

<DT><VAR>Name</VAR>By<VAR>Attr</VAR>
<DD>
These structures give hints about different kinds of implementation of
<VAR>Name</VAR>. This applies to data types (e.g. sets: <CODE>SetByPred</CODE>) or
different methods for defining certain functions (e.g. orderings:
<CODE>OrderingByInjection</CODE>).

</DL>

<P>
Other kinds of structures are still in the development stage and will be
added in later releases.

</P>



<H2><A NAME="SEC4" HREF="bibopalica_toc.html#TOC4">Orthogonality</A></H2>

<P>
Orthogonality means that functions which perform similar tasks are named
similarly. The principles of structuring structures obviously support
sticking to the "Principle of Least Astonishment".

</P>
<P>
Also note that differently implemented types have the same name, and can
therefore easily be replaced by another implementation: simply change the
imported structure and recompile the code. So for sets of natural numbers
you can choose whether to use the ordinary implementation or the
bitstring-oriented implementation by switching from <CODE>IMPORT Set[nat]
ONLY set {} + in ...</CODE> to <CODE>IMPORT Bitset ONLY set {} + in
...</CODE>.

</P>
<P>
The reader should particularly note the following:

</P>

<UL>
<LI>

There is always a function <CODE>` :</CODE><VAR>type</VAR><CODE>-&#62; denotation</CODE>. If the
type is parameterized, the functionality is augmented by functions for
converting the parameter type, e.g. sequences: 
<CODE>` : (data -&#62; denotation) -&#62; seq -&#62; denotation</CODE>.
The only exception is the type
<CODE>denotation</CODE> itself. Even for types like 
<CODE>set'SetByPred</CODE> (see  <A HREF="bibopalica_body.html#SEC13">AggregateTypes</A>) which do
not provide a sensible textual representation,
a function which returns a fixed text
describing the type is supplied.

The function <CODE>`</CODE> is located in Structure <VAR>Type</VAR>Conv.

<LI>

If a conversion from <CODE>denotation</CODE> to <VAR>type</VAR> is given, this function
is called <CODE>!</CODE> and located in Structure <VAR>Type</VAR>.

<LI>

Functions which convert one type into another type are called
<CODE>as</CODE><VAR>Type</VAR>, e.g. <CODE>asNat</CODE> for a function which converts type
<CODE>int</CODE> to type <CODE>nat</CODE>. The exceptions are the functions <CODE>`</CODE> and
<CODE>!</CODE> (see above).

<LI>

Aggregate types (see  <A HREF="bibopalica_body.html#SEC13">AggregateTypes</A>) have many similarities which are
exploited in the naming of functions. 

<DL COMPACT>

<DT><CODE>!</CODE>
<DD>
Selection of one of the components.

<DT><CODE>#</CODE>
<DD>
The size of the aggregate object.

<DT><CODE>%</CODE>
<DD>
Combining up to eight elements to produce an aggregate.

<DT><CODE>.. iter</CODE>
<DD>
Generating elements with the help of a function.

<DT><CODE>*</CODE>
<DD>
The mapping operator(s).

<DT><CODE>/ (\)</CODE>
<DD>
Reducing and folding. If order of elements matters, then both functions
(left and right reduce or fold) are given.

<DT><CODE>|</CODE>
<DD>
Filtering out elements with a given predicate.

<DT><CODE>exist? forall?</CODE>
<DD>
Applying predicates to all elements of an aggregate.

</DL>
</UL>



<H1><A NAME="SEC5" HREF="bibopalica_toc.html#TOC5">Survey of Structures</A></H1>

<P>
We will now take a look at the structures in BIBLIOTHECA OPALICA. We
will not examine each and every structure, rather will provide explanations
concerning each group of structures. There will be no further comment on
structures whose purpose is explained by the naming principles
(see  <A HREF="bibopalica_body.html#SEC3">What's in a Name? -- Naming of Structures</A>).

</P>
<P>
The structures of BIBLIOTHECA OPALICA have been grouped into five
subsystems, some of which have been further divided into subsubsystems. The
user need not be aware of the structure of BIBLIOTHECA OPALICA for
using OPAL and the OPAL Compilation System. Searching for
information about the library is made easier, though, if you know about the
structure.

</P>
<DL COMPACT>

<DT><CODE>Internal</CODE>
<DD>
The subsystem <CODE>Internal</CODE> contains structures which are dependent on the
actual implementation.

<DT><CODE>BasicTypes</CODE>
<DD>
In this subsystem the "bread-and-butter" structures are compiled. This
includes structures for handling booleans, denotations (see  <A HREF="bibopalica_body.html#SEC28">String vs. Denotation</A>),
characters and numbers (see  <A HREF="bibopalica_body.html#SEC27">Numbers</A>). 

<DT><CODE>Functions</CODE>
<DD>
This subsystem contains structures for creating functions from other
functions.

<DT><CODE>AggregateTypes</CODE>
<DD>
Aggregates allow you to group elements together and treat them
as a single entity. There are heterogeneous aggregates, such as Cartesian
products and disjoint union, as well as homogeneous aggregates, such as
sequences (a.k.a. lists), binary trees, sets, mappings and the like.

<DT><CODE>System</CODE>
<DD>
Structures in the Subsystem <CODE>System</CODE> provide access to the
environment. This encompasses structures for debugging, access to the
facilities of the operating system and, last but not least, structures for
input and output.

</DL>


<UL>
<LI><A HREF="bibopalica_body.html#SEC6">Internal</A>
<LI><A HREF="bibopalica_body.html#SEC8">BasicTypes</A>
<LI><A HREF="bibopalica_body.html#SEC9">Functions</A>
<LI><A HREF="bibopalica_body.html#SEC13">AggregateTypes</A>
<LI><A HREF="bibopalica_body.html#SEC20">System</A>
</UL>



<H2><A NAME="SEC6" HREF="bibopalica_toc.html#TOC6">Internal</A></H2>

<P>
The subsystem <CODE>Internal</CODE> is divided into further subsystems. The user sees only the subsubsystem <CODE>Strange</CODE>.

</P>

<UL>
<LI><A HREF="bibopalica_body.html#SEC7">Strange</A>
</UL>



<H3><A NAME="SEC7" HREF="bibopalica_toc.html#TOC7">Strange</A></H3>

<P>
As the name suggests, these structures are not for everyday use. They do
have their purpose, but think twice before you use them. They are not
semantically safe and, in most cases, you will be able to do very well
without them.

</P>
<DL COMPACT>

<DT><CODE>CAST</CODE>
<DD>
gives you the possibility of lying about the type of an expression. There is
no guarantee about any properties of the result. In particular, you may not
assume that <CODE>cast[a,b](cast[b,a](x))</CODE> yields <CODE>x</CODE> again, and be
assured that casting, say <CODE>pair[nat, char]</CODE> to
<CODE>seq[option[string]]</CODE>, will cause considerable confusion.

<DT><CODE>EQUALITY</CODE>
<DD>
provides a generic equality on data types which do not
contain functions. Note that this constraint is not checked by the
compiler.

<DT><CODE>INLINE</CODE>
<DD>
provides an interface to usage of C macros. This is only useful in
connection with handcoding(see  <A HREF="bibopalica_body.html#SEC26">Handcoded Structures</A>).

</DL>



<H2><A NAME="SEC8" HREF="bibopalica_toc.html#TOC8">BasicTypes</A></H2>

<P>
Basic Types are finitely or infinitely enumerable types. Currently, the
following types are members of this subsystem:

</P>
<DL COMPACT>

<DT><CODE>bool</CODE>
<DD>
<A NAME="IDX1"></A>
As noted before, <CODE>bool</CODE> is a built-in sort. The predefined functions
can be looked up in structure <CODE>BOOL</CODE>. Another structure allows for
converting <CODE>bool</CODE> to <CODE>denotation</CODE>.

<DT><CODE>char</CODE>
<DD>
<A NAME="IDX2"></A>
Apart from the basic operations, there is a structure <CODE>PrintableChar</CODE>
which contains definitions for the ASCII character set.

<DT><CODE>denotation</CODE>
<DD>
<A NAME="IDX3"></A>
The type <CODE>denotation</CODE> is predefined. The predefined signature is called
<CODE>DENOTATION</CODE>.  The structure <CODE>Denotation</CODE> supplies additional
functions which make usage of denotations possible.

<DT><CODE>nat, int, real</CODE>
<DD>
<A NAME="IDX4"></A>
<A NAME="IDX5"></A>
<A NAME="IDX6"></A>
These structures deliver the usual functions on the different kinds of
numbers. Note that identifiers like <CODE>64</CODE> are not special to OPAL ---
they are like any other identifier. Hence you have to define other
numbers for yourself. The advice is to define a constant with an appropriate
name, e.g. <SAMP>`DEF hashtablesize == "497"!'</SAMP>.

The functions <CODE>!</CODE> are very strict and do not accept anything besides
the indicated characters ("anything" includes whitespace!). This is to
prevent you from typing mistakes<A NAME="DOCF1" HREF="bibopalica_foot.html#FOOT1">(1)</A>.

<DT><CODE>rel, subrel</CODE>
<DD>
<A NAME="IDX7"></A>
<A NAME="IDX8"></A>
These structures contain types which are used to indicate a result of a
comparison with functions found in a <VAR>Type</VAR>Compare structure.

<DT><CODE>void</CODE>
<DD>
<A NAME="IDX9"></A>
This is the simplest data type. It consists of exactly one constant
constructor <CODE>nil</CODE>.

<DT><CODE>ABORT</CODE>
<DD>
is sort of an annotated "undefined". Use this structure to give the user of
your OPAL programs hints as to what might have gone wrong. It is a good
idea to add the source, that is, name and origin of the function, to the
message. See  <A HREF="bibopalica_body.html#SEC29">ABORT</A>.

</DL>



<H2><A NAME="SEC9" HREF="bibopalica_toc.html#TOC9">Functions</A></H2>

<P>
The <CODE>Functions</CODE> subsystem is divided into three parts: <CODE>General</CODE>
for composition, iteration and the like, <CODE>Orderings</CODE> for constructing
ordering relations, and <CODE>Special</CODE> for structures which need special
care in their usage.

</P>

<UL>
<LI><A HREF="bibopalica_body.html#SEC10">General</A>
<LI><A HREF="bibopalica_body.html#SEC11">Orderings</A>
<LI><A HREF="bibopalica_body.html#SEC12">Special</A>
</UL>



<H3><A NAME="SEC10" HREF="bibopalica_toc.html#TOC10">General</A></H3>

<DL COMPACT>

<DT><CODE>funct</CODE>
<DD>
<A NAME="IDX10"></A>
This structure allows a function type to be "packed" in a data type.

<DT><CODE>Compose, ComposePar</CODE>
<DD>
These structures define functions for composing two functions either
sequentially or concurrently.

<DT><CODE>Control</CODE>
<DD>
This structure offers you basic control structures for iterating functions.

<DT><CODE>Predicate</CODE>
<DD>
This structure allows you to combine bool-valued functions almost the same
way boolean values can be combined. Of course, no equality on functions can
be defined in OPAL.

</DL>



<H3><A NAME="SEC11" HREF="bibopalica_toc.html#TOC11">Orderings</A></H3>

<P>
When defining an (enumerated) type, defining the ordering relations by
yourself can often be both tedious and lead to errors. The structures in
this subsystem facilitate the task:

</P>
<DL COMPACT>

<DT><CODE>OrderingByInjection</CODE>
<DD>
This structure is to be instantiated with an injection into the natural
numbers and then yields the usual ordering relations.

<DT><CODE>OrderingByLess</CODE>
<DD>
Use of this structure requires still to define the "less" relation, but
relieves you of defining the other operations.

<DT><CODE>InducedRel</CODE>
<DD>
This structure is more general than the previous two. You may translate any
relation to another type by supplying an appropriate translation function.

</DL>



<H3><A NAME="SEC12" HREF="bibopalica_toc.html#TOC12">Special</A></H3>

<P>
Functions provided by structures of this subsystem generally come with the
warnings "handle with care" and "use only, if you know what you are doing".

</P>
<DL COMPACT>

<DT><CODE>AcceleratorC, AcceleratorF</CODE>
<DD>
The purpose of these structures is a cost-effective evaluation of binary
functions, which is often available if both arguments are known to be
equal. Sometimes it is possible to apply a quick (but somewhat dirty) test
for equality, which may fail even if both arguments are equal, but which
never yields true if they are not.

</DL>



<H2><A NAME="SEC13" HREF="bibopalica_toc.html#TOC13">AggregateTypes</A></H2>

<P>
The concept of aggregating elements to a single entity is one of the most
important in functional programming. BIBLIOTHECA OPALICA offers you
many different ways to do this:

</P>

<UL>
<LI>

Product types correspond to Cartesian products of different data types.

<LI>

Union types allow for the disjoint union of data types.

<LI>

Sequence-like types comprehend elements of a single data type while
preserving order.

<LI>

Tree-like data types structure data in the form of binary trees.

<LI>

Set-like data types differ from sequence-like data types in that order does
not matter.

<LI>

Map-like data types contain pairs of data types which constitute finite
mappings.

</UL>


<UL>
<LI><A HREF="bibopalica_body.html#SEC14">ProductLike</A>
<LI><A HREF="bibopalica_body.html#SEC15">UnionLike</A>
<LI><A HREF="bibopalica_body.html#SEC16">SeqLike</A>
<LI><A HREF="bibopalica_body.html#SEC17">TreeLike</A>
<LI><A HREF="bibopalica_body.html#SEC18">SetLike</A>
<LI><A HREF="bibopalica_body.html#SEC19">MapLike</A>
</UL>



<H3><A NAME="SEC14" HREF="bibopalica_toc.html#TOC14">ProductLike</A></H3>

<P>
This subsystem contains structures for the use of Cartesian products of
types. Our experience is that more than four sorts are usually not needed.

</P>
<P>
Type <CODE>void</CODE> may be considered as the empty product (see  <A HREF="bibopalica_body.html#SEC8">BasicTypes</A>).

</P>
<DL COMPACT>

<DT><CODE>pair, triple, quad</CODE>
<DD>
<A NAME="IDX11"></A>
<A NAME="IDX12"></A>
<A NAME="IDX13"></A>
For these structures functions are provided to build and to unbuild objects,
to select components, to map a function onto the components. Additionally,
<CODE>pair</CODE> can be compared. Note, that type <CODE>quad</CODE> is defined in the
Structure <CODE>Quadruple</CODE>.

<DT><CODE>AnonPair, AnonTriple, AnonQuadruple</CODE>
<DD>
These "anonymous" structures are like their named counterparts, but they
refer to the built-in tupling of data types in OPAL which are denoted
by the keyword <CODE>**</CODE>. Hence, only the selectors are defined.

</DL>



<H3><A NAME="SEC15" HREF="bibopalica_toc.html#TOC15">UnionLike</A></H3>

<P>
This subsystem contains structures for disjoint union of data types.

</P>
<P>
Type <CODE>void</CODE> may be considered as the empty union (see  <A HREF="bibopalica_body.html#SEC8">BasicTypes</A>).

</P>
<DL COMPACT>

<DT><CODE>option</CODE>
<DD>
<A NAME="IDX14"></A>
This is the most important type in this subsystem. It is the disjoint union
of type <CODE>void</CODE> (see  <A HREF="bibopalica_body.html#SEC8">BasicTypes</A>) with an arbitrary other data type.

This type is useful for fusing two functions like <CODE>test? : some -&#62;
bool</CODE> and <BR><CODE>select: some -&#62; data</CODE> (where <CODE>select</CODE> is undefined
when <CODE>test?</CODE> fails) into a single function <CODE>testAndSelect: some -&#62;
option[data]</CODE>.

<DT><CODE>union</CODE>
<DD>
<A NAME="IDX15"></A>
<A NAME="IDX16"></A>
<A NAME="IDX17"></A>
This type comes in three flavours: as union of two, three or four data types.

</DL>



<H3><A NAME="SEC16" HREF="bibopalica_toc.html#TOC16">SeqLike</A></H3>

<P>
Here you will find structures for dealing with aggregate types where number
and ordering of elements matters.

</P>
<DL COMPACT>

<DT><CODE>seq</CODE>
<DD>
<A NAME="IDX18"></A>
By far the most frequently used type in functional programming is the
sequence (or list) type. Consequently, this type is well supported by many
structures. Besides the structures which are explained by their names
(see  <A HREF="bibopalica_body.html#SEC3">What's in a Name? -- Naming of Structures</A>), there are structures for indexing sequences
(<CODE>SeqIndex</CODE>), special variants of mapping (<CODE>SeqMapEnv</CODE>),
structures for dealing with nested sequences (<CODE>SeqOfSeq</CODE>), for sorting
sequences (<CODE>SeqSort</CODE>) and for combining sequences of equal length
(<CODE>SeqZip</CODE>).

<DT><CODE>string</CODE>
<DD>
<A NAME="IDX19"></A>
The type <CODE>string</CODE> can essentially be treated as an instantiation of
type <CODE>seq</CODE> with type <CODE>char</CODE>. Some additional functions, which
ensure backwards compatibility with the old library, are also available.
There is no structure for nested strings or for combining two strings of the
same length; the comparison operators are defined in the base structure.

For a discussion about the difference to type <CODE>denotation</CODE>, see
 <A HREF="bibopalica_body.html#SEC28">String vs. Denotation</A>.

<DT><CODE>union</CODE>
<DD>
<A NAME="IDX20"></A>
This type is defined in structure <CODE>BTUnion</CODE> and is a disjoint union of
basic types, i.e. <CODE>bool, nat, int, real, char, string</CODE> and
<CODE>denotation</CODE>. It is used in the structures for formatted input and
output.

<DT><CODE>StringFormat, StringScan</CODE>
<DD>
These structures contain functions for formatted input and output of the
types which are combined in the type <CODE>union'BTUnion</CODE>. The usage is
similar to that of the functions <CODE>printf</CODE> and <CODE>scanf</CODE> from
<CODE>C</CODE>, so that usage of the functions from BIBLIOTHECA OPALICA
should be no more difficult than use of the functions from <CODE>stdio</CODE> of
ANSI-C.

</DL>



<H3><A NAME="SEC17" HREF="bibopalica_toc.html#TOC17">TreeLike</A></H3>

<P>
Tree-like aggregates store the data in binary trees. We have general binary
trees (in the following often simply called <STRONG>trees</STRONG>), heaps and balanced
search trees.

</P>
<DL COMPACT>

<DT><CODE>tree</CODE>
<DD>
<A NAME="IDX21"></A>
Structures of this family implement functions for binary
trees. <CODE>~'TreeCompare</CODE> compares trees of differenty types. The other
members of this family are standard (see  <A HREF="bibopalica_body.html#SEC3">What's in a Name? -- Naming of Structures</A>). Note that
there are more variants of mapping and reducing functions than e.g. on
sequences. 

<DT><CODE>IndexingOfTrees</CODE>
<DD>
This structure contains functions which handle indices of trees and are
independent of the element type. Trees are indexed by the followign scheme:
The root node is assigned index <I>0</I>, and if any node has index <I>i</I>, the
left child has index <I>2i+1</I>, the right child has index <I>2i+2</I>. (This
differs from other indexing schemes, since we assign <I>0</I> to the root node.)

<DT><CODE>heap</CODE>
<DD>
<A NAME="IDX22"></A>
Heaps are trees whose root value is less or equal than either one of the
children's values. In addition to trees, we can combine heaps and extract
the minimum, so you may use this data type for a priority queue.

<DT><CODE>bstree'BSTree</CODE>
<DD>
<A NAME="IDX23"></A>
Balanced search trees are trees whose root value is greater than the value
of the left child and is less than the value of the right child. The trees
are balanced, that is, sizes of both subtrees must be similar. (Actually,
the criterion is <CODE>1/w &#60;= size(left) / size(right) &#60;= w</CODE>, where <CODE>w</CODE>
is a small positive natural number.)

</DL>



<H3><A NAME="SEC18" HREF="bibopalica_toc.html#TOC18">SetLike</A></H3>

<P>
Set-like aggregates are similar to sequences, but order of elements does not
matter, and in most cases it also does not matter how often an element is
added to an aggregate.

</P>
<P>
There are five different implementations of sets. This plentifulness shows
that there is no ideal implementation for every purpose. The advantages and
disadvantages of the additional implementations are given below.

</P>
<DL COMPACT>

<DT><CODE>set'Set</CODE>
<DD>
<A NAME="IDX24"></A>
This family of structures defines functions for finite
sets. <CODE>SetConstr</CODE> comprises functions for Cartesian product and
disjoint union of sets, the other structures adhere to the naming principles
(see  <A HREF="bibopalica_body.html#SEC3">What's in a Name? -- Naming of Structures</A>). All structures take as an additional
parameter an ordering predicate, otherwise functions like <CODE>subset</CODE> or
<CODE>in</CODE> cannot be implemented<A NAME="DOCF2" HREF="bibopalica_foot.html#FOOT2">(2)</A>.

<DT><CODE>set'SetByInj</CODE>
<DD>
<A NAME="IDX25"></A>
These structures provide a slightly different interface. Instead of an
ordering predicate you must supply an injection into the natural numbers. 

<DT><CODE>set'SetByPred</CODE>
<DD>
<A NAME="IDX26"></A>
These sets are defined by a describing predicate. This is useful if you want
to perform operations on big sets with short descriptive predicates, and it
is a device for dealing with infinite sets in OPAL. The disadvantage
is that many functions on sets (e.g. equality, subset) are not computable for
these sets and can therefore not be implemented.

<DT><CODE>set'SetByBST</CODE>
<DD>
<A NAME="IDX27"></A>
These sets are represented internally by balanced search trees and are more
efficient in including, excluding and searching single elements than the
standard implementation.

<DT><CODE>set'Bitset</CODE>
<DD>
<A NAME="IDX28"></A>
The naming of this family of structures is really an anachronism -- a
better name would be <CODE>SetOfNat</CODE>. This type is handcoded and provides an
efficient (with respect to time and space) device for dealing with sets of
small natural numbers.

<DT><CODE>bag</CODE>
<DD>
<A NAME="IDX29"></A>
Bags (sometimes called multi-sets) are similar to sets, but the frequency of
elements matters. So some additional functions on bags are available;
otherwise they are treated in the same way as the standard implementation of
sets (<CODE>set'Set</CODE>).

</DL>



<H3><A NAME="SEC19" HREF="bibopalica_toc.html#TOC19">MapLike</A></H3>

<P>
Here you can find structures which implement finite mappings.

</P>
<DL COMPACT>

<DT><CODE>map</CODE>
<DD>
<A NAME="IDX30"></A>
This is the type for general finite mappings. For an efficient
implementation, an ordering relation on the domain type must be
provided. Reducing and mapping is defined on the codomain, filtering checks
both components of a pair. Additional functions are provided for inverting a
map (<CODE>MapInvert</CODE>) and for composing two maps (<CODE>MapCompose</CODE>).

<DT><CODE>array</CODE>
<DD>
<A NAME="IDX31"></A>
This is a handcoded mapping from natural numbers to an arbitrary data
type. Indices start at 0. The order on natural numbers induces an order of
elements, so both variations of fold and reduce are available

</DL>



<H2><A NAME="SEC20" HREF="bibopalica_toc.html#TOC20">System</A></H2>

<P>
This subsystem subsumes all structures which provide functions for
communicating in some manner with the environment. It is in turn divided
into four subsystems: <CODE>Debugging</CODE> contains structures for support in
debugging OPAL programs (surprise, surprise!), <CODE>Commands</CODE> provides
the basic declarations for the OPAL Command Script I/O, the structures
in <CODE>Streams</CODE> define a simple interface for accessing files, and
<CODE>Unix</CODE> contains structures tailored for OPAL programs which run
under <CODE>Unix</CODE>.

</P>


<UL>
<LI><A HREF="bibopalica_body.html#SEC21">Debugging</A>
<LI><A HREF="bibopalica_body.html#SEC22">Commands</A>
<LI><A HREF="bibopalica_body.html#SEC23">Streams</A>
<LI><A HREF="bibopalica_body.html#SEC24">Unix</A>
</UL>



<H3><A NAME="SEC21" HREF="bibopalica_toc.html#TOC21">Debugging</A></H3>

<P>
This subsystem contains just one structure, which in our opinion could not
be assigned to any of the other subsystems.

</P>
<DL COMPACT>

<DT><CODE>DEBUG</CODE>
<DD>
This structure contains functions which aid in debugging by means of
side-effect output of messages. This constitutes dirty programming style and
should not be used in your ready-to-be-shipped program, but sometimes
debugging is quicker when you don't quite stick to the rules.

</DL>



<H3><A NAME="SEC22" HREF="bibopalica_toc.html#TOC22">Commands</A></H3>

<P>
This subsystem comprises structures which define functions on
<VAR>commands</VAR> which are the base type for the OPAL Command Script I/O,
and some structures for communicating with the environment which are
independent from the underlying operating system.

</P>
<DL COMPACT>

<DT><CODE>com</CODE>
<DD>
<A NAME="IDX32"></A>
The command type <CODE>com</CODE> is essential for I/O in OPAL. It is
always parameterized with the type which is to be passed to the next
command. If there is no such type, you have to use type <CODE>void</CODE>
(see  <A HREF="bibopalica_body.html#SEC8">BasicTypes</A>). <CODE>ComAction</CODE> defines abbreviations for the
instance <CODE>com[void]</CODE>. Means for composing commands are given in
<CODE>ComCompose</CODE> and <CODE>ComCheck</CODE>; <CODE>ComSeqReduce</CODE> reduces a
sequence to a single command. <CODE>ComChoice</CODE> finally provides external
choice between two commands.

<DT><CODE>agent'ComAgent[result]</CODE>
<DD>
<A NAME="IDX33"></A>
An agent executes a monadic command concurrently with other
agents. Communication between agents is supported by synchronization
with the termination of an agent and by client/server oriented
communication via service access points (see structure
<CODE>ComService</CODE>). A special command for delaying an agent is provided
in the structure <CODE>ComTimeout</CODE>.

<DT><CODE>sap'ComService[in, out]</CODE>
<DD>
<A NAME="IDX34"></A>
This structure provides a model for agent communication based on the
client / server approach.  Client and servers communicate via so-called
service access points (SAPs).

<DT><CODE>Env</CODE>
<DD>
This structure provides access to arguments with which the program was
called, and to the environment variables. 

<DT><CODE>Random</CODE>
<DD>
This structure implements a pseudo random number generator.
</DL>



<H3><A NAME="SEC23" HREF="bibopalica_toc.html#TOC23">Streams</A></H3>

<P>
Streams are a simple and abstract means for reading or writing data from or
to a file.

</P>
<DL COMPACT>

<DT><CODE>Stream</CODE>
<DD>
This is the basic structure and contains functions for text input and output.

<DT><CODE>BinStream</CODE>
<DD>
This structure contains functions for reading and writing arbitrary data
types. Since the files contain no information about the type which was
written into them, strong typing is violated. You can use a tag to identify
the correct file type for yourself. Note that this tag is internally
augmented to ensure that the binary format used by internal routines is the
same.

</DL>



<H3><A NAME="SEC24" HREF="bibopalica_toc.html#TOC24">Unix</A></H3>

<P>
The structures described here are tailored especially for the Unix operating
system. If OPAL is ever run under another operating system, these
structures will most likely be missing.

</P>
<P>
For the current release, several structures have been added, which provide
Posix conformant access to system calls. See below under <CODE>ProcessCtrl</CODE>,
<CODE>Signal</CODE>, <CODE>UserAndGroup</CODE> and <CODE>Wait</CODE>.

</P>

<DL COMPACT>

<DT><CODE>file</CODE>
<DD>
<A NAME="IDX35"></A>
The structures <CODE>File</CODE> and <CODE>BinFile</CODE> correspond roughly to
<CODE>Stream</CODE> and <CODE>BinStream</CODE> (see  <A HREF="bibopalica_body.html#SEC23">Streams</A>). They provide functions
for input and output to and from files but are more flexible than the
structures in the subsystem <CODE>Stream</CODE>.

<DT><CODE>FileSystem</CODE>
<DD>
<A NAME="IDX36"></A>
<A NAME="IDX37"></A>
<A NAME="IDX38"></A>
<A NAME="IDX39"></A>
<A NAME="IDX40"></A>
<A NAME="IDX41"></A>
This structure provides access to the Unix file system. This structure
contains functions for accessing Unix file attributes like file types,
file modes, inodes, devices, atime, ctime, mtime; working with (hard and
symbolic) links,
renaming files, changing access permissions, working on directories and
creating named pipes.

<CODE>FileSystemFun</CODE> contains some convenient functions for dealing with
file modes.

<DT><CODE>ProcessCtrl</CODE>
<DD>
<A NAME="IDX42"></A>
<A NAME="IDX43"></A>
<A NAME="IDX44"></A>
This structure is the successor of <CODE>Process</CODE> which is no longer
supported but still contained. It provides functions for creating,
terminating, mutate processes, getting information about one's own process,
and changing some of the attributes of a Unix process (group ids, working
directory and the like).

<DT><CODE>Signal</CODE>
<DD>
<A NAME="IDX45"></A>
<A NAME="IDX46"></A>
<A NAME="IDX47"></A>
<A NAME="IDX48"></A>
This structure enables the user to deal with signals from an OPAL
program. There exist functions for masking signals, sending signals, waiting
for signals and there is also a limited capability for handling signals.

<DT><CODE>time</CODE>
<DD>
<A NAME="IDX49"></A>
<A NAME="IDX50"></A>
These structures allow you to access system time from within OPAL.

<DT><CODE>UserAndGroup</CODE>
<DD>
<A NAME="IDX51"></A>
<A NAME="IDX52"></A>
<A NAME="IDX53"></A>
<A NAME="IDX54"></A>
This structure provides functions for managing information about Unix users,
Unix groups and their ids.

<DT><CODE>UnixFailures</CODE>
<DD>
This structure contains definitions for constants which describe all
possible causes of failure.

<DT><CODE>Wait</CODE>
<DD>
<A NAME="IDX55"></A>
In this structure you will find functions which enable you to wait for the
children of the current process.

</DL>



<H1><A NAME="SEC25" HREF="bibopalica_toc.html#TOC25">Special Features in BIBLIOTHECA OPALICA</A></H1>


<UL>
<LI><A HREF="bibopalica_body.html#SEC26">Handcoded</A>
<LI><A HREF="bibopalica_body.html#SEC27">Numbers</A>
<LI><A HREF="bibopalica_body.html#SEC28">Text</A>
<LI><A HREF="bibopalica_body.html#SEC29">ABORT</A>
</UL>



<H2><A NAME="SEC26" HREF="bibopalica_toc.html#TOC26">Handcoded Structures</A></H2>

<P>
Some structures in BIBLIOTHECA OPALICA are not implemented in OPAL, rather are handcoded and implemented in the target language of the OPAL
compiler. This is done for two different reasons.

</P>
<P>
One reason is that access to the environment must be provided by some kind
of runtime system. This runtime system is not one monolithic block of code
with which every OPAL program is burdened. Instead, each structure
which accesses different parts of the environment adds only the
necessary code.

</P>
<P>
The other reason is that some basic data types are already supported by the
target language. So, for reasons of efficiency, some data types have been
handcoded. In contrast to the structures which provide access to the
environment, these structures could have been implemented in OPAL.

</P>
<P>
If, for either of these reasons, you wish to add some handcoded structures
to your system, you are kindly referred to the <CITE>Handcoder's Guide</CITE>
which is included in the OPAL distribution.

</P>



<H2><A NAME="SEC27" HREF="bibopalica_toc.html#TOC27">Numbers</A></H2>

<P>
Numbers belong to the family of handcoded structures
(see  <A HREF="bibopalica_body.html#SEC26">Handcoded Structures</A>). You should never make assumptions about possible sizes
of numbers, since these may change in later releases of BIBLIOTHECA
OPALICA. Use the constants <CODE>min</CODE> and <CODE>max</CODE> wherever possible.

</P>
<P>
The following (in)equalities are guaranteed to hold
in every implementation of OPAL:

</P>
<P>
<CODE>min'Nat = 0</CODE><BR>
<CODE>max'Nat &#62;= 1073741822</CODE><BR>
<BR>
<CODE>min'Int &#60;= -536870911</CODE><BR>
<CODE>max'Int &#62;=  536870910</CODE><BR>
<BR>
<CODE>min'Real &#60;= -1e+37</CODE><BR>
<CODE>max'Real &#62;=  1e+37</CODE>

</P>
<P>
The current implementation exceeds these bounds.

</P>



<H2><A NAME="SEC28" HREF="bibopalica_toc.html#TOC28">String vs. Denotation</A></H2>

<P>
In BIBLIOTHECA OPALICA two types designed for textual representation
are available namely <CODE>denotation</CODE> and
<CODE>string</CODE>. Both are implemented differently.

</P>
<P>
The type <CODE>denotation</CODE> should be used for text which does not change
very often, since insertions and deletions are relatively expensive. Space
requirements, on the other hand, are low. This type is best used for
messages and constant strings.

</P>
<P>
The type <CODE>string</CODE> has a user interface which is almost identical to
that of sequences. In particular, all higher-order functions are available
for strings, so operations on texts can now directly be defined on type
<CODE>string</CODE>.  Note that strings are implemented differently than
sequences, so operations on strings are faster than operations on sequences
of character, and space consumption is lower.

</P>


<H2><A NAME="SEC29" HREF="bibopalica_toc.html#TOC29">ABORT</A></H2>

<P>
<CODE>ABORT</CODE> is a special function. It is essentially a function which
yields the undefined value of the parameter type. Hence, you can use this
function to replace the automatically inserted error messages with your own
messages, which may provide more information about the real cause.

</P>
<P>
The most interesting feature about <CODE>ABORT</CODE> is that tests for
<CODE>ABORT</CODE> are eliminated completely if the optimization switch <CODE>-op</CODE>
is set. Thus, you can develop your program with informative error messages,
then turn on the compiler switch and eliminate all the (expensive) checks
for definedness.

</P>



<H1><A NAME="SEC30" HREF="bibopalica_toc.html#TOC30">Acknowledgement</A></H1>

<P>
BIBLIOTHECA OPALICA is only the latest development of the OPAL
library.

</P>
<P>
The predecessor of BIBLIOTHECA OPALICA was designed by <I>Wolfram
Schulte</I>, together with <I>Andreas Fett</I> and <I>Gottfried Egger</I>; the
structures which are now found in subsystem <CODE>Commands</CODE> were designed by
<I>Gottfried Egger</I> and <I>Wolfram Schulte</I>.

</P>
<P>
The restructuring of the library is the result of fruitful discussions with
<I>Wolfgang Grieskamp</I>, <I>Joachim Faulhaber</I>,
<I>Mario S@"udholt</I>
and <I>Sabine Dick</I>.

</P>
<P>
The library has profited from many suggestions from (in alphabetical order)
<I>Olaf Brandes</I>, <I>Christoph Breitkopf</I>, <I>Gottfried Egger</I>, <I>Sebastian
Erdmann</I>, <I>Andreas Fett</I>, <I>Christian Maeder</I> and <I>Burkhart Wolff</I>.

</P>
<P>
The text was carefully proofread by <I>Niamh Warde</I>.

</P>


<H1><A NAME="SEC31" HREF="bibopalica_toc.html#TOC31">Bugs And Flaws</A></H1>

<P>
There are currently no known bugs or flaws in BIBLIOTHECA OPALICA.

</P>



<H1><A NAME="SEC32" HREF="bibopalica_toc.html#TOC32">Changes in OPAL programs necessitated by BIBLIOTHECA OPALICA</A></H1>

<P>
When a new library for OPAL was announced, some people feared they
would have to forget all they knew about the old version, and learn the
whole new library from scratch. This is not the case.

</P>
<P>
The most important change is the finer structuring. The old library was
divided into three subsystems, two of which were of no interest for ordinary
users. Now, BIBLIOTHECA OPALICA is divided into many sub- and
subsubsystems. 
The structuring has no significance for the user as far as the
OPAL Compilation System is concerned.

</P>
<P>
The other important change is the treatment of text, which involves the
types <CODE>denotation</CODE> and <CODE>string</CODE>. This is detailed in  <A HREF="bibopalica_body.html#SEC28">String vs. Denotation</A>.

</P>

<P>
BIBLIOTHECA OPALICA is highly, but not fully compatible with the former
library. Code which was written using the old library has to be
adapted. We distinguish two kinds of adaptations:

</P>

<UL>

<LI>

Relocations involve only <CODE>IMPORT</CODE> statements. You will have to add some
<CODE>IMPORT</CODE> statements which reflect the finer structuring of
BIBLIOTHECA OPALICA.

<LI>

Incompatibilities require change of code in function declarations and
definitions.

</UL>

<P>
We will first specify the incompatibilities and then list old library
structures with the changes they each require. The treatment of text is
considered in a separate section.

</P>

<UL>
<LI><A HREF="bibopalica_body.html#SEC33">Incompatibilities</A>
<LI><A HREF="bibopalica_body.html#SEC40">List of Old Structures</A>
<LI><A HREF="bibopalica_body.html#SEC41">Treatment of Text</A>
</UL>



<H2><A NAME="SEC33" HREF="bibopalica_toc.html#TOC33">Incompatibilities</A></H2>


<UL>
<LI><A HREF="bibopalica_body.html#SEC34">Bitset</A>
<LI><A HREF="bibopalica_body.html#SEC35">Conversion</A>
<LI><A HREF="bibopalica_body.html#SEC36">denotation constants</A>
<LI><A HREF="bibopalica_body.html#SEC37">Natural Numbers</A>
<LI><A HREF="bibopalica_body.html#SEC38">Section</A>
<LI><A HREF="bibopalica_body.html#SEC39">Suspend</A>
</UL>



<H3><A NAME="SEC34" HREF="bibopalica_toc.html#TOC34">Bitset</A></H3>

<P>
The name of the sort has changed from <CODE>bitset</CODE> to <CODE>set</CODE>. The
function <CODE>maxBit</CODE> no longer exists, since these sets are no longer
bounded.

</P>


<H3><A NAME="SEC35" HREF="bibopalica_toc.html#TOC35">Conversion</A></H3>

<P>
The <CODE>format</CODE> and <CODE>scan</CODE> functions from <CODE>Conversion</CODE> (which have
been relocated) formerly interpreted the backslash combinations
(<CODE>\n</CODE>, <CODE>\x41</CODE>, etc.)
themselves, even in strings. Since denotation
constants are interpreted differently now, this feature has been removed.

</P>
<P>
The functions <CODE>! :</CODE> <VAR>basictype</VAR><CODE> -&#62; string</CODE> (where
<VAR>basictype</VAR> is one of <CODE>bool, char, nat, int, real</CODE>) have been
replaced by <CODE> ` : </CODE><VAR>basictype</VAR><CODE>-&#62; denotation</CODE> in structure
<VAR>Basictype</VAR><CODE>Conv</CODE> (see  <A HREF="bibopalica_body.html#SEC3">What's in a Name? -- Naming of Structures</A>).  So you need to
change all applications of these functions, e.g. <CODE>5!</CODE> to <CODE>!(5`)</CODE>
(where the first <CODE>!</CODE> has origin <CODE>String</CODE>) in order to get an
equivalent expression. For treatment of text, see also  <A HREF="bibopalica_body.html#SEC41">Treatment of Text</A>.

</P>


<H3><A NAME="SEC36" HREF="bibopalica_toc.html#TOC36">Constants of type <CODE>denotation</CODE></A></H3>

<P>
Denotation constants are now interpreted in a C-like way, i.e. combinations
like <CODE>\n</CODE>, <CODE>\x41</CODE>, etc. are now interpreted as a single
character. The only exception is <CODE>\"</CODE>, which is interpreted as end of
text. To denote a single <CODE>\</CODE>, write <CODE>\\</CODE>.

</P>


<H3><A NAME="SEC37" HREF="bibopalica_toc.html#TOC37">Natural Numbers</A></H3>

<P>
The constant <CODE>max'Nat</CODE> was raised and is no longer convertible to an
object of type <CODE>int</CODE>. Strictly speaking, this is not an
incompatibility, since this was never guaranteed, but since quite a few
people seem to have relied on this fact we record it here.

</P>
<P>
If you assumed <CODE>asInt(max'Nat)</CODE> to be defined, you will get a runtime
error message which says <CODE>asInt'NatConv: natural too large</CODE>. A quick
remedy is to replace occurrences of <CODE>max'Nat</CODE> by <CODE>asNat(max'Int)</CODE>,
but this is a little bit awkward. A better (but more time consuming)
solution is to check whether your program needs either objects of type
<CODE>int</CODE> or of type <CODE>nat</CODE> and to change it as required.

</P>



<H3><A NAME="SEC38" HREF="bibopalica_toc.html#TOC38">Section</A></H3>

<P>
The structure <CODE>Section</CODE> no longer exists. Use lambda expressions
instead of the functions which were supplied by <CODE>Section</CODE>.

</P>


<H3><A NAME="SEC39" HREF="bibopalica_toc.html#TOC39">Suspend</A></H3>

<P>
The structure <CODE>Suspend</CODE> no longer exists. Use lambda expressions
instead of the functions which were supplied by <CODE>Suspend</CODE>.

</P>



<H2><A NAME="SEC40" HREF="bibopalica_toc.html#TOC40">List of Old Structures</A></H2>

<P>
This section contains a list of those structures from the old library which
were modified, and thus necessitate changes in your program.

</P>

<P>
Structures which are "split into" no longer exist. Structures which are
marked "split off" still exist, but some functions now have to be imported
from different structures.

</P>

<P>
Functions which are marked "old fashioned" in BIBLIOTHECA OPALICA
are marked with (+) in the following list.

</P>
<DL COMPACT>

<DT><CODE>ArrayMapReduce</CODE>
<DD>
split into <CODE>ArrayMap</CODE> with function <CODE>*</CODE>, and <CODE>ArrayReduce</CODE>
with function <CODE>/</CODE>.

<DT><CODE>Bag</CODE>
<DD>
split off <CODE>BagFilter</CODE> with function <CODE>|</CODE>, and <CODE>BagConv</CODE> with
functions <CODE>explode(+), implode(+), explodeCt(+), implodeCt(+)</CODE>.

<DT><CODE>Bitset</CODE>
<DD>
sort <CODE>bitset</CODE> renamed <CODE>set</CODE>, function <CODE>maxBit</CODE> no
longer exists.

<DT><CODE>Char</CODE>
<DD>
split off <CODE>CharConv</CODE> with function <CODE>ord(+)</CODE>, and <CODE>NatConv</CODE>
with function <CODE>chr(+)</CODE>.

<DT><CODE>ComData</CODE>
<DD>
renamed <CODE>BinStream</CODE>.

<DT><CODE>ComEnv</CODE>
<DD>
structure is renamed <CODE>Env</CODE>, function <CODE>random</CODE> relocated to
<CODE>Random</CODE>, function <CODE>localtime</CODE> will be relocated to structure
<CODE>Time</CODE>.

<DT><CODE>ComProcess</CODE>
<DD>
has been reimplemented differently. See structures <CODE>Process</CODE> and
<CODE>Pipe</CODE> for adapting your code.

<DT><CODE>ComSocket</CODE>
<DD>
will be renamed <CODE>Socket</CODE>.

<DT><CODE>ComStream</CODE>
<DD>
renamed <CODE>Stream</CODE>.

<DT><CODE>Conversion</CODE>
<DD>
split into <CODE>NatConv</CODE> with function <CODE>! : nat -&#62; string</CODE> renamed
<CODE>` 'NatConv: nat -&#62; denotation</CODE>, (similar for type <CODE>int, bool,
real</CODE> and <CODE>char</CODE>); into <CODE>BTUnion</CODE> with type <CODE>union</CODE> and
function <CODE>u</CODE>; into <CODE>StringFormat</CODE> with function <CODE>format</CODE> and
<CODE>StringScan</CODE> with function <CODE>scan</CODE>.

<DT><CODE>Int</CODE>
<DD>
split off <CODE>IntConv</CODE> with function <CODE>asNat</CODE>, and <CODE>NatConv</CODE> with
function <CODE>asInt</CODE>.

<DT><CODE>Map</CODE>
<DD>
split off <CODE>MapConv</CODE> with function <CODE>explode(+)</CODE> and <CODE>implode(+)</CODE>.

<DT><CODE>MapMapReduce</CODE>
<DD>
split into <CODE>MapMap</CODE> with function <CODE>*</CODE>, and <CODE>MapReduce</CODE> with
function <CODE>/</CODE>.

<DT><CODE>PrintableChar</CODE>
<DD>
function <CODE>_</CODE> renamed <CODE>underscore</CODE>.

<DT><CODE>Real</CODE>
<DD>
split off <CODE>RealConv</CODE> with function <CODE>trunc(+)</CODE>, and <CODE>NatConv</CODE>
with function <CODE>asReal</CODE>.

<DT><CODE>Section</CODE>
<DD>
no longer exists.

<DT><CODE>Seq</CODE>
<DD>
split off <CODE>SeqFilter</CODE> with functions <CODE>|, partition, take, drop,
split</CODE>, and <CODE>SeqIndex</CODE> with functions <CODE>!, slice</CODE>.

<DT><CODE>SeqFun</CODE>
<DD>
split into <CODE>SeqCompare</CODE> with type <CODE>rel</CODE> and functions <CODE>&#60;, =,
&#62;, &#60;?, =?, &#62;?, cmp</CODE> and <CODE>eq?</CODE>, into <CODE>SeqOfSeq</CODE> with function
<CODE>flat</CODE>, and <CODE>SeqSort</CODE> with functions <CODE>msort</CODE> and <CODE>merge</CODE>.

<DT><CODE>SeqMapReduce</CODE>
<DD>
split into <CODE>SeqMap</CODE> with function <CODE>*</CODE>, and <CODE>SeqReduce</CODE> with
functions <CODE>/, \</CODE>.

<DT><CODE>Set</CODE>
<DD>
split off <CODE>SetConv</CODE> with functions <CODE>explode(+)</CODE> and
<CODE>implode(+)</CODE>, and <CODE>SetFilter</CODE> with functions <CODE>|</CODE> and
<CODE>partition</CODE>.

<DT><CODE>SocketInterNet</CODE>
<DD>
will be renamed <CODE>Internet</CODE>.

<DT><CODE>String</CODE>
<DD>
split off <CODE>StringConv</CODE> with functions <CODE>implode(+)</CODE> and
<CODE>explode(+)</CODE>, and <CODE>StringIndex</CODE> with functions <CODE>!, slice,
insert, delete</CODE> and <CODE>:=</CODE>.

<DT><CODE>Suspend</CODE>
<DD>
no longer exists.

</DL>



<H2><A NAME="SEC41" HREF="bibopalica_toc.html#TOC41">Treatment of Text</A></H2>

<P>
One of the novelties in BIBLIOTHECA OPALICA is the different treatment
of the types <CODE>string</CODE> and <CODE>denotation</CODE>. We will discuss here why
we made this change and advise which type to choose in which circumstances. 

</P>
<P>
The situation in the old library was unsatisfactory. First you had the type
<CODE>denotation</CODE>, which was almost unusable, since no functions operated on
denotations (well, one did). Then there was the <CODE>string</CODE> type which,
while it provided a usable interface for simple treatment of text, was not
equipped with a free type. So whenever you wrote an "interesting" function
on text, you first had to convert the string into a sequence of characters,
and, after performing two expensive conversions, you finally had access
to the nice higher-order functions like map, reduce and the like.

</P>
<P>
This has changed in BIBLIOTHECA OPALICA.

</P>
<P>
In principle, the only change you need to make is to adapt the <CODE>IMPORT</CODE>
lines, since all functions on strings have been retained in BIBLIOTHECA
OPALICA.

</P>
<P>
However, you should examine your code, and depending on the usage of text,
choose one of the following approaches:

</P>
<P>
If you have strings that are not changed very often you should
consider changing type <CODE>string</CODE> to type <CODE>denotation</CODE> and 
the <CODE>IMPORT</CODE> line from <CODE>IMPORT String ONLY</CODE> ... to
<CODE>IMPORT Denotation ONLY</CODE> ...

</P>
<P>
The other possibility is that you are working on the text, and will
therefore perform an <CODE>explode</CODE> on the text before you really start
applying functions. In this case you should replace type <CODE>seq[char]</CODE>
with type <CODE>string</CODE> and remove the <CODE>explode</CODE> and <CODE>implode</CODE>
function calls. You will now have to import the functions which you used on
sequences from the corresponding string structures.

</P>



<H1><A NAME="SEC42" HREF="bibopalica_toc.html#TOC42">Designing Structures For Your Own Data Types</A></H1>

<P>
When designing structures for your own data types, you should follow the
principles used for structuring the library itself (see  <A HREF="bibopalica_body.html#SEC3">What's in a Name? -- Naming of Structures</A>).

</P>
<P>
First have a look at the library and search for the most similar type
already available. Perhaps you are missing another arithmetic type, or your
new type can be considered as an aggregate type, or you want to give a
different implementation for a data type which already exists.

</P>
<P>
If you find a similar data type, try to copy the interfaces of the
corresponding structures as far as reasonable. If you give a different
implementation for an existing data type, keep the name of the type.

</P>
<P>
If you want to define a totally new data type, you should nevertheless try
to use names from existing structures which perform a similar task. If
you somehow "select" elements, call that function <CODE>!</CODE>. The
concatenation is called <CODE>++</CODE>, composition is named <CODE>o</CODE> and no
doubt you will find other functions which resemble functions on the new data
type.

</P>
<P>
<EM>Always</EM> define a function <CODE>` : type -&#62; denotation</CODE> (appropriately
augmented if the type is parameterized). There are first experimental
tools, which exploit the fact that for every type <CODE>type</CODE> a conversion
function <CODE>`</CODE> exists in <CODE>TypeConv</CODE>.

</P>
<P>
Try to keep interfaces small. Give a base structure which contains the most
necessary function declarations. Group additional functions into separate
structures. 

</P>
<P>
And do not forget to send us the product of your efforts if you think it 
fills a gap in BIBLIOTHECA OPALICA.

</P>



<H1><A NAME="SEC43" HREF="bibopalica_toc.html#TOC43">Efficiency: What "Not For User Purpose" Really Means</A></H1>

<P>
There are some functions in BIBLIOTHECA OPALICA which are marked "not
for user purpose". The functions in these sections provide access to
internal representations; these are needed for the efficient implementation
of other functions on the same date type, when the data type is located in
another structure.

</P>
<P>
In principle, you may use these functions as you do other functions and
perhaps you gain some additional performance in doing so. You do this at
your own risk, however. We do not guarantee anything about the behaviour of
functions which are marked "not for user purpose"; moreover these functions
are subject to change in later releases of BIBLIOTHECA OPALICA without
further notice.

</P>



<H1><A NAME="SEC44" HREF="bibopalica_toc.html#TOC44">Index of Types</A></H1>
<P>
<p>55 entries</p>
<A NAME="bibopalica_tp"></A>[ <A HREF="#bibopalica_tp_97"> a </A> ] [ <A HREF="#bibopalica_tp_98"> b </A> ] [ <A HREF="#bibopalica_tp_99"> c </A> ] [ <A HREF="#bibopalica_tp_100"> d </A> ] [ <A HREF="#bibopalica_tp_102"> f </A> ] [ <A HREF="#bibopalica_tp_103"> g </A> ] [ <A HREF="#bibopalica_tp_104"> h </A> ] [ <A HREF="#bibopalica_tp_105"> i </A> ] [ <A HREF="#bibopalica_tp_109"> m </A> ] [ <A HREF="#bibopalica_tp_110"> n </A> ] [ <A HREF="#bibopalica_tp_111"> o </A> ] [ <A HREF="#bibopalica_tp_112"> p </A> ] [ <A HREF="#bibopalica_tp_113"> q </A> ] [ <A HREF="#bibopalica_tp_114"> r </A> ] [ <A HREF="#bibopalica_tp_115"> s </A> ] [ <A HREF="#bibopalica_tp_116"> t </A> ] [ <A HREF="#bibopalica_tp_117"> u </A> ] [ <A HREF="#bibopalica_tp_118"> v </A> ] [ <A HREF="#bibopalica_tp_119"> w </A> ] 
<H2><A NAME="bibopalica_tp_97" HREF="#bibopalica_tp">a</A></H2>
<TABLE cellspacing=0 cellpadding=1>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX33" TARGET="bibopalica__body">agent'ComAgent[result]</A></TD></TR>
<TR><TD bgcolor=#ddeeff valign=top><A HREF="bibopalica_body.html#IDX31" TARGET="bibopalica__body">array[data]</A></TD></TR>
</TABLE>
<H2><A NAME="bibopalica_tp_98" HREF="#bibopalica_tp">b</A></H2>
<TABLE cellspacing=0 cellpadding=1>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX29" TARGET="bibopalica__body">bag[data, &#60;]</A></TD></TR>
<TR><TD bgcolor=#ddeeff valign=top><A HREF="bibopalica_body.html#IDX1" TARGET="bibopalica__body">bool</A></TD></TR>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX23" TARGET="bibopalica__body">bstree'BSTree[data, &#60;]</A></TD></TR>
</TABLE>
<H2><A NAME="bibopalica_tp_99" HREF="#bibopalica_tp">c</A></H2>
<TABLE cellspacing=0 cellpadding=1>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX2" TARGET="bibopalica__body">char</A></TD></TR>
<TR><TD bgcolor=#ddeeff valign=top><A HREF="bibopalica_body.html#IDX55" TARGET="bibopalica__body">childstat'Wait</A></TD></TR>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX32" TARGET="bibopalica__body">com[data]</A></TD></TR>
</TABLE>
<H2><A NAME="bibopalica_tp_100" HREF="#bibopalica_tp">d</A></H2>
<TABLE cellspacing=0 cellpadding=1>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX3" TARGET="bibopalica__body">denotation</A></TD></TR>
<TR><TD bgcolor=#ddeeff valign=top><A HREF="bibopalica_body.html#IDX37" TARGET="bibopalica__body">device'FileSystem</A></TD></TR>
</TABLE>
<H2><A NAME="bibopalica_tp_102" HREF="#bibopalica_tp">f</A></H2>
<TABLE cellspacing=0 cellpadding=1>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX35" TARGET="bibopalica__body">file</A></TD></TR>
<TR><TD bgcolor=#ddeeff valign=top><A HREF="bibopalica_body.html#IDX40" TARGET="bibopalica__body">filemode'FileSystem</A></TD></TR>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX41" TARGET="bibopalica__body">filestat'FileSystem</A></TD></TR>
<TR><TD bgcolor=#ddeeff valign=top><A HREF="bibopalica_body.html#IDX38" TARGET="bibopalica__body">filetype'FileSystem</A></TD></TR>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX44" TARGET="bibopalica__body">fission'ProcessCtrl</A></TD></TR>
<TR><TD bgcolor=#ddeeff valign=top><A HREF="bibopalica_body.html#IDX10" TARGET="bibopalica__body">funct[from, to]</A></TD></TR>
</TABLE>
<H2><A NAME="bibopalica_tp_103" HREF="#bibopalica_tp">g</A></H2>
<TABLE cellspacing=0 cellpadding=1>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX54" TARGET="bibopalica__body">group'UserAndGroup</A></TD></TR>
<TR><TD bgcolor=#ddeeff valign=top><A HREF="bibopalica_body.html#IDX53" TARGET="bibopalica__body">groupid'UserAndGroup</A></TD></TR>
</TABLE>
<H2><A NAME="bibopalica_tp_104" HREF="#bibopalica_tp">h</A></H2>
<TABLE cellspacing=0 cellpadding=1>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX22" TARGET="bibopalica__body">heap[data, &#60;]</A></TD></TR>
</TABLE>
<H2><A NAME="bibopalica_tp_105" HREF="#bibopalica_tp">i</A></H2>
<TABLE cellspacing=0 cellpadding=1>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX36" TARGET="bibopalica__body">inode'FileSystem</A></TD></TR>
<TR><TD bgcolor=#ddeeff valign=top><A HREF="bibopalica_body.html#IDX5" TARGET="bibopalica__body">int</A></TD></TR>
</TABLE>
<H2><A NAME="bibopalica_tp_109" HREF="#bibopalica_tp">m</A></H2>
<TABLE cellspacing=0 cellpadding=1>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX30" TARGET="bibopalica__body">map[dom, &#60;, codom]</A></TD></TR>
</TABLE>
<H2><A NAME="bibopalica_tp_110" HREF="#bibopalica_tp">n</A></H2>
<TABLE cellspacing=0 cellpadding=1>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX4" TARGET="bibopalica__body">nat</A></TD></TR>
</TABLE>
<H2><A NAME="bibopalica_tp_111" HREF="#bibopalica_tp">o</A></H2>
<TABLE cellspacing=0 cellpadding=1>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX14" TARGET="bibopalica__body">option[data]</A></TD></TR>
</TABLE>
<H2><A NAME="bibopalica_tp_112" HREF="#bibopalica_tp">p</A></H2>
<TABLE cellspacing=0 cellpadding=1>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX11" TARGET="bibopalica__body">pair[data1, data2]</A></TD></TR>
<TR><TD bgcolor=#ddeeff valign=top><A HREF="bibopalica_body.html#IDX39" TARGET="bibopalica__body">permission'FileSystem</A></TD></TR>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX42" TARGET="bibopalica__body">process'ProcessCtrl</A></TD></TR>
<TR><TD bgcolor=#ddeeff valign=top><A HREF="bibopalica_body.html#IDX43" TARGET="bibopalica__body">procstat'ProcessCtrl</A></TD></TR>
</TABLE>
<H2><A NAME="bibopalica_tp_113" HREF="#bibopalica_tp">q</A></H2>
<TABLE cellspacing=0 cellpadding=1>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX13" TARGET="bibopalica__body">quad'Quadruple[data1, data2, data3, data4]</A></TD></TR>
</TABLE>
<H2><A NAME="bibopalica_tp_114" HREF="#bibopalica_tp">r</A></H2>
<TABLE cellspacing=0 cellpadding=1>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX6" TARGET="bibopalica__body">real</A></TD></TR>
<TR><TD bgcolor=#ddeeff valign=top><A HREF="bibopalica_body.html#IDX7" TARGET="bibopalica__body">rel</A></TD></TR>
</TABLE>
<H2><A NAME="bibopalica_tp_115" HREF="#bibopalica_tp">s</A></H2>
<TABLE cellspacing=0 cellpadding=1>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX34" TARGET="bibopalica__body">sap'ComService[in, out]</A></TD></TR>
<TR><TD bgcolor=#ddeeff valign=top><A HREF="bibopalica_body.html#IDX18" TARGET="bibopalica__body">seq[data]</A></TD></TR>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX28" TARGET="bibopalica__body">set'Bitset</A></TD></TR>
<TR><TD bgcolor=#ddeeff valign=top><A HREF="bibopalica_body.html#IDX24" TARGET="bibopalica__body">set'Set[data, &#60;]</A></TD></TR>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX27" TARGET="bibopalica__body">set'SetByBST[data, &#60;]</A></TD></TR>
<TR><TD bgcolor=#ddeeff valign=top><A HREF="bibopalica_body.html#IDX25" TARGET="bibopalica__body">set'SetByInj[data, #]</A></TD></TR>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX26" TARGET="bibopalica__body">set'SetByPred[data]</A></TD></TR>
<TR><TD bgcolor=#ddeeff valign=top><A HREF="bibopalica_body.html#IDX48" TARGET="bibopalica__body">sigaction'Signal</A></TD></TR>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX47" TARGET="bibopalica__body">sighandler'Signal</A></TD></TR>
<TR><TD bgcolor=#ddeeff valign=top><A HREF="bibopalica_body.html#IDX46" TARGET="bibopalica__body">sigmask'Signal</A></TD></TR>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX45" TARGET="bibopalica__body">signal</A></TD></TR>
<TR><TD bgcolor=#ddeeff valign=top><A HREF="bibopalica_body.html#IDX19" TARGET="bibopalica__body">string</A></TD></TR>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX8" TARGET="bibopalica__body">subrel</A></TD></TR>
</TABLE>
<H2><A NAME="bibopalica_tp_116" HREF="#bibopalica_tp">t</A></H2>
<TABLE cellspacing=0 cellpadding=1>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX49" TARGET="bibopalica__body">time</A></TD></TR>
<TR><TD bgcolor=#ddeeff valign=top><A HREF="bibopalica_body.html#IDX21" TARGET="bibopalica__body">tree[data]</A></TD></TR>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX12" TARGET="bibopalica__body">triple[data1, data2, data3]</A></TD></TR>
</TABLE>
<H2><A NAME="bibopalica_tp_117" HREF="#bibopalica_tp">u</A></H2>
<TABLE cellspacing=0 cellpadding=1>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX20" TARGET="bibopalica__body">union'BTUnion</A></TD></TR>
<TR><TD bgcolor=#ddeeff valign=top><A HREF="bibopalica_body.html#IDX15" TARGET="bibopalica__body">union'Union2[data1, data2]</A></TD></TR>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX16" TARGET="bibopalica__body">union'Union3[data1, data2, data3]</A></TD></TR>
<TR><TD bgcolor=#ddeeff valign=top><A HREF="bibopalica_body.html#IDX17" TARGET="bibopalica__body">union'Union4[data1, data2, data3, data4]</A></TD></TR>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX52" TARGET="bibopalica__body">user'UserAndGroup</A></TD></TR>
<TR><TD bgcolor=#ddeeff valign=top><A HREF="bibopalica_body.html#IDX51" TARGET="bibopalica__body">userid'UserAndGroup</A></TD></TR>
</TABLE>
<H2><A NAME="bibopalica_tp_118" HREF="#bibopalica_tp">v</A></H2>
<TABLE cellspacing=0 cellpadding=1>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX9" TARGET="bibopalica__body">void</A></TD></TR>
</TABLE>
<H2><A NAME="bibopalica_tp_119" HREF="#bibopalica_tp">w</A></H2>
<TABLE cellspacing=0 cellpadding=1>
<TR><TD valign=top><A HREF="bibopalica_body.html#IDX50" TARGET="bibopalica__body">wday'Time</A></TD></TR>
</TABLE>

</P>
<P><HR><P>
This document was generated 1 October 1998 (19:16:10) using the
<A HREF="http://wwwcn.cern.ch/dci/texi2html/">texi2html</A>
translator version 1.51-kd-pl15.</P>
</BODY>
</HTML>
