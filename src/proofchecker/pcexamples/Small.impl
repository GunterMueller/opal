IMPLEMENTATION Small
/$ PROOFCHECK $/

IMPORT BasicTac COMPLETELY
       Strategies COMPLETELY
       CalcInduct COMPLETELY
       CalcComputational COMPLETELY
       CalcLogical COMPLETELY
       CalcDomain COMPLETELY
       CalcStructural COMPLETELY
       CalcPP COMPLETELY
       REFLEXIONS COMPLETELY
       ProofTactics COMPLETELY
       ProofByTest COMPLETELY

       Nat ONLY nat succ 0 >= < 1 2 3 0?
       Seq ONLY seq <> ::
       Pair COMPLETELY

-- %Dieser Beweis schlägt fehl
PROOF skolem1 : |- Copy[skolem1:LAW]
PROOF skolem1 ==  traceP(ex_r; all_r; equiv_refl_u)

PROOF skolem2 : |- Copy[skolem2:LAW]
PROOF skolem2 == traceP(all_r; ex_r; equiv_refl_u; assume)


LAW lemma2 == EX f: nat ** nat -> nat. ALL a b. f(a, b) === succ(a)
PROOF lemma2 : |- lemma2
PROOF lemma2 == traceP(ex_r; tApartS; lambda_extUN; equiv_refl_u; *(dfd_lambda)
                      )

FUN f: nat ** nat -> nat
SPC f(a, b) == r
PRE true
POST r === succ(succ(a))

PROOF f : dfd_succ |- Spc[f]
PROOF f == traceP(unskolem; opalR; *(bLogic); lambda_extUN; equiv_refl_u;
                   dfd_lambda; lambda_reduce; tApartS)

/$ prettyfix [and'BOOL] 1 $/
LAW dfd_and == ALL a b. DFD a and b
LAW dfd_succ? == ALL a. DFD succ?(a)
LAW dfd_0? == ALL a. DFD 0?(a)
FUN f2: nat ** nat -> nat
SPC f2(a, b) == r
PRE true
POST r === succ(succ(a))
PROOF f2: dfd_and dfd_succ? dfd_0? dfd_succ |- Spc[f2]
PROOF f2 == traceP(unskolem; case_intro; tApartL; opalR; lambda_reduce;
                   opalR; tApartL; *(lambda_extUN); *(equiv_refl_u);
                   lambda_reduce; dfd_lambda; checkSkolem; tApartS)


LAW dfd_succ == ALL a. DFD succ(a)
PROOF dfd_succ : |- dfd_succ
PROOF dfd_succ == test[succ, nat](succ(0) :: succ(succ(0)) :: <>)


FUN abraxas: nat ** nat -> nat
DEF abraxas(a, b) == succ(succ(a))

FUN g: nat -> bool
SPC g(a) == b
PRE true
POST g(a) === true

LAW t == succ(succ(0)) >= 0
LAW u == ALL a:nat b. a < b
LAW tImpl == ALL a b c. a >= b AND b >= c ==> a >=c

PROOF tImpl: t tImpl |- u
PROOF tImpl == traceP(tApartS)


FUN P Q R : nat -> bool
FUN S: nat ** nat ** nat -> bool

LAW JJ == ALL x y z. P(x) AND Q(y) AND R(z) ==> S(x, y, z)
LAW J1 == P(1)
LAW J2 == Q(2)
LAW J3 == ALL x. R(x)
LAW J3a == R(2)

PROOF JJ: J1 J2 J3 JJ |- u
PROOF JJ == traceP(tApartS)

LAW JK == ALL x y z. NOT (P(x) AND Q(y) AND R(z))
PROOF JK: JJ |- JK
PROOF JK == traceP(tApartS)

LAW K == ALL x . NOT (P(x) AND P(x))

PROOF K: |- K
PROOF K == traceP(tApartS)