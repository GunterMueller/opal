IMPLEMENTATION Lists
/$ PROOFCHECK $/

IMPORT Num COMPLETELY
       Abort[list] COMPLETELY
       Abort[data] COMPLETELY
       

DATA list == <>
             ::(ft: data, rt: list)


DEF #(<>) == 0
DEF #(x :: y) == succ(#(y))

DEF l ! 0 == ft(l)
DEF l ! succ(n) == rt(l) ! n

DEF <> ++ l2 == l2
DEF (x :: y) ++ l2 == x :: (y ++ l2)

DEF revert(<>) == <>
DEF revert(x :: y) == revert(y) ++ (x :: <>)


-- %$Proofs$
IMPORT BasicTac COMPLETELY
       Strategies COMPLETELY
       ProofTactics COMPLETELY
       CalcInduct COMPLETELY
       CalcComputational COMPLETELY
       CalcLogical COMPLETELY
       CalcLogicalForward COMPLETELY
       CalcDomain COMPLETELY
       CalcStructural COMPLETELY
       REFLEXIONS COMPLETELY
       Nat ONLY nat 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15


PROOF cons_length: Discr[<>, ::?] Discr[::, ::?]
                   Def[#] 
                   succ_> irreflexive[num, >] |- 
                   Copy[cons_length:LAW]
PROOF cons_length == statP(inductStart;
                            rewriter;
                            (subst_l_deep; cAssume)
                           )

PROOF ++_neutral_r : Def[++'Lists] |- Copy[neutral_r[list, ++, <>]:LAW]
PROOF ++_neutral_r == simpleP

PROOF ++_neutral_l : Def[++'Lists] |- Copy[neutral_l[list, ++, <>]:LAW]
PROOF ++_neutral_l == simpleP 

PROOF ++_assoc : Def[++'Lists] Copy[neutral_r[list, ++, <>]:LAW]
                 |- Copy[assoc[list, ++]:LAW]
PROOF ++_assoc == simpleP

PROOF ++_length: Def[#] Def[++'Lists] neutral_l[num, +, 0] neutral_r[num, +, 0]
                 +_succ |- Copy[++_length:LAW]
PROOF ++_length == simpleP

PROOF reverse_append: Def[revert] Def[++'Lists] 
                      Copy[neutral_r[list, ++, <>]:LAW]
                      Copy[assoc[list, ++]:LAW]
                      |- Copy[reverse_append:LAW]
PROOF reverse_append == simpleP

PROOF reverse_len: Def[revert] Def[#] 
                   Copy[++_length:LAW] +_succ_r neutral_r[num, +, 0]
                   |- Copy[reverse_len:LAW]
PROOF reverse_len == simpleP
