IMPLEMENTATION TypeLaws

IMPORT SortHandling ONLY variants dataVariants
       SeqOfSeq ONLY combinations flat
       Seq ONLY seq % ft rt ++
       Compose ONLY o
       PCEnv ONLY lawName discr sel equiv ddfd sdfd  pBody gen cdfd proofName
       RepoAn ONLY none an
       SeqMap ONLY *
       RepoAbsy ONLY components variant component
       SetConv ONLY asSet
       Set ONLY set + incl
       Nat ONLY nat

DEF getFreetypeLaws(tp)(R) ==
  LET vs == variants(tp, R)
  IN
  commonTypeLaws(tp, vs)(R)

DEF getDatatypeLaws(tp)(R) ==
  LET vs == dataVariants(tp, R)
  IN
  asSet((\\v. cdfd(none, tp, v)) * vs) + commonTypeLaws(tp, vs)(R)


FUN commonTypeLaws: objectName ** seq[variant] -> repo -> set[lawName, <]
DEF commonTypeLaws(tp, vs)(R) ==
  LET vv == combinations(%(vs, vs))
      1st == ft
      2nd == ft o rt
      mdisc == \\s. discr(none, tp, 1st(s), 2nd(s))
      msel == \\s. (\\s1. sel(none, tp, 1st(s), s1)) * components(2nd(s))
      mexcl == \\s. equiv(none, tp, 1st(s), 2nd(s))
      mddfd == \\s. ddfd(none, tp, s)
      msdfd == \\s. (\\ c. sdfd(none, tp, c)) * components(s)
  IN
  incl(gen(none, tp, vs),
       asSet((mdisc * vv) ++ (mexcl * vv) ++ flat(msel * vv) ++
             mddfd * vs ++ flat(msdfd * vs)))
