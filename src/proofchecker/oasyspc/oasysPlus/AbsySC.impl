IMPLEMENTATION AbsySC

IMPORT RepoAbsy COMPLETELY
       Seq ONLY seq <> ::  <>? ft % =
       SeqMap ONLY *
       RepoAn ONLY none
       RepoObjectAccess ONLY fct denotation
       ABORT ONLY ABORT
       Denotation ONLY ++ =
       Fmt ONLY pretty
       SeqOfSeq ONLY flat
       String ONLY string
       Nat ONLY nat
       RepoName ONLY sign = part:SORT pragmaName:SORT unitName:SORT
       Option ONLY =
       PredefEntities ONLY false true


-- %$Expressions$
DEF tuple1(_, e :: <>) == e
DEF tuple1(a, else) == tuple(a, else)

DEF apply1(a, fc, args) ==
  IF args <>? THEN name(a, fc)
  ELSE apply(a, name(none, fc), tuple1(none, name(none, _) * args))
  FI

DEF tuple1(es) == tuple1(none, es)
DEF apply1(f, as) == apply1(none, f, as)
DEF apply1(f, a) == apply1(f, a%)
DEF apply1(f, a) == apply(none, name(none, f), a)
DEF apply1(f, args) ==   
  IF args <>? THEN f
  ELSE apply(none, f, tuple1(none, name(none, _) * args))
  FI


DEF !(n) == name(none, n)

DEF select(b) == IF b THEN true ELSE false FI

-- %$Formulae$


DEF forall1(a, vars, range) == 
  IF vars <>? THEN range
  ELSE
    quant(a, forall, sign(ft(vars)), vars, range)
  FI

DEF exist1(a, vars, range) == 
  IF vars <>? THEN range
  ELSE
    quant(a, exist, sign(ft(vars)), vars, range)
  FI

DEF conj1(_, f :: <>) == f
DEF conj1(a, Fs) == connect(a, conj, Fs)

DEF disj1(_, f :: <>) == f
DEF disj1(a, Fs) == connect(a, disj, Fs)

DEF forall1(vars, range) == forall1(none, vars, range)
DEF forall1(var, range) == forall1(var%, range)
DEF exist1(vars, range) == exist1(none, vars, range)
DEF conj1(Fs) == conj1(none, Fs)
DEF disj1(Fs) == disj1(none, Fs)

DEF cong(n1, n2) == cong(n1!, n2!)
DEF cong(e1, e2) == atomic(none, cong, %(e1, e2))
DEF dfd(n) == dfd(n!)
DEF dfd(e) == atomic(none, dfd, e%)
DEF neg(f) == connect(none, neg, f%)
DEF equiv(f1, f2) == connect(none, equiv, %(f1, f2))
DEF impl(f1, f2) == connect(none, impl, %(f1, f2))

-- %$$Properties$
DEF dfd?(F) == IF atomic?(F) THEN kind(F) dfd? ELSE false FI
DEF approx?(F) == IF atomic?(F) THEN kind(F) approx? ELSE false FI
DEF cong?(F) == IF atomic?(F) THEN kind(F) cong? ELSE false FI
DEF neg?(F) == IF connect?(F) THEN kind(F) neg? ELSE false FI
DEF conj?(F) == IF connect?(F) THEN kind(F) conj? ELSE false FI
DEF disj?(F) == IF connect?(F) THEN kind(F) disj? ELSE false FI
DEF impl?(F) == IF connect?(F) THEN kind(F) impl? ELSE false FI
DEF equiv?(F) == IF connect?(F) THEN kind(F) equiv? ELSE false FI
DEF forall?(F) == IF quant?(F) THEN kind(F) forall? ELSE false FI
DEF exist?(F) == IF quant?(F) THEN kind(F) exist? ELSE false FI

-- %$$Transformations$
DEF flatConj(connect(a, equiv, F1 :: F2 :: R)) == 
  connect(a, equiv, flatConj(F1) :: flatConj(F2) :: R)
DEF flatConj(connect(a, impl, F :: R)) == connect(a, impl, flatConj(F) :: R)
DEF flatConj(connect(a, conj, FS)) == connect(a, conj, flat(flatConj * FS))
DEF flatConj(_else) == _else:formula

FUN flatConj: formula -> seq[formula]
DEF flatConj(connect(a, conj, FS)) == flat(flatConj * FS)
DEF flatConj(_else) == %(_else)


-- %$Functionalities$

FUN cart1: seq[fct] -> fct
DEF cart1(fc :: <>) == fc
DEF cart1(else) == cart(else)

DEF fct(R)(name(_, op)) == fct(op)(R)
DEF fct(R)(apply(_, fu, _)) ==
  IF funct?(fct(R)(fu)) THEN codom(fct(R)(fu))
  ELSE ABORT("fct'FormulaHandling: no codom for applied fct:" ++
             pretty(fmtFct(fct(R)(fu))))
  FI
DEF fct(R)(tuple(_, els)) == 
  LET z1 == fct(R) * els
      z2 == (\\ f. IF f cart? THEN elems(f) ELSE %(f) FI) * z1
  IN
  cart1(flat(z2))
DEF fct(R)(den(_, _)) == name(denotation(R))
DEF fct(R)(cases(_, gs, _)) == 
  IF gs <>? THEN ABORT("fct'FormulaHandling: empty guard ?!")
  ELSE fct(R)(then(ft(gs))) FI
DEF fct(R)(lambda(_,_,vs,bd)) ==
  funct(cart1((\\ v. fct(v)(R)) * vs), fct(R)(bd))
DEF fct(R)(let(_,_,bd)) == fct(R)(bd)
DEF fct(R)(as(_,_,bd)) == fct(R)(bd)
DEF fct(R)(any(_)) == ABORT("fct'FormulaHandling: no functionality for `any'")


-- %$Relations$
/* %
@ignore
*/
-- %annotations are all equal
FUN = : an ** an -> bool
DEF =(_ :an, _) == true
-- %Generated by ordinatrice.

FUN = : atomicKind ** atomicKind -> bool
DEF =(dfd,dfd) == true
DEF =(dfd,approx) == false
DEF =(dfd,cong) == false
DEF =(dfd,other(_,_)) == false
DEF =(dfd,informal(_)) == false
DEF =(approx,dfd) == false
DEF =(approx,approx) == true
DEF =(approx,cong) == false
DEF =(approx,other(_,_)) == false
DEF =(approx,informal(_)) == false
DEF =(cong,dfd) == false
DEF =(cong,approx) == false
DEF =(cong,cong) == true
DEF =(cong,other(_,_)) == false
DEF =(cong,informal(_)) == false
DEF =(other(_,_),dfd) == false
DEF =(other(_,_),approx) == false
DEF =(other(_,_),cong) == false
DEF =(other(a,b),other(A,B)) == IF =(a,A) THEN true
ELSE
  false
FI
DEF =(other(_,_),informal(_)) == false
DEF =(informal(_),dfd) == false
DEF =(informal(_),approx) == false
DEF =(informal(_),cong) == false
DEF =(informal(_),other(_,_)) == false
DEF =(informal(a),informal(A)) == IF =(a,A) THEN true
ELSE
false
FI

FUN = : connectKind ** connectKind -> bool
DEF =(neg,neg) == true
DEF =(neg,conj) == false
DEF =(neg,disj) == false
DEF =(neg,impl) == false
DEF =(neg,equiv) == false
DEF =(neg:connectKind,other(_)) == false
DEF =(conj,neg) == false
DEF =(conj,conj) == true
DEF =(conj,disj) == false
DEF =(conj,impl) == false
DEF =(conj,equiv) == false
DEF =(conj:connectKind,other(_)) == false
DEF =(disj,neg) == false
DEF =(disj,conj) == false
DEF =(disj,disj) == true
DEF =(disj,impl) == false
DEF =(disj,equiv) == false
DEF =(disj:connectKind,other(_)) == false
DEF =(impl,neg) == false
DEF =(impl,conj) == false
DEF =(impl,disj) == false
DEF =(impl,impl) == true
DEF =(impl,equiv) == false
DEF =(impl:connectKind,other(_)) == false
DEF =(equiv,neg) == false
DEF =(equiv,conj) == false
DEF =(equiv,disj) == false
DEF =(equiv,impl) == false
DEF =(equiv,equiv) == true
DEF =(equiv:connectKind,other(_)) == false
DEF =(other(_),neg:connectKind) == false
DEF =(other(_),conj:connectKind) == false
DEF =(other(_),disj:connectKind) == false
DEF =(other(_),impl:connectKind) == false
DEF =(other(_),equiv:connectKind) == false
DEF =(other(a),(other(A)):connectKind) == IF =(a,A) THEN true
ELSE
false
FI

FUN = : quantKind ** quantKind -> bool
DEF =(forall,forall) == true
DEF =(forall,exist) == false
DEF =(forall:quantKind,other(_)) == false
DEF =(exist,forall) == false
DEF =(exist,exist) == true
DEF =(exist:quantKind,other(_)) == false
DEF =(other(_),forall:quantKind) == false
DEF =(other(_),exist:quantKind) == false
DEF =(other(a),(other(A)):quantKind) == IF =(a,A) THEN true
ELSE
false
FI

FUN = : eqn ** eqn -> bool
DEF =(eqn(a,b,c,d,e),eqn(A,B,C,D,E)) == IF =(a,A) THEN IF =(b,B) THEN IF =(c,C) THEN IF =(=)(d,D) THEN IF =(e,E) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI

FUN = : guard ** guard -> bool
DEF =(guard(a,b,c),guard(A,B,C)) == IF =(a,A) THEN IF =(b,B) THEN IF =(c,C) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI

DEF =(name(a,b),name(A,B)) == IF =(a,A) THEN IF =(b,B) THEN true
ELSE
false
FI
ELSE
false
FI
DEF =(name(_,_),apply(_,_,_)) == false
DEF =(name(_,_),tuple(_,_)) == false
DEF =(name(_,_),den(_,_)) == false
DEF =(name(_,_),cases(_,_,_)) == false
DEF =(name(_,_),lambda(_,_,_,_)) == false
DEF =(name(_,_),let(_,_,_)) == false
DEF =(name(_,_),as(_,_,_)) == false
DEF =(name(_,_),any(_)) == false
DEF =(apply(_,_,_),name(_,_)) == false
DEF =(apply(a,b,c),apply(A,B,C)) == IF =(a,A) THEN IF =(b,B) THEN IF =(c,C) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
DEF =(apply(_,_,_),tuple(_,_)) == false
DEF =(apply(_,_,_),den(_,_)) == false
DEF =(apply(_,_,_),cases(_,_,_)) == false
DEF =(apply(_,_,_),lambda(_,_,_,_)) == false
DEF =(apply(_,_,_),let(_,_,_)) == false
DEF =(apply(_,_,_),as(_,_,_)) == false
DEF =(apply(_,_,_),any(_)) == false
DEF =(tuple(_,_),name(_,_)) == false
DEF =(tuple(_,_),apply(_,_,_)) == false
DEF =(tuple(a,b),tuple(A,B)) == IF =(a,A) THEN IF =(=)(b,B) THEN true
ELSE
false
FI
ELSE
false
FI
DEF =(tuple(_,_),den(_,_)) == false
DEF =(tuple(_,_),cases(_,_,_)) == false
DEF =(tuple(_,_),lambda(_,_,_,_)) == false
DEF =(tuple(_,_),let(_,_,_)) == false
DEF =(tuple(_,_),as(_,_,_)) == false
DEF =(tuple(_,_),any(_)) == false
DEF =(den(_,_),name(_,_)) == false
DEF =(den(_,_),apply(_,_,_)) == false
DEF =(den(_,_),tuple(_,_)) == false
DEF =(den(a,b),den(A,B)) == IF =(a,A) THEN IF =(b,B) THEN true
ELSE
false
FI
ELSE
false
FI
DEF =(den(_,_),cases(_,_,_)) == false
DEF =(den(_,_),lambda(_,_,_,_)) == false
DEF =(den(_,_),let(_,_,_)) == false
DEF =(den(_,_),as(_,_,_)) == false
DEF =(den(_,_),any(_)) == false
DEF =(cases(_,_,_),name(_,_)) == false
DEF =(cases(_,_,_),apply(_,_,_)) == false
DEF =(cases(_,_,_),tuple(_,_)) == false
DEF =(cases(_,_,_),den(_,_)) == false


DEF =(cases(a,b,c),cases(A,B,C)) == IF =(a,A) THEN IF =(=)(b,B) THEN IF =(=)(c,C
) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
DEF =(cases(_,_,_),lambda(_,_,_,_)) == false
DEF =(cases(_,_,_),let(_,_,_)) == false
DEF =(cases(_,_,_),as(_,_,_)) == false
DEF =(cases(_,_,_),any(_)) == false
DEF =(lambda(_,_,_,_),name(_,_)) == false
DEF =(lambda(_,_,_,_),apply(_,_,_)) == false
DEF =(lambda(_,_,_,_),tuple(_,_)) == false
DEF =(lambda(_,_,_,_),den(_,_)) == false
DEF =(lambda(_,_,_,_),cases(_,_,_)) == false
DEF =(lambda(a,b,c,d),lambda(A,B,C,D)) == IF =(a,A) THEN IF =(b,B) THEN IF =(=)(
c,C) THEN IF =(d,D) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
DEF =(lambda(_,_,_,_),let(_,_,_)) == false
DEF =(lambda(_,_,_,_),as(_,_,_)) == false
DEF =(lambda(_,_,_,_),any(_)) == false
DEF =(let(_,_,_),name(_,_)) == false
DEF =(let(_,_,_),apply(_,_,_)) == false
DEF =(let(_,_,_),tuple(_,_)) == false
DEF =(let(_,_,_),den(_,_)) == false
DEF =(let(_,_,_),cases(_,_,_)) == false
DEF =(let(_,_,_),lambda(_,_,_,_)) == false

DEF =(let(a,b,c),let(A,B,C)) == IF =(a,A) THEN IF =(=)(b,B) THEN IF =(c,C) THEN 
true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
DEF =(let(_,_,_),as(_,_,_)) == false
DEF =(let(_,_,_),any(_)) == false
DEF =(as(_,_,_),name(_,_)) == false
DEF =(as(_,_,_),apply(_,_,_)) == false
DEF =(as(_,_,_),tuple(_,_)) == false
DEF =(as(_,_,_),den(_,_)) == false
DEF =(as(_,_,_),cases(_,_,_)) == false
DEF =(as(_,_,_),lambda(_,_,_,_)) == false
DEF =(as(_,_,_),let(_,_,_)) == false
DEF =(as(a,b,c),as(A,B,C)) == IF =(a,A) THEN IF =(b,B) THEN IF =(c,C) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
DEF =(as(_,_,_),any(_)) == false
DEF =(any(_),name(_,_)) == false
DEF =(any(_),apply(_,_,_)) == false
DEF =(any(_),tuple(_,_)) == false
DEF =(any(_),den(_,_)) == false
DEF =(any(_),cases(_,_,_)) == false
DEF =(any(_),lambda(_,_,_,_)) == false
DEF =(any(_),let(_,_,_)) == false
DEF =(any(_),as(_,_,_)) == false
DEF =(any(a),any(A)) == IF =(a,A) THEN true
ELSE
false
FI


-- %@end ignore