/* %The basic functions for the abstract data type of sequences. */
SIGNATURE Seq [data]
/* %- Copyright 1989 - 1998 by the Opal Group, TU Berlin. All rights reserved
      See OCSHOME/etc/LICENSE or 
      http://uebb.cs.tu-berlin.de/~opal/LICENSE.html for details
*/
-- % $Date: 1998-06-16 15:59:58 $ ($Revision: 1.1.1.1 $)

IMPORT Nat ONLY nat
       Option[data] ONLY option

-- %$Parameter$
SORT data

-- %$The Type Itself$
TYPE seq == <>				
            ::(ft:data, rt:seq)

/* %Alternate (alphabetic) names for constructors and
discriminators. Note that you can not use them in pattern-based
definitions. */ 
FUN empty: seq
FUN cons:  data ** seq -> seq
FUN empty? 
    cons?   : seq -> bool
 

-- %$Constructing a Seq From Datas$
-- %@code{%(e_0, ..., e_n-1) = <e_0, ..., e_n-1>}
FUN % 	: data ->seq				
    %   : data ** data -> seq			
    %	: data ** data ** data -> seq		
    %   : data ** data ** data ** data -> seq		
    %   : data ** data ** data ** data ** data -> seq
    %   : data ** data ** data ** data ** data ** data -> seq
    %   : data ** data ** data ** data ** data ** data ** data -> seq
    %   : data ** data ** data ** data ** data ** data ** data ** data -> seq

/* %Append an element to the beginning (@code{::}, @code{cons}) or to the end
(@code{+%}) of a sequence. */
FUN ::  : data ** seq -> seq 
FUN cons: data ** seq -> seq
FUN +%  : seq ** data -> seq 

-- %$constructing a Seq From a Function$
/* %@code{(n_1 .. n_2)(f) = <f(n1), f(n1 +1), ..., f(n2)>} */
FUN ..         : nat ** nat -> (nat -> data) -> seq

/* %@code{iter(start, it, P) = <start,  it(start), ... it^n(start)>},
where @i{n+1} is the smallest number such that
@code{~P(it^(n+1)(start))}. */ 
FUN iter : data ** (data -> data) ** (data -> bool) -> seq

-- %$Combining Sequences$
-- %Concatenate sequences.
FUN ++ 	: seq ** seq -> seq

/* %Concatenate: @code{+/+(d)(s1, s2)} concatenate sequences, put
@code{d} inbetween, if both are nonempty. */
FUN +/+ : data -> seq ** seq -> seq 
FUN +/+ : seq -> seq ** seq -> seq 

/* %Concatenate: @code{+%+(d)(s1, s2)} concatenate sequences, put
@code{d} inbetween unconditionally. */
FUN +%+ : data -> seq ** seq -> seq 
FUN +%+ : seq -> seq ** seq -> seq 

-- %$Working on a Sequence$
/* %Take or drop the first @i{k} elements of a sequence. @code{split}
performs both operations simultaneously: @code{split (n, s) = (take
(n,s), drop (n,s))}. These functions adjust the index to the length of
the sequence if it is too great. */
FUN take 	: nat ** seq -> seq			
FUN drop	: nat ** seq -> seq			
FUN split	: nat ** seq -> seq ** seq		

/* %Drop the last element (@code{front}) or the first
(@code{rt}). These functions abort on empty sequences. */
FUN front	: seq -> seq
FUN rt		: seq -> seq

FUN revert	: seq -> seq

-- %$Accessing Datas in a Sequence$
FUN ft last     : seq -> data   
    
-- %$Information About a Sequence$
FUN # 	: seq -> nat				-- length

/* % @code{exist?} and @code{forall?} check, whether any component or
all components fulfill a predicate @i{P}, @code{find?} returns one
element which fulfills @i{P}, if it exists. */
FUN exist?	: (data -> bool) ** seq -> bool	
FUN find?	: (data -> bool) ** seq -> option[data]
FUN forall?	: (data -> bool) ** seq -> bool

-- %$Comparing Sequences$
/* %If called with an total strict order on its elements, @code{<} is
a lexicographic total strict order on sequences. @code{=} is similar
for equality (equivalence) relations. */
FUN < : (data ** data -> bool) -> (seq ** seq -> bool)
FUN = : (data ** data -> bool) -> (seq ** seq -> bool)
