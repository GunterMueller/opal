/* %
   Combinator library to build lexical scanners.
*/
SIGNATURE ScannerCombinator[token,eof,eof?]
/* %- Copyright 1989 - 1998 by the Opal Group, TU Berlin. All rights reserved
      See OCSHOME/doc/LICENSE or
      http://projects.uebb.tu-berlin.de/opal/trac/wiki/License for details
*/
-- % $Date: 2011-01-04T14:44:45.667619Z $ ($Revision: 8623 $)

IMPORT Char       ONLY char
       Nat        ONLY nat
       String     ONLY string
       Seq[token] ONLY seq


/* ****************************************************************** */
/* %$Structure parameter$                                             */
/* ****************************************************************** */

/* % The sort of @code{token}s the scanner produces. The special token
   @code{eof} is emitted when all input has been consumed and
   @code{eof eof?} should be @code{true}. */

SORT token
FUN eof:  token
FUN eof? : token -> bool


/* ****************************************************************** */
/* %$Setting up and running scanners$                                 */
/* ****************************************************************** */

/* % Scanners are of type @code{()->scanner} to avoid non
   termination. This slightly cumbersome type only shows up in the
   @code{FUN} declaration of a scanner and can be ignored in all other
   respects. */
SORT scanner

/* % A scanner requires that its input (a @code{string} or
   @code{denotation}) to be of sort @code{input}. The function
   @code{init} performs the necessary transition. */
SORT input

FUN init: string -> input
FUN init: denotation -> input

/* % Given a scanner @code{s} and some input @code{inp}, we obtain the
   next token by calling @code{next(s)(inp)}. @code{next} also returns
   the remaining input. When all input has been consumed the scanner
   returns the @code{eof} token. If @code{next(s)(inp) = (eof,inp1)}
   then @code{next(s)(inp1)} also yields an @code{eof} token. */
FUN next: (()->scanner) -> input -> token ** input

/* % The functions @code{tokenize} can be used to obtain a sequence of
   tokens for the entire input. The sequence is always terminated by
   one @code{eof} token. */
FUN tokenize: (()->scanner) -> input -> seq[token]
FUN tokenize: (()->scanner) -> string -> seq[token]
FUN tokenize: (()->scanner) -> denotation -> seq[token]


/* ****************************************************************** */
/* %$Input positions and ranges$                                      */
/* ****************************************************************** */

/* % A scanner keeps track of the current position in input. Positions
   and position ranges are represented by values of sorts @code{pos} and
   @code{range}. */
SORT pos range

/* % A position is specified by a line and a column. Both are numbered
   starting with @code{1}. */
FUN line column: pos -> nat

/* % A range consists of two positions and describes the extend of a
   recognized lexeme in the input. Given a range @code{ran}, the
   positions @code{from(ran)} and @code{to(ran)} specify the position
   of the first and last character of a recognized lexeme. */
FUN from to: range -> pos


/* ****************************************************************** */
/* %$Basic scanners$                                                  */
/* ****************************************************************** */

/* % @code{char(c)} recognizes exactly the character @code{c} at the
   beginning of the input and fails otherwise. */
FUN char: char -> (()->scanner)

/* % @code{action(act)} applies @code{act} to the currently recognized
   range and lexeme. @code{act} returns a token that, if no other
   Calls to @code{action} are performed afterwards, is the recognized
   token the scanner returns when passed to @code{next}. */
FUN action: (range ** string -> token) -> (()->scanner)
FUN action: (range ** denotation -> token) -> (()->scanner)

/* % In case the range information is irrelevant there is also the
   following simpler form of @code{action}. */
FUN action: (denotation -> token) -> (()->scanner)
FUN action: (string -> token) -> (()->scanner)

/* % @code{drop} is a special scanner that forgets the currently
recognized lexeme, e. g. useful to ignore whitespace or comments. */
FUN drop: ()->scanner

/* % @code{success} never fails and leaves the input untouched. It is
   sometimes handy to define more complex scanners from basic ones. */
FUN success: (()->scanner)


-- ---------------------------------------------------------------------
-- %$$Combining scanners$
-- ---------------------------------------------------------------------

/* % Sequential composition: the lexeme recognized by @code{s1;s2} is
   the lexeme recognized by @code{s1} followed by the @code{s2}'s. If
   any of the scanner fails, the composition also fails. */
FUN ; : (()->scanner) ** (()->scanner) -> (()->scanner)

/* % Parallel composition: @code{s1|s2} runs both scanners on the
   input. The composition fails if both scanners fail. If exactly one
   scanner is successful and the other one fails the result is
   produced by the successful one. If both scanners are able to
   recognize something, the result is the longer lexeme of the
   two. That is, @code{|} implements the @emph{longest match} rule. If
   both scanners recognize a lexeme of identical length, the left one
   is preferred. */
FUN | : (()->scanner) ** (()->scanner) -> (()->scanner)

/* % Alternative composition: @code{s1<|s2} first runs @code{s1} on
   the input. If @code{s1} is successful, it determines the result,
   otherwise @code{s2} is tried. */
FUN <| : scanner ** scanner -> scanner


/* ****************************************************************** */
/* %$Complex scanners$                                                */
/* ****************************************************************** */

/* % Repetition: @code{s*} greedily applies @code{s} zero or more
   times.

   @code{s+} greedily applies @code{s} one or more times. */
FUN * : (()->scanner) -> (()->scanner)
FUN + : (()->scanner) -> (()->scanner)

/* % Character range: @code{c1-c2} recognizes any character from
   @code{c1} to @code{c2}. The character code of @code{c1} should be
   less or equal to @code{c2}, otherwise, the scanner always fails. */
FUN - : char ** char -> (()->scanner)


-- %@ignore
-- Local variables:
-- coding: latin-1-unix
-- mode: opal
-- End:
-- %@end ignore


-- %@ignore
-- Local variables:
-- coding: latin-1-unix
-- mode: opal
-- End:
-- %@end ignore


-- %@ignore
-- Local variables:
-- coding: latin-1-unix
-- mode: opal
-- End:
-- %@end ignore
