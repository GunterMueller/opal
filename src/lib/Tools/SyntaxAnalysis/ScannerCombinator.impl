/* %
   Combinator library to build lexical scanners.
*/
IMPLEMENTATION ScannerCombinator
/* %- Copyright 1989 - 1998 by the Opal Group, TU Berlin. All rights reserved
      See OCSHOME/doc/LICENSE or
      http://projects.uebb.tu-berlin.de/opal/trac/wiki/License for details
*/
-- % $Date: 2011-01-04T14:44:45.667619Z $ ($Revision: 8623 $)

IMPORT ABORT      COMPLETELY
       Char       COMPLETELY
       Compose    COMPLETELY
       Denotation COMPLETELY
       Dotfix     COMPLETELY
       Fmt        COMPLETELY
       Identity   COMPLETELY
       Nat        COMPLETELY
       NatConv    COMPLETELY
       Predicate  COMPLETELY
       Seq        COMPLETELY
       String     COMPLETELY
       StringConv COMPLETELY


/* ****************************************************************** */
/* %$Variable convention$                                            */
/* ****************************************************************** */

/* % In the following implementation, we use the following variable
   names or decorations thereof:
@code
s:       ()->scanner -- Scanners
st:      input       -- Scanner states
inp:     string      -- Input of a scanner state
lex:     string      -- Currently recognized lexeme
len:     nat         -- Lenght of current lexeme
tok:     token       -- Current token
ran:     range       -- Ranges
pos:     pos         -- Positions
col,lin: nat         -- Columns and lines
c:       char        -- Character
cs:      string      -- String of characters
act: range**string->token,     -- Token building actions
     string->token,
     range**denotation->token,
     denotation -> token
@end code
*/


/* ****************************************************************** */
/* %$Input data type$                                                 */
/* ****************************************************************** */

/* % The data type @code{input} represents the scanner's state. It is
   named @code{input} to give better mnemonics in the interface
   because from outside this is the only relevant issue.

   A scanner can be in state @code{failed}, @code{scanning}, or
   @code{committed}. A failed scanner was not able to recognize any
   prefix of the input and cannot recover from that state. A scanning
   scanner is in the process of accumulating characters of the
   lexeme. A scanner in state committed has just translated the
   current lexeme into a token. We have the following state
   transitions:

@verbatim
scanning ---> failed
  ^ |
  | v
committed
@verbatim code

   When a scanner changes from @code{committed} to @code{scanning},
   the token of the @code{committed} state is forgotten. */
DATA input ==
   scanning(        -- State `scanning'
     input:string,  -- Input to be scanned
     lexeme:string, -- Recognized characters in reverse order
     length:nat,    -- Number of characters recognized
     range:range)   -- Range in the input of currently recognized characters
   committed(       -- State `committed'
     input:string,  -- Input to be scanned
     token:token,   -- Current token
     length:nat,    -- Length of lexeme the token originated from
     range:range)   -- Range in the input the token originated from
   failed           -- State `failed'


-- ---------------------------------------------------------------------
-- %$$Functions on the scanner state$
-- ---------------------------------------------------------------------

/* % The following functions manipulate the scanner state. We usually
   apply them with the @code{.}-operator from @code{Dotfix}. */

/* % Return the first character of the input. Aborts in all states but
   @code{scanning} and if all input has been consumed. */
FUN ft: input -> char
DEF ft(scanning(c::cs,lex,len,ran)) == c
DEF ft(st) == ABORT(internalErrMsg("ft",st))

/* % Check if there is still input. Aborts in all but the
   @code{scanning} state. */
FUN avail?: input -> bool
DEF avail?(scanning(inp,lex,len,ran)) == inp ::?
DEF avail?(st) == ABORT(internalErrMsg("avail?",st))

/* % Add a character to the current lexeme. Aborts in all but the
   @code{scanning} state. */
FUN add: input -> char -> input
DEF add(scanning(inp,lex,len,ran))(c) == scanning(inp,c::lex,len+1,ran)
DEF add(st,c) == ABORT(internalErrMsg("add",st))

/* % Drop the first character of the input. Aborts in all but the
   @code{scanning} state and if all input has been consumed. */
FUN drop: input -> input
DEF drop(scanning(c::cs,lex,len,ran)) == scanning(cs,lex,len,ran)
DEF drop(st) == ABORT(internalErrMsg("drop",st))

/* % Return length of lexeme of state. This function is practically
   identical to selector @code{length} but produces a better error
   message if called on a @code{failed} state. */
FUN len: input -> nat
DEF len(scanning(inp,lex,len,ran)) == len
DEF len(committed(inp,tok,len,ran)) == len
DEF len(st) == ABORT(internalErrMsg("len",st))

/* % Advance the current range by the given character @code{c}. If
   @code{c} is a newline this is respected accordingly. Aborts in all
   but the scanning state. */
FUN advance: input -> char -> input
DEF advance(scanning(inp,lex,len,ran))(c) ==
    LET ran1 ==
      IF c =  newline THEN from(ran)-(to(ran)++_line)
      IF c |= newline THEN from(ran)-(to(ran)++_col)
      FI
    IN scanning(inp,lex,len,ran1)
DEF advance(st)(c) == ABORT(internalErrMsg("advance",st))

/* % Return the state with the longer lexeme, prefers the left
   argument in case of equal length */
FUN longest: input ** input -> input
DEF longest(st1,st2) ==
    IF st1.len <  st2.len THEN st2
    IF st1.len >= st2.len THEN st1
    FI

/* % Format a state. */
FUN fmtInput: input -> denotation
DEF fmtInput(scanning(inp,lex,len,ran)) ==
    !"State: scanning" .. |<<- ..
    (<_> x 2 |.|
      !"Input:  " .. !!(take(50,inp)) .. |<<- ..
      !"Lexeme: " .. !!(lex) .. !"(" ++ `(len) ++ ")" +%+(newline)
    )

    
    "  Range:  " ++ `(ran)
DEF `(committed(inp,tok,len,ran)) == "committed(" ++ `(inp) ++ ",<tok>," ++ `(len) ++ ")"
    "State: scanning" +%+(newline)
    "  Input: " ++ take(50,inp) <_|
    "  Token: <tok> " ++ "(" ++ `(len) ++ ")" <_|
    "  Range: " ++ `(ran)
DEF `(failed) == "State: failed"


/* ****************************************************************** */
/* %$Scanner data type$                                               */
/* ****************************************************************** */

/* % A scanner transforms from input to input, i. e. from scanning
   state to scanning state.*/
DATA scanner == scanner(scanner: input -> input)


/* ****************************************************************** */
/* %$Setting up and running scanners$                                 */
/* ****************************************************************** */

/* % Set up an initial scanner state. */
DEF init(inp:string) == scanning(inp,<>,0,zero)
DEF init(inp:denotation) == init(`(inp))

/* % Drive the scanner into the @code{committed} or @code{failed}
   state as long as input is available. If the input has been consumed
   completely, an @code{eof} token is returned. */
DEF next(s)(st) ==
    IF input(st) <>? THEN (eof,st)
    IF input(st) ::? THEN
      LET st1 == scanner(s())(st)
      IN IF st1 committed? THEN (st1.token,scanning(st1.input,<>,0,reset(st1.range)))
         IF st1 scanning?  THEN next(s)(st1)
         IF st1 failed?    THEN
           LET msg == "The scanner failed. This is most likely to invalid" <_|
                      "input. You should include a `catch-all' scanner" <_|
                      "that produces an `invalid' token or similar."
           IN (ABORT(userErrMsg("next",msg)),st1)
         FI
    FI

/* % Scan the entire input and return a sequence of tokens terminated
   by @code{eof}. */
DEF tokenize(s)(st:input) ==
    tokenize(next(s),st)
DEF tokenize(s)(inp:string) ==
    LET st == init(inp)
    IN tokenize(next(s),st)
DEF tokenize(s)(inp:denotation) ==
    LET st == init(inp)
    IN tokenize(next(s),st)

/* % This function drives the scanner until it return @code{eof}. */
FUN tokenize: (input -> token ** input) ** input -> seq[token]
DEF tokenize(next,st) ==
    LET (tok,st1) == next(st)
    IN IF tok eof?    THEN %(tok)
       IF ~(tok eof?) THEN tok::tokenize(next,st1)
       FI


/* ****************************************************************** */
/* %$Positions and ranges$                                            */
/* ****************************************************************** */

/* % A position contains of a line and column number starting at
   @code{1}. A range consists of the positions of the first and last
   character of the input region. */
DATA pos == ;(line:nat,column:nat)
DATA range == -(from:pos,to:pos)

/* % The position of the first character in the input. */
FUN origin: pos
DEF origin == (1;1)

/* % The range containing no characters at the beginning of the
   input. */
FUN zero: range
DEF zero == origin-(1;0)

/* % Advance column or line of a position. When advancing a line,
   column is reset to zero. */
FUN ++_col ++_line: pos -> pos
DEF (lin;col)++_col == (lin; col+1)
DEF (lin;col)++_line == (lin+1; 0)

/* % Reset a range @code{ran} to the empty range starting directly
   after @code{to(ran)}. For example: @code{reset((3;5)-(4;10))}
   yields @code{(4;11)-(4;10)}. */
FUN reset: range -> range
DEF reset(from-to) == (to++_col)-to


/* ****************************************************************** */
/* %$Basic scanners$                                                  */
/* ****************************************************************** */

/* % The most basic scanner that recognizes the given character
   @code{c}. It fails if the first character of the input is not
   @code{c}, or if the input is empty. If in state @code{committed},
   the token is dropped and scanning restarts.

   If the first character is @code{c} then @code{c} is added to the
   lexeme, removed from the input and the current recognized range is
   advanced. */
DEF char(c) == \\ .
    scanner(\\st.
      IF st scanning? THEN
        IF st avail? THEN
          IF st.ft = c THEN
            LET st1 == st.add(c)
                st2 == st1.drop
                st3 == st2.advance(c)
            IN st3
          IF st.ft |= c THEN failed
          FI
        IF ~(st avail?) THEN failed
        FI
      IF st committed? THEN
        LET ran1 == reset(st.range)
            st1  == scanning(st.input,<>,0,ran1)
        IN scanner(char(c)())(st1)
      IF st failed? THEN st
      FI
    )

/* % Perform the given token building action and go to state
   @code{committed}. The function aborts if the current state is
   @code{commited}, this is a user error. If teh current state is
   @code{failed}, it aborts with an internal error because this should
   not be possible. */
DEF action(act:string**range->token) == \\ .
    scanner(\\st.
      IF st scanning? THEN
        committed(st.input,act(st.range,revert(st.lexeme)),st.length,st.range)
      IF st committed? THEN
        LET msg == "You probably called `action' twice without any " ++
                   "intervening scanning," <_|
                   "like in `action(act1);action(act2)'."
        IN ABORT(userErrMsg("action",msg))
      IF st failed? THEN
        ABORT(internalErrMsg("action",st))
      FI
    )

/* % The other versions of @code{action}. */
DEF action(act:string->token) == action(\\ran,lex. act(lex))
DEF action(act:range**denotation->token) == action(\\ran,lex. act(ran,lex!))
DEF action(act:denotation->token) == action(\\ran,lex. act(lex))

/* % Drop the current lexeme or token and go to state @code{scanning}
   with an empty lexeme. */
DEF drop == \\ .
    scanner(\\st.
      IF st.(scanning? or committed?) THEN scanning(st.input,<>,0,reset(st.range))
      IF st failed?                   THEN st
      FI
    )

/* % The identity scanner that does nothing. */
DEF success == \\ . scanner(id)


-- ---------------------------------------------------------------------
-- %$$Combining scanners$
-- ---------------------------------------------------------------------

/* % Sequential composition: only run the second scanner if the first
   did not fail. */
DEF s1 ; s2 == \\ .
    scanner(\\st.
      LET st1 == scanner(s1())(st)
      IN IF st1.(scanning? or committed?) THEN
           scanner(s2())(st1)
         IF st1 failed? THEN st1
         FI
    )

/* % Parallel composition with longest match rule. */
DEF s1 | s2 == \\ .
    scanner(\\st.
      LET st1 == scanner(s1())(st)
      IN IF st1 failed? THEN
           scanner(s2())(st)
         IF st1.(scanning? or committed?) THEN
           LET st2 == scanner(s2())(st)
           IN IF st2 failed? THEN
                st1
              IF st2.(scanning? or committed?) THEN
                longest(st1,st2)
              FI
         FI
    )

/* % Alternative composition with first fit rule from left to
   right. */
DEF s1 <| s2 == \\ .
    scanner(\\st.
      LET st1 == scanner(s1())(s1)
      IN IF st1 failed?                  THEN scanner(s2())(st)
         IF st1.(scanning? or comitted?) THEN st1
         FI
    )


/* ****************************************************************** */
/* %$Complex scanners$                                                */
/* ****************************************************************** */

/* % Zero or more repetitions. */
DEF s* == s; ((s*) | success)

/* % One or more repetitions. */
DEF s+ == s;(s*)


/* ****************************************************************** */
/* %$Error messages$                                                  */
/* ****************************************************************** */

/* % @code{internalErrMsg(fn,st)} produces an error message containg
   function name @code{fn} and a dump of the state @code{st}. It is
   called on internal errors that only appear in case of a bug in the
   library. */
FUN internalErrMsg: denotation ** input -> denotation
DEF internalErrMsg(fn,st) ==
    !"An internal error occured in ScannerCombinator." .. |<<- ..
    !"This is a bug. Please send a bug report to" .. |<<- ..
    !"opal-users@projects.uebb.tu-berlin.de including the" .. |<<- ..
    !"following output." .. |<<- ..
    !(fn) .. !": invalid call in state" .. |<<- ..
    fmtInput(st)

/* % @code{userErrMsg(fn,msg)} produces an error message containing
   the function name @code{fn} and message @code{msg}. It is called if
   the client code performs something invalid. */
FUN userErrMsg: denotation ** denotation -> denotation
DEF userErrMsg(fn,msg) ==
    "An error occured in " ++ fn ++ " of ScannerCombinator." ++
    "The reason might be the following:" <_|
    msg

FUN <_| : denotation ** denotation -> denotation
DEF <_| == +%+(newline)


-- %@ignore
-- Local variables:
-- coding: latin-1-unix
-- mode: opal
-- End:
-- %@end ignore
