/** Class representing generators for OPAL structures.
  *
  * @author Wolfgang Grieskamp
  * @version $Id: StructureGenerator.pizza,v 1.1 1999-10-16 17:32:05 wg Exp $
  */

package opal.javabind;

import java.lang.*;
import java.lang.reflect.*;
import java.io.*;
import pizza.lang.*;
import pizza.newutil.*;
import java.util.Date;
import java.text.DateFormat;

import opal.javabind.Kind.*;
import opal.javabind.Config.*;

public class StructureGenerator {

  /** The origin of the structure. */
  private Origin structOrigin;

  /** The path to the subsystem. */
  private String path;

  /** The name of a formal parameter (if any). */
  private Name formal;

  /** Whether this structure should be really outputed. */
  private boolean doOutput;
      

  /** Aggregated code writers. */
  private CodeWriter signHeader, signType, signFun;
  private CodeWriter implHeader, implFun, implDef;
  private JniCodeWriter hcHeader, hcDef, hcInit;

  private StringWriter signHeaderBuf, signTypeBuf, signFunBuf,
                       implHeaderBuf, implFunBuf, implDefBuf,
		       hcHeaderBuf, hcDefBuf, hcInitBuf;

  /** Cache of names already declared. */
  private Set<Name> signKnown = new Set();
  private Set<Name> implKnown = new Set();

  /** Counting version numbers for base names. */
  private Hashtable<String, Integer> countBaseNames = new Hashtable();

  /** Set of fields which need an update function because of free type. */
  private Set<Field> needFieldUpdate = new Set();


  /** Construct a structure generator. */
  public StructureGenerator(String path, String struct,
			    boolean doOutput) throws IOException {
    this(path, struct, 0, doOutput);
  }

  public StructureGenerator(String path, String struct, int noFormals,
			    boolean doOutput) 
  throws IOException {
    this.doOutput = doOutput;

    signKnown.put(Name.bool);
    signKnown.put(Name.denotation);
    implKnown.put(Name.bool);
    implKnown.put(Name.denotation);
    
    signHeaderBuf = new StringWriter();
    signHeader = new CodeWriter(signHeaderBuf);
    signTypeBuf = new StringWriter();
    signType = new CodeWriter(signTypeBuf);
    signFunBuf = new StringWriter();
    signFun = new CodeWriter(signFunBuf);

    implHeaderBuf = new StringWriter();
    implHeader = new CodeWriter(implHeaderBuf);
    implFunBuf = new StringWriter();
    implFun = new CodeWriter(implFunBuf);
    implDefBuf = new StringWriter();
    implDef = new CodeWriter(implDefBuf);

    hcHeaderBuf = new StringWriter();
    hcHeader = new OcsJniCodeWriter(hcHeaderBuf);
    hcDefBuf = new StringWriter();
    hcDef = new OcsJniCodeWriter(hcDefBuf);
    hcInitBuf = new StringWriter();
    hcInit = new OcsJniCodeWriter(hcInitBuf);


    this.path = path;
    if (noFormals > 0){
      if (noFormals > 1)
	throw new
	  IllegalArgumentException("can only handle 0 or 1 formals");
      formal = new Name("data", Kind.Sort, Origin.FORMAL);
      signKnown.put(formal);
      implKnown.put(formal);
      structOrigin = new Origin(struct, List.cons(formal));
    } else {
      formal = null;
      structOrigin = new Origin(struct, List.Nil);
    } 

    String stamp = "generated by javabind version " + Config.version;
    signHeader.comment(stamp);
    implHeader.comment(stamp);
    hcHeader.comment(stamp);

    signHeader.word("SIGNATURE "); signHeader.line(structOrigin.toString());
    if (noFormals > 0){
      signHeader.line("SORT data");
    }
    signHeader.line("IMPORT Void ONLY void:SORT");
    implHeader.word("IMPLEMENTATION "); implHeader.line(structOrigin.base);
    implHeader.line("IMPORT Com COMPLETELY");
    implHeader.line("IMPORT ComCompose COMPLETELY");
    implHeader.line("IMPORT JavaVM COMPLETELY");
    implHeader.line("IMPORT CAST COMPLETELY");
    implHeader.line("IMPORT Void COMPLETELY");
    hcHeader.line("#include \"JavaVM.h\"");

    hcInit.begBlock("static void init_const_" + 
		    OcsJniCodeWriter.convert(structOrigin.base) + 
		    "(){");
  }

  /** Close a structure generator, making all data permanent. */
  public void close() throws IOException {
    hcInit.endBlock("}");

    signHeader.close(); signType.close(); signFun.close();
    implHeader.close(); implFun.close(); implDef.close();
    hcHeader.close(); hcDef.close(); hcInit.close();

    StringWriter out;

    out = new StringWriter();
    out.write(signHeaderBuf.toString());
    out.write("\n");
    out.write(signTypeBuf.toString());
    out.write("\n");
    out.write(signFunBuf.toString());
    out.close();
    if (doOutput)
      Aux.writeOnDiff(out.toString(),
		      new File(path, structOrigin.base + ".sign"));

    
    out = new StringWriter();
    out.write(implHeaderBuf.toString());
    out.write("\n");
    out.write(implFunBuf.toString());
    out.write("\n");
    out.write(implDefBuf.toString());
    out.close();
    if (doOutput)
      Aux.writeOnDiff(out.toString(),
		      new File(path, structOrigin.base + ".impl"));

    if (doOutput)
      Aux.writeOnDiff("",
		      new File(path, structOrigin.base + ".hc.h"));

    out = new StringWriter();
    out.write(hcHeaderBuf.toString());
    out.write("\n");
    out.write(hcDefBuf.toString());
    out.write("\n");
    out.write(hcInitBuf.toString());
    out.close();

    if (doOutput)
      Aux.writeOnDiff(out.toString(),
		      new File(path, structOrigin.base + ".hc.c"));

  }

  /** Return the origin of this structure. */
  public Origin getOrigin(){
    return structOrigin;
  }

  /** Reexport the given name from this structure. */
  public void genReexport(Name name){
    importName(signHeader, signKnown, implKnown, name);
  }

  /** Reexport the given structure from this structure. */
  public void genStructReexport(String struct){
    signHeader.line("IMPORT " + struct + " COMPLETELY");
  }



  /** Generate the type representing a class. */
  public Name genClassType(Class clazz){
    Type type = Type.fromClass(clazz);
    signKnown.put(type.name);
    signType.nextline("SORT ");
    signType.word(type.name.base);
    implDef.nextline("DATA ");
    implDef.word(type.name.base);
    implDef.words(" == make_" + type.name.base);
    implDef.words("(OBJECT: OBJECT)");
    hcHeader.declareClassVar(type);
    hcInit.initClassVar(type);
    return type.name;
  }

  /** Import the class representation. */
  public void importClassType(Class clazz){
    Type type = Type.fromClass(clazz);
    hcHeader.importClassVar(type);
  }

  /** Generate an upwards cast. */
  public Name genUpCast(Class from, Class to){
    Type fromType = Type.fromClass(from);
    Type toType = Type.fromClass(to);
    Name name = funName(toType.name.base,
			List.cons(fromType), toType,
			structOrigin);
    declareExportedFun(name);
    defineFunAs(name, simpleCall("cast"), passThrough);
    return name;
  }

  /** Generate a downwards cast. */
  public Name genDownCast(Class from, Class to){
    Type fromType = Type.fromClass(from);
    Type toType = Type.fromClass(to);
    Name name = funName(toType.name.base,
			List.cons(fromType), toType,
			structOrigin);
    declareExportedFun(name);
    Name hcName = declareHcFun(name);
    hcDef.defineDownCast(toType, hcName, 0, fromType);
    return name;
  }

  /** Generate a downwards test. */
  public Name genDownTest(Class from, Class to){
    Type fromType = Type.fromClass(from);
    Type toType = Type.fromClass(to);
    Type boolType = Type.fromClass(Boolean.TYPE);
    Name name = funName(toType.name.base + "?",
			List.cons(fromType), boolType,
			structOrigin);
    declareExportedFun(name);
    Name hcName = declareHcFun(name);
    hcDef.defineDownTest(toType, hcName, 0, fromType);
    return name;
  }


  /** Generate free type. */
  public Set<Name> genFreeType(Class clazz,
			       List<Config.Variant> variants){

    Type classType = Type.fromClass(clazz);
    Hashtable<Name,Set<Field>> selectors = new Hashtable();
    Set<Name> newNames = new Set();
    List<Field> commonFields = 
      List.fromArray(clazz.getFields())
          .filter(fun (Field f)->boolean
		  { return !Modifier.isStatic(f.getModifiers()) &&
                           f.getName().indexOf("$") == -1; });

    if (variants == List.Nil && commonFields == List.Nil){
      // do nothing
      return new Set();
    }

    signType.line();
    signType.word("TYPE ");
    signType.words(classType.name.base);
    signType.word(" == ");

    

    for (List<Variant> vs = variants; vs != List.Nil; vs = vs.tail()){
      switch (vs.head()){
      case Subclass(Class subclass, Constructor cons, List<Field> fields):
	genSubclassVariant(classType,selectors,newNames,commonFields,
			   subclass, cons, fields);
	break;

      case Constant(Field field):
	genConstantVariant(classType,selectors,newNames,commonFields,
			   field);
	break;
      }
    }

    Enumerator<Name> selNames = selectors.keys();
    while (selNames.hasMoreElements()){
      Name selName = selNames.nextElement();
      Set<Field> fields = selectors.get(selName);
      if (fields.size() == 1){
	Type fieldType = Type.fromClass(fields.elements()
	                               .nextElement().getDeclaringClass());
	if (fieldType.clazz.equals(classType.clazz)){
	  // selector on the same class level is already implemented
	} else {
	  defineFunAs(selName,
		fun (List<String> args)->String {
	             return selName.base + "(" + fieldType.name.base 
	                       + "(" + args.head() + "))";
	        },
		passThrough
	  );
	}
      } else {
	defineFunAs(selName,
         fun (List<String> args)->String {
	   Enumerator<Field> enum = fields.elements();
	   StringBuffer res = new StringBuffer();
	   while (enum.hasMoreElements()){
	     Field field = enum.nextElement();
	     Type subType = Type.fromClass(field.getDeclaringClass());
	     res.append(" IF ");
	     res.append(subType.name.base + "?(" + args.head() + ")");
	     res.append(" THEN ");
	     res.append(selName.base + "(" + subType.name.base + 
			"(" + args.head() + "))");
	   }
	   res.append(" FI");
	   return res.toString();
         },
	 passThrough
       );
      }

    }

    return newNames;
  }
		      

  private void genConstantVariant(Type classType,
			     Hashtable<Name,Set<Field>> selectors,
			     Set<Name> newNames,
			     List<Field> commonFields,
			     Field field){
    // generate free type branch
    signType.line();
    signType.word("  ");
    signType.word(field.getName());
    // generator test
    Type booleanType = Type.fromClass(Boolean.TYPE);
    Type objectType = Type.fromClass(Object.class);
    Origin equalsOrig = objectType.name.origin;
    if (equalsOrig.base.endsWith(Config.sortStructSuffix)){
      equalsOrig = new Origin(
		       equalsOrig.base.substring(0,equalsOrig.base.length()-
					  Config.sortStructSuffix.length()),
                       List.Nil);
    }
    Name testFun = funName(field.getName() + "?",
			    List.cons(classType), booleanType,
			    structOrigin);
    // FIXME: perhaps EQUALS shouldn't be used here
    defineFunAs(testFun,
		fun (List<String> args)->String {
		   return "EQUALS(" + 
		     "OBJECT(" + field.getName() + " : " + 
		                      classType.name.toSortString() + ")," +
		     "OBJECT(" + args.head() + ")" +
		     ")";
                },
		passThrough);
  }

    
  private void genSubclassVariant(Type classType,
			     Hashtable<Name,Set<Field>> selectors,
			     Set<Name> newNames,
			     List<Field> commonFields,
			     Class subclass, Constructor cons,
			     List<Field> fields){
    Type subType = Type.fromClass(subclass);
    List<Field> allFields;
    if (subclass.equals(classType.clazz)){
      commonFields = commonFields.filter(fun (Field f)->boolean
					 { return !fields.contains(f); });
    }
    allFields = commonFields.concat(fields);

    String consName = subType.clazz.getName();
    int dollar = consName.lastIndexOf("$");
    if (dollar >= 0) consName = consName.substring(dollar+1);
    consName = Aux.baseName(consName);

    // generate free type branch
    signType.line();
    signType.word("  ");
    signType.word(consName);
    signType.word("(");
    int ind = 2 + consName.length() + 1;
    int i = 0; List<Field> l = allFields;
    while (l != List.Nil){
      if (i > 0) {
      	signType.word(","); 
	signType.line();
	for (int j = 0; j < ind; j++) { signType.word(" "); }
      }	
      i++;
      Field f = l.head();
      signType.word(f.getName());
      signType.word(" : ");
      signType.words(Type.fromClass(f.getType()).name.toSortString()); 
      l = l.tail();
    }
    signType.word(")");

    // define constructor function
    List<Type> fieldTypes = allFields.map(fun (Field f)->Type
	                                   { return Type.fromClass(f.getType()); });
    Class[] fieldClassArr = new Class[fieldTypes.length()];
    fieldTypes.map(fun (Type t)->Class { return t.clazz; })
	          .copy(fieldClassArr);
    Name name = funName(consName,
			fieldTypes, classType, structOrigin);
    try {
      // check if similar method is already declared 
      Method m = classType.clazz.getMethod(name.base,fieldClassArr);
      if (!Modifier.isStatic(m.getModifiers())){
	System.out.println("Warning: `" + name +"' declared nonstatic");
	throw new NoSuchMethodException();
      }
    }
    catch (NoSuchMethodException e){
      newNames.put(name);
      defineFunAs(name, 
		  fun (List<String> args)->String
		  { 
		    List<String> supArgs = args.take(commonFields.length());
		    List<String> subArgs = args.drop(commonFields.length());
		    String consCall;
		    if (true || subArgs != List.Nil){
		      consCall = "new" + Aux.baseName(cons.getName()) +
		                      "(" + subArgs.elementsToString(",") +")";
		    } else {
		      consCall = "new" + Aux.baseName(cons.getName());
		    }
		    Type consType = subType;
		    if (supArgs.length() != 0){
		      // update commonFields with supArgs
		      for (List<Field> fs = commonFields; fs != List.Nil;
			   fs = fs.tail(), supArgs = supArgs.tail()){
			Field f = fs.head();
			needFieldUpdate.put(f);
			Type ownerType = Type.fromClass(f.getDeclaringClass());
			if (!ownerType.clazz.equals(consType.clazz))
			  consCall = cast(consType, ownerType, consCall);
			consCall =
			  "_set_" + f.getName() + "(" + consCall + "," +
			  supArgs.head() + ")";
			consType = ownerType;
		      }
		    }
		    if (!consType.clazz.equals(classType.clazz)){
		      consCall = cast(consType, classType, consCall);
		    }
		    return consCall;
		  },
		  passThrough);
    }

    // define test function
    Name testName = funName(consName + "?",
			    List.cons(classType), Type.fromClass(Boolean.TYPE),
			    structOrigin);
    defineFunAs(testName,
		fun (List<String> args)->String{
                   if (classType.clazz.equals(subType.clazz)){
		     return "true";
		   } else {
		     return subType.name.base + "?(" + args.head() + ")";
		   }
                },
		passThrough);
		     

    // sample selectors
    for (List<Field> fs = allFields; fs != List.Nil; fs = fs.tail()){
      Name selName = funName(fs.head().getName(),
			     List.cons(classType),
			     Type.fromClass(fs.head().getType()),
			     structOrigin);
      Set<Field> sel = selectors.get(selName);
      if (sel == null){
	sel = new Set();
	selectors.put(selName, sel);
      }
      sel.put(fs.head());
    }
  }

  private static String cast(Type fromType, Type toType, String expr){
    return "cast[" + fromType.name.toString() + "," + toType.name.toString() + 
            "](" + expr + ")";
  }
            
  
  /** Generate constructor. */
  public Name genConstructor(Class clazz,
			     Constructor cons, 
			     Set<BindProp> props){
    boolean immutable = props.contains(BindProp.Immutable);
    List<Type> params = List.fromArray(cons.getParameterTypes())
                            .map(fun (Class c)->Type
				 { return Type.fromClass(c); });
    Type result = Type.fromClass(clazz);
    if (immutable){
      Name name = funName("new" + Aux.baseName(cons.getName()), 
			  params, result, structOrigin);
      declareExportedFun(name);
      Name hcName = declareHcFun(name);
      hcHeader.declareConstructorIdVar(result, hcName, 0);
      hcInit.initConstructorIdVar(result, hcName, 0, params);
      hcDef.defineConstructor(result, hcName, 0, immutable,
			      params, result);
      return name;
    } else {
      Name name = comName("new" + Aux.baseName(cons.getName()), 
			  params, result, structOrigin);
      declareExportedFun(name);
      Name internName = defineCom(name);
      hcHeader.declareConstructorIdVar(result, internName, 0);
      hcInit.initConstructorIdVar(result, internName, 0, params);
      hcDef.defineConstructor(result, internName, 0, immutable,
			      params, result);
      return name;
    } 
  }

  /** Generate field access. */
  public Name genGetField(Class clazz, Field field, Set<BindProp> props){
    boolean immutable = props.contains(BindProp.Immutable);
    Type fieldType = Type.fromClass(field.getType());
    Type type = Type.fromClass(clazz);
    List<Type> params;
    if (Modifier.isStatic(field.getModifiers())){
      params = List.Nil;
      if (immutable){
	Name name = funName(field.getName(), params, fieldType, structOrigin);
	declareExportedFun(name);
	Name internName = defineConst(name);
	hcHeader.declareFieldIdVar(type, internName, 0);
	hcInit.initStaticFieldIdVar(type, internName, 0, 
				    field.getName(), fieldType);
	hcDef.defineGetStaticField(type, internName, 0, 
				   immutable, fieldType);
	return name;
      } else {
	Name name = comName(field.getName(), params, fieldType, structOrigin);
	declareExportedFun(name);
	Name internName = defineCom(name);
	hcHeader.declareFieldIdVar(type, internName, 0);
	hcInit.initStaticFieldIdVar(type, internName, 0, 
				    field.getName(), fieldType);
	hcDef.defineGetStaticField(type, internName, 0, 
				immutable, fieldType);
	return name;
      } 
    } else {
      params = List.cons(type);
      if (immutable){
	Name name = funName(field.getName(), params, fieldType, structOrigin);
	declareExportedFun(name);
	Name hcName = declareHcFun(name);
	hcHeader.declareFieldIdVar(type, hcName, 0);
	hcInit.initFieldIdVar(type, hcName, 0, 
			      field.getName(), fieldType);
	hcDef.defineGetField(type, hcName, 0, 
			     immutable, type, fieldType);
	return name;
      } else {
	Name name = comName(field.getName(), params, fieldType, structOrigin);
	declareExportedFun(name);
	Name internName = defineCom(name);
	hcHeader.declareFieldIdVar(type, internName, 0);
	hcInit.initFieldIdVar(type, internName, 0, 
			      field.getName(), fieldType);
	hcDef.defineGetField(type, internName, 0, 
			     immutable, type, fieldType);
	return name;
      }
    }
  }
	
	
  /** Generate field update. */
  public Name genSetField(Class clazz, Field field, Set<BindProp> props){
    boolean immutable = props.contains(BindProp.Immutable);
    boolean isStatic =  Modifier.isStatic(field.getModifiers());
    boolean required  = needFieldUpdate.contains(field);

    if (immutable && !required) return null;

    Type fieldType = Type.fromClass(field.getType());
    Type type = Type.fromClass(clazz);
    List<Type> params;
    if (Modifier.isStatic(field.getModifiers())){
      params = List.cons(fieldType);
    } else {
      params = List.cons(type, fieldType);
    }
    if (immutable && !isStatic) {
      // required only internally for free types
      Name name = funName("_set_" + field.getName(), params, type,
			  structOrigin);
      declareInternalFun(name);
      Name hcName = declareHcFun(name);
      hcHeader.declareFieldIdVar(type, hcName, 0);
      hcInit.initFieldIdVar(type, hcName, 0, 
			    field.getName(), fieldType);
      hcDef.defineInternSetField(type, hcName, 0, 
				 type, fieldType);
      return name;
    } else {
      Name name = comName(":=_" + field.getName(), params, 
			  Type.fromClass(Void.TYPE), structOrigin);
      declareExportedFun(name);
      Name internName = defineCom(name);
      hcHeader.declareFieldIdVar(type, internName, 0);
      if (Modifier.isStatic(field.getModifiers())){
	hcInit.initStaticFieldIdVar(type, internName, 0, 
				    field.getName(), fieldType);
	hcDef.defineSetStaticField(type, internName, 0, 
				   false, fieldType);
      } else {
	hcInit.initFieldIdVar(type, internName, 0, 
			      field.getName(), fieldType);
	hcDef.defineSetField(type, internName, 0, 
			     false, type, fieldType);
      }
      return name;
    }
  }

  /** Generate method call. */
  public Name genMethod(Class clazz, Method method, Set<BindProp> props){
    boolean immutable = props.contains(BindProp.Immutable);
    Type type = Type.fromClass(clazz);
    Type result = Type.fromClass(method.getReturnType());
    List<Type> params = List.fromArray(method.getParameterTypes())
                            .map(fun (Class c)->Type
				 { return Type.fromClass(c); });
    
    if (!Modifier.isStatic(method.getModifiers())){
      params = List.Cons(type, params);
    }

    if (immutable){
      Name name = funName(method.getName(), params, result, structOrigin);
      declareExportedFun(name);
      Name hcName = declareHcFun(name);
      hcHeader.declareMethodIdVar(type, hcName, 0);
      if (Modifier.isStatic(method.getModifiers())){
	hcInit.initStaticMethodIdVar(type, hcName, 0, 
				     method.getName(), params, result);
	hcDef.defineStaticMethod(type, hcName, 0, 
			      immutable, params, result);
      } else {
	hcInit.initMethodIdVar(type, hcName, 0, 
			       method.getName(), params, result);
	hcDef.defineMethod(type, hcName, 0, 
			   immutable, params, result);
      }
      return name;
    } else {
      Name name = comName(method.getName(), params, result, structOrigin);
      declareExportedFun(name);
      Name internName = defineCom(name);
      hcHeader.declareMethodIdVar(type, internName, 0);
      if (Modifier.isStatic(method.getModifiers())){
	hcInit.initStaticMethodIdVar(type, internName, 0, 
				     method.getName(), params, result);
	hcDef.defineStaticMethod(type, internName, 0, 
			      immutable, params, result);
      } else {
	hcInit.initMethodIdVar(type, internName, 0, 
			       method.getName(), params, result);
	hcDef.defineMethod(type, internName, 0, 
			immutable, params, result);
      }
      return name;
    }

    /*
    // check if we can inherit the method definition from another class.
    // this must be a class in the same package, in order to avoid
    // cyclic dependencies between OCS subsystems
    Class altClass = method.getDeclaringClass();
    if (clazz.equals(altClass)){
      // first introduced here
      altClass = null;
    } else {
      if (!samePackage(clazz, altClass)){
	// try to find a class between this class and alternate class
	// which is in the the same package
	Class sup = clazz.getSuperclass();
	while (!sup.equals(altClass) && !samePackage(clazz,sup)){
	  sup = sup.getSuperclass();
	}
	if (!sup.equals(altClass)) {
	  altClass = sup;
	} else {
	  altClass = null;
	}
      }
    }
    if (true || altClass == null){
      // define new handcoded version
      Name internName = defineHcFun(name, immutable);
      int version = makeOverloadVersion(internName);
      hcHeader.declareMethodIdVar(type, internName, version);
      if (Modifier.isStatic(method.getModifiers())){
	hcInit.initStaticMethodIdVar(type, internName, version, 
				     method.getName(), params, result);
	hcDef.defineStaticMethod(type, internName, version, 
			      immutable, params, result);
      } else {
	hcInit.initMethodIdVar(type, internName, version, 
			       method.getName(), params, result);
	hcDef.defineMethod(type, internName, version, 
			immutable, params, result);
      }
    } else {
      // inherit binding from superclass
      Type superType = Type.fromClass(altClass);
      Name castName = 
	new Name(superType.name.base,
		 Kind.Fun(List.cons(type.name), superType.name),
		 type.name.origin);
      Origin superOrigin =
	// FIXME: the origin creation should be abstracted!
	new Origin(superType.clazz.getName().replace('.','_'),
		   List.Nil);
      Name superName = 
	funName(immutable, name.base,
		List.cons(superType).concat(params.tail()), 
		result, superOrigin);
      importName(impl, implKnown, null, castName);
      importName(impl, implKnown, null, superName);
      defineFunAs(name, 
		  simpleCall(superName.base),
		  fun (String s, int i)->String 
		  { 
		    if (i == 1){
		      return castName.base + "'" + castName.origin.base 
			       + "(" + s + ")";
		    } else {
		      return s;
		    }
		  });
    }
    return name;
    */
  }

  /** Generate catch command for Throwables. */
  /*
  public Name genCatch(Class clazz){
    Type type = Type.fromClass(clazz);
    Name name = new Name("catch",
			 new Fun(List.cons(makeCom(formal), type.name),
				 makeCom(formal)),
			 structOrigin);
    declareExportedFun(name);
    return name;
  }
  */

  /** Generate throw command for Throwables. */
  /*
  public Name genThrow(Class clazz){
    Type type = Type.fromClass(clazz);
    Name name = new Name("throw",
			 new Fun(List.cons(type.name), makeCom(formal)),
			 structOrigin);
    declareExportedFun(name);
    Name internName = defineHcFun(false, name);
    int version = makeOverloadVersion(internName);
    hcDef.defineThrow(type, internName, version);
    return name;
  }
  */

  // AUXILARIES

  private static boolean samePackage(Class c1, Class c2){
    String p1 = c1.getName();
    String p2 = c2.getName();
    return p1.substring(0, p1.lastIndexOf("."))
             .equals(p2.substring(0, p2.lastIndexOf(".")));
  }



  /** Declare an exported function. */
  private void declareExportedFun(Name name){
    declareFun(signFun, signKnown, implKnown, name);
  }
  /** Declare an internal function. */
  private void declareInternalFun(Name name){
    declareFun(implFun, implKnown, null, name);
  }

  /** Declare a function. */
  private void declareFun(CodeWriter part, Set<Name> known,
			 Set<Name> addAlso, Name name){
    // import dependencies
    known.put(name);
    if (addAlso != null) addAlso.put(name);
    importNameDeps(part == signFun ? signHeader : implHeader, 
		   known, addAlso, name);
    // generate declaration
    part.line();
    part.beg(2);
    part.word("FUN ");
    part.word(name.base);
    part.word(" : ");
    part.words(name.kind.toString());
    part.end();
  }

  /** Define name as command, return name of internal answer function. */
  private Name defineCom(Name name){
    Name internName;
    internName = makeIntern(name.base,
			    new Fun(((Fun)name.kind).params,
				    makeAns(((Fun)name.kind).result
					    .origin.acts.head())));
			  // actually, this is a function
			  // ... -> void -> ans[data]
			  // ans[data] is interpreted implicitely this way
    declareInternalFun(internName);
    defineFunAs(name, 
		fun (List<String> args)->String 
		{ 
		  if (args.length() > 0)
		    return "call(" + internName.base + 
		           "(" + args.elementsToString(",") + "))";
		  else
		    return "call(" + internName.base + ")";
		},
		  passThrough);
    return internName;
  }

  /** Define name as constant, return name of internal 
    * initialization function. */
  private Name defineConst(Name name){
    Name internName;
    internName = makeIntern(name.base,
			    new Fun(List.cons(Type.fromClass(Void.TYPE).name),
				    ((Fun)name.kind).result));
    declareInternalFun(internName);
    defineFunAs(name, 
		fun (List<String> args)->String 
		{ return internName.base + "(nil)"; },
		passThrough);
    return internName;
  }

  /** Declare a function to be handcoded. */
  private Name declareHcFun(Name name){
    List<Name> params = ((Fun)name.kind).params;
    if (params == List.Nil){
      Name internName = makeIntern(name.base,
				new Fun(List.cons(Type.fromClass(Void.TYPE).name),
					((Fun)name.kind).result));
      declareInternalFun(internName);
      defineFunAs(name,
		  fun (List<String> args)->String 
		  { return internName.base + "(nil)"; },
		  passThrough);
      return internName;
    } else {
      Name internName = makeIntern(name.base,name.kind);
      declareInternalFun(internName);
      defineFunAs(name,
		  simpleCall(internName.base),
		  passThrough);
      return internName;
    }
  }

  /** Define a function as calling another function. */
  private void defineFunAs(Name name,
			   (List<String>)->String makeBody,
			   (String,int)->String makeArg){
    StringBuffer formals = new StringBuffer();
    List<String> actuals = List.Nil;
    Enumerator<Name> params = new pizza.newutil.ListEnumerator(((Fun)name.kind).params);
    int i = 1;
    while (params.hasMoreElements()){
      if (i > 1){
	formals.append(",");
      }
      String param = "X" + Integer.toString(i);
      formals.append(param);
      formals.append(":");
      formals.append(params.nextElement().toSortString());
      actuals = actuals.concat(makeArg(param,i));
      i++;
    }
    implDef.nextline("DEF (");
    implDef.word(name.base);
    if (formals.length() > 0){
      implDef.word("(");
      implDef.words(formals.toString());
      implDef.word(")");
    }
    implDef.word("):");
    implDef.words(((Kind.Fun)name.kind).result.toSortString());
    implDef.line(" == ");
    implDef.word("  ");
    implDef.words(makeBody(actuals));
  }

  /** Make a function describing a simple call for defineFunAs. */
  private (List<String>)->String simpleCall(String funName){
    return fun (List<String> args)-> String {
      return funName + "(" + args.elementsToString(",") + ")";
    };
  }

  /** A function describing a pass-through of an argument for  
    * defineFunAs (it is actually identity on strings). */
  private (String,int)->String passThrough =
        fun (String s, int i)->String { return s; };

      
  /** Import the given name and all the names it depends from. */
  private void importName(CodeWriter part, 
			  Set<Name> known, Set<Name> addAlso,
			  Name name){
    if (!known.contains(name) && !name.origin.equals(structOrigin)){
      known.put(name);
      if (addAlso != null){
	addAlso.put(name);
      }
      importNameDeps(part, known, addAlso, name);
      part.nextline("IMPORT ");
      part.word(name.origin.toString());
      part.word(" ONLY ");
      part.word(name.base);
      part.word(" : ");
      part.words(name.kind.toString());

    }
  }

  /** Import the names given name depends from. */
  private void importNameDeps(CodeWriter part, 
			      Set<Name> known, Set<Name> addAlso,
			      Name name){
    switch (name.kind){
    case Fun(List<Name> params, Name res):
      Enumerator<Name> deps = new pizza.newutil.ListEnumerator(params);
      while (deps.hasMoreElements()){
	importName(part, known, addAlso, deps.nextElement());
      }
      importName(part, known, addAlso, res);
      break;
    case Sort:
      break;
    }
    Enumerator<Name> deps = new pizza.newutil.ListEnumerator(name.origin.acts);
    while (deps.hasMoreElements()){
      importName(part, known, addAlso, deps.nextElement());
    }
  }
  
  /** Make a function name. */
  private static Name funName(String base,
			      List<Type> params, Type result,
			      Origin origin){
    Name nresult = result.name;
    return new Name(base, 
		    new Fun(params.map(fun (Type t)->Name 
				       { return t.name; }),
			    nresult),
		    origin);
  }
		      
  /** Make a command name. */
  private static Name comName(String base,
			      List<Type> params, Type result,
			      Origin origin){
    Name nresult = makeCom(result.name);
    return new Name(base, 
		    new Fun(params.map(fun (Type t)->Name 
				       { return t.name; }),
			    nresult),
		    origin);
  }
		      
  /* Make a command. */
  private static Name makeCom(Name n){
    return new Name("com", Kind.Sort, new Origin("Com", List.cons(n)));
  }

  /* Make an answer. */
  private static Name makeAns(Name n){
    return new Name("ans", Kind.Sort, new Origin("Com", List.cons(n)));
  }

  /* Make a unique internal name. */
  private int nameCounter = 0;
  private Name makeIntern(String base, Kind kind){
    nameCounter++;
    return new Name("I" + nameCounter, kind, structOrigin);
  }

  /* Make an overload version. */
  private int makeOverloadVersion(Name n){
    Integer old = countBaseNames.get(n.base);
    int i;
    if (old != null){
      i = old.intValue() + 1;
    } else {
      i = 1;
    }
    countBaseNames.put(n.base, new Integer(i));
    return i;
  }

}
    
