
IMPLEMENTATION ModMix
/* %- Copyright 1989 - 1998 by the Opal Group, TU Berlin. All rights reserved
      See OCSHOME/etc/LICENSE or 
      http://uebb.cs.tu-berlin.de/~opal/LICENSE.html for details
*/
-- % $Date$ ($Revision$)

-- author: cg
-- purpose: parsing Opal1 and property language

IMPORT -- pars
       Terminal		COMPLETELY
       Token		COMPLETELY
       PTypes		COMPLETELY
       ZOpts		COMPLETELY
       PErr		COMPLETELY
       PCommon		COMPLETELY
       ModBase		COMPLETELY
IMPORT -- reps
       Rep		COMPLETELY
IMPORT -- absy
       Absy		COMPLETELY
       PartName		COMPLETELY
       Impl[partName]	COMPLETELY
IMPORT -- admin
       OcPos		COMPLETELY
IMPORT -- lib
       Nat		COMPLETELY
       NatConv		COMPLETELY
       Denotation	COMPLETELY
       Seq		COMPLETELY
       SeqMap		COMPLETELY
       SeqReduce	COMPLETELY
       SeqFilter	COMPLETELY
       Pair[expr[partName],set'Bitset]	COMPLETELY
       Bitset		COMPLETELY
       DEBUG		COMPLETELY

-- ------------------------------------------------------------------------
-- 
-- ------------------------------------------------------------------------

FUN traceMix? : bool
DEF traceMix? == FIELD?[bool]("-ztraceMix")

DEF mkMix ==
    mkMod(\\PRes. PRes)

-- ---------------------------------------------------------------------------

FUN Rhs Lhs In_Lhs Rhs_Mix: nat
DEF Rhs == 1
DEF Lhs == 2
DEF In_Lhs == 3 
DEF Rhs_Mix == 4

FUN rhs? lhs? in_lhs? rhs_mix?: nat -> bool
DEF rhs?(n) == n = 1  DEF lhs?(n) == n = 2  
DEF in_lhs?(n) == n = 3  DEF rhs_mix? (n) == n = 4

DEF mkLhsNoMix == mkNoMix(Lhs)
DEF mkInnerLhsNoMix == mkNoMix(In_Lhs)
DEF mkRhsNoMix == mkNoMix(Rhs)

-- ---------------------------------------------------------------------------

FUN mkNoMix : nat -> modifier
DEF mkNoMix (Rhs?) ==
    mkMod(\\PResP. 
	LET PRes == PRINT(traceMix?, \\ . "Before " ++ `(absy(PResP)),PResP)
	IN  IF absy(PRes) Expr?
	    THEN PRINT(traceMix?, \\ . "After " ++ `(absy(After)),After)
		 WHERE (NAbsy,Err) == buildAppl(Rhs?)(e(absy(PRes)))
		       After == pRes(err(PRes) + Err,Expr(NAbsy),tokS(PRes))
	    ELSE PRes 
	    FI)
   FUN buildAppl : nat -> expr -> expr ** err
   DEF buildAppl (Rhs?)(E)			        == (E,wildErr(Rhs?)(E))
   DEF buildAppl (Rhs?)(typed(E,F,Pos))	    == 
       (typed(NE,F,Pos),Err) WHERE (NE,Err)	== buildAppl(Rhs?)(E)
   DEF buildAppl (Rhs?)(as(N,E,Pos))	        == 
       (as(N,NE,Pos),Err) WHERE (NE,Err)	== buildAppl(Rhs?)(E)
   DEF buildAppl (Rhs?)(tuple(E :: <>,_))	== buildAppl(Rhs?)(E)
   DEF buildAppl (Rhs?)(E AS tuple(_ :: _,_)) == 
		IF Rhs? rhs? THEN (E,ok) ELSE (E,pErrMiss(missOp,pos(E))) FI
   DEF buildAppl (Rhs?)(mix(S, _ ))	        == 
       LET (S2,E1) == build(Rhs?)(S,ok)
           (S3,E2)  == buildFix(Rhs?)(S2)
       IN (S3,E1+E2)

-- ------------------------------------------------------------------------------

   FUN buildFix : nat -> seq[pair[expr[partName],set'Bitset]] -> expr ** err
   DEF buildFix(Rhs?)
       ((tuple(E1,P1)& B1)::((E2& B2)::((tuple(E3,_)& B3):: <>))) ==
       IF (B1 inOprnd?) and ((B2 op?) and (B3 inOprnd?))
       THEN mkSec(Rhs?)(E2,tuple(E1 ++ E3,P1),pos(E2))
       ELSE (apply(E2,tuple(E1 ++ E3,P1),pos(E2)),infixErr(E2))
       FI
   DEF buildFix(Rhs?)((E1 & B1)::((E2 & B2)::((tuple(E3,_) & B3):: <>))) ==
       IF (B1 inOprnd?) and ((B2 op?) and (B3 inOprnd?))
       THEN IF ~(Rhs? rhs?) ANDIF (E1 ho_apply?) 
	    THEN (apply(E1,tuple(E2::E3,pos(E2)),pos(E1)),
		  pErr(ho_inf_pattern,pos(E1)))
	    ELSE mkSec(Rhs?)(E2,tuple(E1::E3,pos(E1)),pos(E2))
	    FI
       ELSE (apply(E2,tuple(E1 :: E3,pos(E1)),pos(E2)),infixErr(E2))
       FI
   DEF buildFix(Rhs?)((tuple(E1,P1) & B1)::((E2 & B2)::((E3 & B3):: <>))) ==
       IF (B1 inOprnd?) and ((B2 op?) and (B3 inOprnd?))
       THEN IF ~(Rhs? rhs?) ANDIF (E3 ho_apply?) 
	    	THEN (apply(E2,tuple(E1 +% E3,P1),pos(E2)),
		  		  pErr(ho_inf_pattern,pos(E3)))
	    	ELSE mkSec(Rhs?)(E2,tuple(E1 +% E3,P1),pos(E2))
	    	FI
       ELSE (apply(E2,tuple(E1 +% E3,P1),pos(E2)),infixErr(E2))
       FI
   DEF buildFix(Rhs?)((E1 & B1)::((E2 & B2)::((E3 & B3):: <>))) ==
       IF (B1 inOprnd?) and ((B2 op?) and (B3 inOprnd?))
       THEN IF ~(Rhs? rhs?) ANDIF (E1 ho_apply?) and (E3 ho_apply?)
	    THEN (apply(E1,tuple(E2::(E3 %),pos(E2)),pos(E1)),
		  pErr(ho_inf_pattern,pos(E1)) + pErr(ho_inf_pattern,pos(E3)))
            OTHERWISE
	    IF ~(Rhs? rhs?) ANDIF (E1 ho_apply?) 
	    THEN (apply(E1,tuple(E2::(E3 %),pos(E2)),pos(E1)),
		  pErr(ho_inf_pattern,pos(E1)))
	    IF ~(Rhs? rhs?) ANDIF (E3 ho_apply?) 
	    THEN (apply(E1,tuple(E2::(E3 %),pos(E2)),pos(E1)),
		  pErr(ho_inf_pattern,pos(E3)))
	    ELSE mkSec(Rhs?)(E2,tuple(E1 :: (E3 %),pos(E1)),pos(E2))
	    FI
       ELSE (apply(E1,tuple(E2::(E3 %),pos(E2)),pos(E1)),infixErr(E2))
       FI
   DEF buildFix(Rhs?)((E1P & B1) :: ((E2P & B2) :: <>)) ==
	LET E1 == PRINT(traceMix?,\\ . "buildFix 2Arg : E1 " ++ `(Expr(E1P)),E1P)
	    E2 == PRINT(traceMix?,\\ . "buildFix 2Arg : E2 " ++ `(Expr(E2P)),E2P)
    IN
       IF (B1 postOprnd?) and (B2 op?) 
       THEN IF ~(Rhs? rhs?) ANDIF E1 ho_apply? 
	    	THEN (apply(E1,E2,pos(E2)),pErr(ho_inf_pattern,pos(E1)))
	    	ELSE mkSec(Rhs?)(E2,E1,pos(E1))
	    	FI
       ELSE (apply(E1,E2,pos(E2)),pErrMiss(missOp,pos(E1)))
       FI
   DEF buildFix(_)((E & _ ) :: <>)  == (E,ok)
   DEF buildFix(_)((E & _) :: _ )  == (E,pErr(noMix ,pos(E)))

FUN traceHO? : bool
DEF traceHO? == FIELD?[bool]("-ztraceHO")

FUN ho_apply? : expr -> bool
DEF ho_apply?(apply(apply(_,_,_),_,_)) == true
DEF ho_apply?(_)		       == false

-- ---------------------------------------------------------------------------

FUN prBS : set'Bitset -> denotation
DEF prBS(BS) == IF BS {}? THEN empty 
		ELSE LET One == arb(BS) IN `(arb(BS)) ++ prBS(excl(One,BS)) FI

-- ---------------------------------------------------------------------------
FUN sectionCond? : nat -> expr -> bool

DEF sectionCond?(Rhs?)(E) == 
    IF Rhs? rhs? THEN IF section? THEN IF E val? THEN ide(object(E)) generated? 
		                  ELSE false FI
		 ELSE false FI
    ELSE false FI		  

-- ---------------------------------------------------------------------------

DEF mkLhsAssoc == mkAssoc(Lhs)
DEF mkInnerLhsAssoc == mkAssoc(In_Lhs)
DEF mkRhsAssoc == mkAssoc(Rhs)

FUN mkAssoc: nat -> modifier
DEF mkAssoc (Rhs?)==
    mkMod(\\PRes. 
	    IF absy(PRes) Expr?
	    THEN pRes(err(PRes) + Err,Expr(NAbsy),tokS(PRes))
		 WHERE (NAbsy,Err) == buildAssoc(Rhs?)(e(absy(PRes)))
	    ELSE PRes 
	    FI)

   FUN buildAssoc : nat -> expr -> expr ** err
   DEF buildAssoc (Rhs?)(E)     == (E,wildErr(Rhs?)(E))
   DEF buildAssoc (Rhs?)(typed(E,F,Pos)) == 
       (typed(NE,F,Pos),Err) WHERE (NE,Err) == buildAssoc(Rhs?)(E)
   DEF buildAssoc (Rhs?)(as(N,E,Pos)) == 
       (as(N,NE,Pos),Err) WHERE (NE,Err)    == buildAssoc(Rhs?)(E)
   DEF buildAssoc (Rhs?)(tuple(E :: <>,_))  == buildAssoc(Rhs?)(E)
   DEF buildAssoc (Rhs?)(E AS tuple(_ :: _,_))	== 
	   IF Rhs? rhs? THEN (E,ok) ELSE (E,pErrMiss(missOp,pos(E))) FI
   DEF buildAssoc (Rhs?)(mix(S, _ )) ==
       LET (S2,E1) == build(Rhs?)(S,ok)
       IN IF #(S2) <= 3 THEN LET (Res,E2) == buildFix(Rhs?)(S2)
			     IN (Res,E1+E2)
          ELSE (mix(S2,pos(1st(ft(S2)))),E1 + checkAssoc(Act_Rhs?)(S2))
			   WHERE Act_Rhs? == IF Rhs? rhs? THEN Rhs_Mix ELSE Rhs? FI
          FI

   FUN checkAssoc : nat -> seq[pair[expr[partName],set'Bitset]] -> err
   DEF checkAssoc(Rhs?)((E1 & B1) :: ((E2 & B2) :: ((E3 & B3) :: <>))) ==
       IF (B1 inOprnd?) and ((B2 op?) and (B3 inOprnd?)) 
       THEN noWildErr(Rhs?)(E1) + noWildErr(Rhs?)(E3)
       ELSE pErrMiss(missInfOp ,pos(E2)) FI
   DEF checkAssoc(Rhs?)((E1 & B1) :: ((E2 & B2) :: <>)) ==
       IF (B1 op?) and (B2 inOprnd?) 
       THEN pErrMiss(missOprnd ,pos(E2)) + noWildErr(Rhs?)(E2) 
       ELSE infixErr(E1) + pErrMiss(missInfOp ,pos(E1)) FI
   DEF checkAssoc(Rhs?)((E1 & B1) :: ((E2 & B2) :: R)) ==
       IF (B1 inOprnd?) and (B2 op?) 
       THEN noWildErr(Rhs?)(E1) +  checkAssoc(Rhs?)(R)
       ELSE infixErr(E2) + checkAssoc(Rhs?)(R) FI
   DEF checkAssoc(_)(S) == pErrMiss(missOp,pos(1st(ft(S))))

-- ---------------------------------------------------------------------------

FUN build: nat -> seq[pair[expr[partName],set'Bitset]] ** err -> seq[pair[expr[partName],set'Bitset]]**err

DEF build(Rhs?)((E1 & B1) :: ((E2 & B2) :: S),Err) ==
 	IF (Rhs? rhs?) or (Rhs? lhs?) ANDIF (B1 fun?) and (B2 arg?)  
	THEN LET (A,NE) == mkA(Rhs?)(E1,E2)
         IN  build(Rhs?)((A & (fun+(inOprnd+postOprnd))) :: S,Err+NE)
 	IF (Rhs? in_lhs?) ANDIF (B1 op?) and (B2 arg?)  
	THEN LET (A,NE) == mkA(Rhs?)(E1,E2)
         IN  build(Rhs?)((A & (fun+(inOprnd+postOprnd))) :: S,Err+NE)
    ELSE LET (NS,NE) == build(Rhs?)(S,ok)
	     IN ((E1 & B1) :: ((E2 & B2) :: NS),Err+NE)
    FI
DEF build(_)(S,E) == (S,E)

FUN mkA : nat -> expr ** expr -> expr ** err
DEF mkA(Rhs?)(tuple(E1:: <>,_),typed(tuple(E2:: <>,P2),F,P3)) ==
    mkSec(Rhs?)(E1,typed(E2,F,P3),P2)

DEF mkA(Rhs?)(typed(tuple(E1:: <>,_),F,P3),tuple(E2:: <>,P2)) == 
    mkSec(Rhs?)(typed(E1,F,P3),E2,P2)

DEF mkA(Rhs?)(typed(tuple(E1:: <>,_),F1,P2),typed(tuple(E2:: <>,P3),F2,P4)) ==
    mkSec(Rhs?)(typed(E1,F1,P2),typed(E2,F2,P4),P3)

DEF mkA(Rhs?)(E1,typed(tuple(E2:: <>,P2),F,P3)) == 
    mkSec(Rhs?)(E1,typed(E2,F,P3),P2)

DEF mkA(Rhs?)(typed(tuple(E1:: <>,_),F,P2),E2) == 
    mkSec(Rhs?)(typed(E1,F,P2),E2,pos(E2))

DEF mkA(Rhs?)(tuple(E1 :: <>,_),E2)  ==   mkSec(Rhs?)(E1,E2,pos(E2))

DEF mkA(Rhs?)(E1,tuple(E2:: <>,P2))   ==  mkSec(Rhs?)(E1,E2,P2)

DEF mkA(Rhs?)(tuple(E1:: <>,_),tuple(E2:: <>,P2)) == mkSec(Rhs?)(E1,E2,P2)

DEF mkA(Rhs?)(E1,E2) == mkSec(Rhs?)(E1,E2,pos(E1))

-- ----------------------------------------------------------------------------

   FUN mkSec : nat -> expr ** expr ** pos -> expr ** err
   DEF mkSec(Rhs?)(Op,tuple(E :: <>,P),_) == mkSec(Rhs?)(Op,E,P)
   DEF mkSec(Rhs?)(Op,Arg AS tuple(Eles,P),Pos) == 
       LET Gens == (\\E.IF E val? THEN ide(object(E)) generated? ELSE false FI)
		   | Eles
	   OpErr == IF Op val? THEN IF ide(object(Op)) generated? 
				    THEN pErr(noWildAsOp,pos(Op)) ELSE ok FI
                    ELSE ok FI
       IN IF (Rhs? rhs?) and section? 
	  	  THEN IF Gens <>? THEN (apply(Op,Arg,P),OpErr)
	           ELSE (lambda(object * Gens,apply(Op,Arg,P),Pos),OpErr) FI
	      ELSE IF ~(Rhs? rhs?) 
	           THEN LET HoPats == (\\Ele. Ele ho_apply?) | Eles
		                Errs   == (+ \ ok)
			                       ((\\E. pErr(ho_pattern,pos(E))) * HoPats)
	                IN (apply(Op,Arg,P),OpErr + Errs) 
	           ELSE (apply(Op,Arg,P),OpErr + wildErr(Rhs?)(Arg)) 
         FI    FI
   DEF mkSec(Rhs?)(Op,Arg AS val(O,_),Pos) == 
       LET  OpErr == IF Op val? THEN IF ide(object(Op)) generated? 
				     THEN pErr(noWildAsOp,pos(Op)) ELSE ok FI
                     ELSE ok FI
       IN IF Rhs? rhs? ANDIF section? ANDIF ide(O) generated?
	      THEN (lambda(O %, apply(Op,Arg,Pos),Pos),OpErr)
	      ELSE (apply(Op,Arg,Pos),OpErr + wildErr(Rhs?)(Arg))
	      FI
   DEF mkSec(Rhs?)(Op,Arg,P) == 
       LET  OpErr == IF Op val? THEN IF ide(object(Op)) generated? 
				     THEN pErr(noWildAsOp,pos(Op)) ELSE ok FI
                     ELSE ok FI
       IN IF ~(Rhs? rhs?) ANDIF Arg ho_apply? 
          THEN (apply(Op,Arg,P),OpErr + pErr(ho_pattern,pos(Op)))
          ELSE (apply(Op,Arg,P),OpErr)
	  FI
-- ---------------------------------------------------------------------------
   FUN mkTopSec: modifier
   DEF mkTopSec == mkMod(\\PRes.
    	IF absy(PRes) Expr?
	    THEN PRINT(traceMix?, \\ . "After " ++ `(absy(After)),After)
		 WHERE (NAbsy,Err) == mkSec(e(absy(PRes)))
		       After == pRes(err(PRes) + Err,Expr(NAbsy),tokS(PRes))
	    ELSE PRes 
	    FI)

   FUN mkSec : expr -> expr ** err
   DEF mkSec(Arg AS tuple(Eles,P)) == 
       IF section?
       THEN LET Gens == (\\E.IF E val? THEN ide(object(E)) generated? 
	                         ELSE false FI) | Eles
            IN IF Gens <>? THEN (Arg,ok)
	           ELSE (lambda(object * Gens,Arg,P),ok) FI
       IF ~(section?) 
       THEN (Arg,wildErr(Rhs)(Arg))
       FI

   DEF mkSec(Arg AS val(o,P)) == 
       IF section? ANDIF (ide(o) generated?) 
       THEN (lambda(o %, Arg,P),ok)
       ELSE (Arg, noWildErr(Rhs)(Arg))
       FI
   DEF mkSec(A) == (A,ok)

-- ---------------------------------------------------------------------------
-- Errors
-- ---------------------------------------------------------------------------

FUN infixErr : expr -> err
DEF infixErr(val(PN,P)) == 
    IF ide(PN) generated? THEN pErr(noWildAsOp,P)
    ELSE pErrMiss(missInfOp ,P) FI
DEF infixErr(E) == pErrMiss(missInfOp ,pos(E)) 

FUN oprndErr : expr ** expr ** pos -> err
DEF oprndErr(val(PN1,_),val(PN2,_),P3) == 
    IF section? or wildcard? 
    THEN IF (ide(PN1) generated?)and(ide(PN2) generated?) 
	 THEN pErr(noTwoUS,P3) 
	 ELSE ok FI
    ELSE ok FI

DEF oprndErr(_,_,_) == ok

FUN oprndErr : expr ** pos -> err
DEF oprndErr(val(PN1,_),P2) == 
    IF section? or wildcard? THEN ok
    ELSE IF (ide(PN1) generated?) THEN pErr(noWild ,P2) ELSE ok FI
    FI
DEF oprndErr(_,_) == ok

FUN wildErr : nat -> expr -> err
DEF wildErr(Rhs?)(V AS val(_,_))          == noWildErr(Rhs?)(V)
DEF wildErr(Rhs?)(typed(V AS val(_,_),_,_)) == noWildErr(Rhs?)(V)
DEF wildErr(Rhs?)(tuple(A,_))             == (+ / ok)(noWildErr(Rhs?) * A)
DEF wildErr(Rhs?)(typed(tuple(A,_),_,_))    == (+ / ok)(noWildErr(Rhs?) * A)
DEF wildErr(_)(_) == ok
			  
FUN noWildErr : nat -> expr -> err
DEF noWildErr(Rhs?)(val(PN,P)) == 
	IF Rhs? rhs? ANDIF ~(section?) ANDIF ide(PN) generated? THEN pErr(noWild ,P) 
    IF Rhs? rhs_mix? ANDIF ide(PN) generated? THEN pErr(noWild ,P) 
    ELSE ok FI
DEF noWildErr(_)(_) == ok
			  
