IMPLEMENTATION Gen
/* %- Copyright 1989 - 1998 by the Opal Group, TU Berlin. All rights reserved
      See OCSHOME/etc/LICENSE or 
      http://uebb.cs.tu-berlin.de/~opal/LICENSE.html for details
*/
-- % $Date: 1998-06-16 15:59:38 $ ($Revision: 1.1.1.1 $)
-- ============================================================================
-- Autor:	ralfi
-- Projekt:	OPAL1-Compiler
-- Zweck:       Uebersetzung der analysierten Quelle nach InterOpal
-- ============================================================================

IMPORT	AnalyzedGlobSig	ONLY	actStructParams
	DEBUG		ONLY	PRINT
	InterOpalOption	ONLY	printInterOpal?
	NameGeneration	ONLY	instOfAdd?
	BaseGeneration	ONLY	=
	EnvIO		ONLY	io & envIO
	Name		ONLY	name <
	Seq		ONLY	<> seq <>?  ++
	SeqFilter	ONLY 	|
	InterOpal	COMPLETELY
	AnalyzedGlobSig	ONLY	globSig
	DENOTATION	ONLY	denotation
	Option		ONLY	option avail
	String		ONLY	string
	Map		ONLY	undef map def? 
	Pair		ONLY	1st pair 2nd &
	SeqMap		ONLY	 *
	SeqReduce	ONLY	/
	Set             COMPLETELY

DEF formParMain2IO(Sig)(IO) ==
  LET	SeqName		== actStructParams(Sig)
	(_,EnvIO)	== instOfAdd?(Sig,&(IO,{}))
						(SeqName,main,avail(formal))
  IN	PRINT(printInterOpal?,"formParMain2IO",EnvIO io)
/*
FUN repairEmptys : struct -> struct
DEF repairEmptys(struct(P,Orig,Sym,Inst,Onlys,Objs,Props)) ==
  LET	Emptys1	== 1st*((\\Pair.(Pair 2nd)<>?)|asSeq(Onlys))
	Emptys2	== (\\I.(I def? Onlys)~)|(1st*asSeq(Inst))
	EInst	== (\\I.(I formal?)~)|(Emptys1++Emptys2)
	NewInst	== /((\\I,M.IF I def? M THEN I undef M ELSE M FI),Inst)(EInst)
	NewOnly	== /((\\I,M.IF I def? M THEN I undef M ELSE M FI),Onlys)(EInst)
  IN struct(P,Orig,Sym,NewInst,NewOnly,Objs,Props)

FUN testSelf : origin -> seq[name'InterOpal] -> bool
DEF testSelf(Orig)(Seq) ==
	/((\\Name,B.IF (Name origin)=Orig THEN true ELSE B FI),false)(Seq)

FUN repairSelfInst : struct -> struct
DEF repairSelfInst(struct(P,Orig,Sym,Inst,Onlys,Objs,Props)) ==
  LET	Self	== (\\Pair.testSelf(Orig)(Pair 2nd))|(asSeq(Inst))
	EInst	== (\\I.(I formal?)~)|(1st*Self)
	NewInst	== /((\\I,M.IF I def? M THEN I undef M ELSE M FI),Inst)(EInst)
	NewOnly	== /((\\I,M.IF I def? M THEN I undef M ELSE M FI),Onlys)(EInst)
  IN struct(P,Orig,Sym,NewInst,NewOnly,Objs,Props)
*/

FUN repairEmptys : interOpal -> interOpal
DEF repairEmptys(IO AS interOpal(Part,Structs)) == IO
/*	interOpal(Part,
	asMap((\\Pair. &(Pair 1st,repairSelfInst(Pair 2nd)))*asSeq(Structs)))
*/
