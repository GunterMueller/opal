SIGNATURE PragmaAnFun
/* %- Copyright 1989 - 1998 by the Opal Group, TU Berlin. All rights reserved
      See OCSHOME/etc/LICENSE or 
      http://uebb.cs.tu-berlin.de/~opal/LICENSE.html for details
*/
-- % $Date: 1998-06-16 15:59:35 $ ($Revision: 1.1.1.1 $)

-- subject: miscelleanous functions related to pragma annotations
-- author:  wg 

IMPORT	Ide		ONLY ide 
	SourceAn	ONLY pos:SORT
	TypeAn		ONLY type:SORT
	PragmaAn	ONLY pragmaAn pragma pragmaItem pragmaName
	Ac 		ONLY exp:SORT
	Error		ONLY err:SORT
	Format		ONLY format
	Seq[pragmaTerm]	ONLY seq
	Seq[pragmaName]	ONLY seq
	Seq[pragmaItem]	ONLY seq
	Set[denotation,<] ONLY set
	Denotation	ONLY <


FUN format : pragmaAn -> format
FUN format : pragma -> format
FUN format : pragmaItem -> format
FUN format : pragmaName -> format
    /* Format functions.
    */


/* PROPOSED, NYI */


TYPE pragmaTerm ==
    atom	(pos: pos, sym: denotation)
    names	(pos: pos, names: seq[pragmaName])
    predicate	(pos: pos, sym: denotation, args: seq[pragmaTerm])

FUN parse: (denotation -> bool) ** (pragmaTerm -> err) 
		** seq[pragmaItem] -> pragmaTerm ** err
    /* 	parse(Slot?,Check,Items) == (Term,Err)

	parses pragma items according to the following meta-syntax:

	  PRAGMA ::= 
		lexem(Pos,Val)			! atom(Pos,Val)
	    |	names(Pos,Names)		! names(Pos,Names)
	    |   lexem(_,Val) 
		lexem(Pos,"(") PRAGMA||lexem(_,",") lexem(_,")")
						! predicate(Val,Pos,PRAGMAs)
	
	all outest level predicate terms or atoms whose symbol does
	not fulfill Slot? are ignored
	
	to each constructed term the function Check is applied to check for
	further context conditions.

    */
