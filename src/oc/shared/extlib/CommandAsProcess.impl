-- LAST EDIT: Thu Feb 10 20:58:36 1994 by Christian Maeder (troilos!maeder) 
-- LAST EDIT: Tue Feb  1 13:54:23 1994 by Juergen Exner (hektor!jue) 
-- LAST EDIT: Mon Jan 31 20:29:40 1994 by Juergen Exner (hektor!jue) 
-- LAST EDIT: Mon Jan 24 13:04:58 1994 by Juergen Exner (hektor!jue) 
-- LAST EDIT: Mon Jan 17 17:57:36 1994 by Juergen Exner (hektor!jue) 
-- Adapted to new library "Bibliotheca Opalica
-- Version of January, the 17, 1994
--
-- LAST EDIT: Wed Dec  8 15:23:45 1993 by Juergen Exner (hektor!jue) 

IMPLEMENTATION CommandAsProcess[in, out]
/* %- Copyright 1989 - 1998 by the Opal Group, TU Berlin. All rights reserved
      See OCSHOME/etc/LICENSE or 
      http://uebb.cs.tu-berlin.de/~opal/LICENSE.html for details
*/
-- % $Date: 1998-06-16 15:59:34 $ ($Revision: 1.1.1.1 $)

IMPORT  Process      	COMPLETELY
	Env		ONLY env
	Seq		ONLY seq ++

	File		ONLY file open close
				stdIn stdOut write writeLine 
	BinFile		ONLY read write

        BinFile         COMPLETELY
        ComCompose      COMPLETELY
        Com             COMPLETELY
	Option		ONLY option nil

	Char		ONLY char
	String		ONLY string ! ::
        Seq[string]     ONLY seq <> % 
        Denotation      ONLY  ++
        Nat             ONLY nat 1 0
	Void		ONLY nil
	
DATA phase == optim trans gen
DATA direction == toProc fromProc

-- FUN callAsProcess : procKind ** denotation ** in -> com[out]

DEF callAsProcess (ph, mystruct, data) ==
    LET procName == getProcName(ph)
        inFile == getFileName(mystruct, ph, toProc)
        outFile == getFileName(mystruct, ph, fromProc) 
        intag == getTag(ph, toProc)
        outtag == getTag(ph,fromProc)
        IN
        open(inFile,"wb")	 				& (\\ input.
        write(input, intag, data)  				& ( \\ _ .
	close(input)						& ( \\ _ .
	env("OCSSUBPROCS")					& ( \\ path .
        callProcess(path ++ "/" ++ procName,
                    %(mystruct!), nil )		& (\\ _ .
	open (outFile,"rb")					& (\\ output. 
	read(output,outtag)					& (\\ result. 
	close(output)						& (\\ _ .
	yield(okay(result))
        ))))))))


FUN callProcess : denotation ** seq[string] ** option[seq[string]] -> com[void]
DEF callProcess(name, args, env) ==
        fork & 			(\\P. 
	IF P self? 
                THEN -- son process
		  execve(name, args, env) & (\\ _ .
		  yield[void]
			(fail[void]("Can't start subprocess " ++ name)) & (\\ _ .
		  exit(1)))
                  -- "exit" should never be reached
              IF ~ (P self?) 
                THEN -- father process
                  wait & (\\ _ .
		  yield(okay(nil))
	          )
              FI
	)

FUN getProcName : phase -> denotation
DEF getProcName(optim) == "ocOpt"
DEF getProcName(gen) == "ocGen"
DEF getProcName(trans) == "ocTrans"

FUN getFileName : denotation ** phase ** direction -> denotation
DEF getFileName (structname, p, d) ==
    ("OCS/") ++
    structname  ++
    (".") ++
       (IF p optim? THEN "opt"
    IF p trans? THEN "trans"
    IF p gen? THEN "gen" FI) ++ 
    (".") ++ 
       (IF d toProc? THEN "in"
    IF d fromProc? THEN "out" FI)

FUN getTag : phase ** direction -> denotation
DEF getTag (p, d) ==
       (IF p optim? THEN "opt"
        IF p trans? THEN "trans"
        IF p gen? THEN "gen" FI)
    ++ (" TESTVersion ")
    ++ (IF d toProc? THEN "in"
        IF d fromProc? THEN "out" FI)


-- FUN execCommand : denotation ** (in -> com[out]) ** phase -> com[void]
DEF execCommand(structName, Com, ph) == 
    LET intag == getTag(ph, toProc)
        outtag == getTag(ph, fromProc)
        inFileName == getFileName(structName, ph, toProc)
        outFileName == getFileName(structName, ph, fromProc)
    IN
    open(inFileName,"rb")
    & (\\ In . read(In, intag)
    & (\\ InDat . Com(InDat)
    & (\\ Res . open(outFileName,"wb")
    & (\\ Out . write(Out, outtag, Res)
    & (close(In)
    & (close(Out)
    ))))))




