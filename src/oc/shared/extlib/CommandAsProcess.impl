-- Adapted to new library "Bibliotheca Opalica"
-- Version of January, the 17, 1994
--

IMPLEMENTATION CommandAsProcess[in, out]
/* %- Copyright 1989 - 1998 by the Opal Group, TU Berlin. All rights reserved
      See OCSHOME/etc/LICENSE or 
      http://uebb.cs.tu-berlin.de/~opal/LICENSE.html for details
*/
-- % $Date: 1999-03-09 12:04:34 $ ($Revision: 1.2 $)

IMPORT  Process         COMPLETELY
        ProcessArgs     ONLY env
        Seq             ONLY seq ++

        File            ONLY file open close
                                stdIn stdOut write writeLine 
        BinFile         ONLY read write

        BinFile         COMPLETELY
        ComCompose      COMPLETELY
        Com             COMPLETELY
        Option          ONLY option nil

        Char            ONLY char
        String          ONLY string ! ::
        Seq[string]     ONLY seq <> % 
        Denotation      ONLY  ++
        Nat             ONLY nat 1 0
        Void            ONLY nil
        
DATA phase == optim trans gen
DATA direction == toProc fromProc

-- FUN callAsProcess : procKind ** denotation ** in -> com[out]

DEF callAsProcess (ph, mystruct, data) ==
    LET procName == getProcName(ph)
        inFile == getFileName(mystruct, ph, toProc)
        outFile == getFileName(mystruct, ph, fromProc) 
        intag == getTag(ph, toProc)
        outtag == getTag(ph,fromProc)
        IN
        open(inFile,"wb")                                       & (\\ input.
        write(input, intag, data)                               & ( \\ _ .
        close(input)                                            & ( \\ _ .
        env("OCSSUBPROCS")                                      & ( \\ path .
        callProcess(path ++ "/" ++ procName,
                    %(mystruct!), nil )         & (\\ _ .
        open (outFile,"rb")                                     & (\\ output. 
        read(output,outtag)                                     & (\\ result. 
        close(output)                                           & (\\ _ .
        yield(okay(result))
        ))))))))


FUN callProcess : denotation ** seq[string] ** option[seq[string]] -> com[void]
DEF callProcess(name, args, env) ==
        fork &                  (\\P. 
        IF P self? 
                THEN -- son process
                  execve(name, args, env) & (\\ _ .
                  yield[void]
                        (fail[void]("Can't start subprocess " ++ name)) & (\\ _ .
                  exit(1)))
                  -- "exit" should never be reached
              IF ~ (P self?) 
                THEN -- father process
                  wait & (\\ _ .
                  yield(okay(nil))
                  )
              FI
        )

FUN getProcName : phase -> denotation
DEF getProcName(optim) == "ocOpt"
DEF getProcName(gen) == "ocGen"
DEF getProcName(trans) == "ocTrans"

FUN getFileName : denotation ** phase ** direction -> denotation
DEF getFileName (structname, p, d) ==
    ("OCS/") ++
    structname  ++
    (".") ++
       (IF p optim? THEN "opt"
    IF p trans? THEN "trans"
    IF p gen? THEN "gen" FI) ++ 
    (".") ++ 
       (IF d toProc? THEN "in"
    IF d fromProc? THEN "out" FI)

FUN getTag : phase ** direction -> denotation
DEF getTag (p, d) ==
       (IF p optim? THEN "opt"
        IF p trans? THEN "trans"
        IF p gen? THEN "gen" FI)
    ++ (" TESTVersion ")
    ++ (IF d toProc? THEN "in"
        IF d fromProc? THEN "out" FI)


-- FUN execCommand : denotation ** (in -> com[out]) ** phase -> com[void]
DEF execCommand(structName, Com, ph) == 
    LET intag == getTag(ph, toProc)
        outtag == getTag(ph, fromProc)
        inFileName == getFileName(structName, ph, toProc)
        outFileName == getFileName(structName, ph, fromProc)
    IN
    open(inFileName,"rb")
    & (\\ In . read(In, intag)
    & (\\ InDat . Com(InDat)
    & (\\ Res . open(outFileName,"wb")
    & (\\ Out . write(Out, outtag, Res)
    & (close(In)
    & (close(Out)
    ))))))




