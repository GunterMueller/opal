IMPLEMENTATION InterOpalIO
/* %- Copyright 1989 - 1998 by the Opal Group, TU Berlin. All rights reserved
      See OCSHOME/etc/LICENSE or 
      http://uebb.cs.tu-berlin.de/~opal/LICENSE.html for details
*/
-- % $Date: 1998-06-16 15:59:37 $ ($Revision: 1.1.1.1 $)
-- ============================================================================
-- Autor:	ralfi
-- Projekt:	OPAL1-Compiler - Zwischensprache InterOpal
-- Zweck:       Ein/Ausgaberoutinen fuer InterOpal, die unabhaengig vom
--		IO des Compilers sind
-- ============================================================================

IMPORT	
	Com		ONLY	ans com data error fail fail? okay okay? yield
	ComCompose	ONLY	& ;
	BinStream	ONLY	read write
	Stream          ONLY    close create input open output 
				stdErr stdOut write string char
 	InterOpal	ONLY	interOpal:SORT ioTypeKey
	Option		ONLY	avail avail? cont nil nil? option
	Denotation      ONLY    ++ 
	Void		ONLY	nil void

	
-- ---------------------------------------------------------------------------
FUN readInterOpal       : bool ** denotation -> com[option[interOpal]]
DEF readInterOpal(Verbose?,Fn) ==
    optread(Verbose?,Fn,ioTypeKey)

FUN writeInterOpal	: bool ** denotation -> interOpal -> com[void]
DEF writeInterOpal(Verbose?,Fn)(IO) ==
    write(Verbose?,Fn,ioTypeKey,IO)

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
-- Kopiert und leicht abgewandelt von OcComData OcComStream
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

FUN ioError: denotation
DEF ioError == "i/o error" 

FUN write: bool**denotation**denotation**interOpal -> com[void]
DEF write(Verbose?,fn,tag,data) ==
  create(Verbose?,fn) &
  (\\output.write(output,tag,data) ;
            (\\a.IF a okay? THEN close(Verbose?,output)
                 IF a fail? THEN (writeErr(fn,error(a)) ;
                                  close(Verbose?,output)) ;
                                  yield(fail(ioError))
                 FI))

FUN create: bool**denotation -> com[output]
DEF create(Verbose?,fn) ==
  traceWriting(Verbose?,fn) ;
  (\\ _ .create(fn) ;
         (\\a.IF a okay? THEN yield(a)
              IF a fail? THEN writeErr(fn,error(a)) ;
                              yield(fail(ioError))
              FI))


FUN optread: bool**denotation**denotation -> com[option[interOpal]]
DEF optread(Verbose?,fn,tag) ==
  tryOpen(Verbose?,fn) &
  (\\optIn.IF optIn nil? THEN yield(okay(nil))
           IF optIn avail? THEN
             LET input == cont(optIn)
             IN read(input,tag) ;
                (\\a.IF a okay? THEN close(Verbose?,input) ;
                                     yield(okay(avail(data(a))))
                     IF a fail? THEN (writeErr(fn,error(a)) ;
                                      close(Verbose?,input)) ;
                                      yield(fail(ioError))
                     FI)
           FI)

FUN writeErr: denotation**denotation -> com[void]
DEF writeErr(fn,msg) ==
  write(stdErr,fn ++ ((": " ) ++ msg)) &
  write(stdErr,"\n")

FUN tryOpen: bool**denotation -> com[option[input]]
DEF tryOpen(Verbose?,fn) ==
  traceReading(Verbose?,fn) ;
  (\\ _ .open(fn) ;
         (\\a.IF a okay? THEN yield(okay(avail(data(a))))
              IF a fail? THEN yield(okay(nil))
              FI))
  
FUN close: bool ** input -> com[void]
DEF close(_,input:input) ==
  close(input) ;
  (\\a.IF a okay? THEN yield(a)
       IF a fail? THEN writeErr("",error(a)) ;
                       yield(fail(ioError))
       FI)

FUN close:  bool**output -> com[void]
DEF close(Verbose?,output:output) ==
  close(output) ;
  (\\a.IF a okay? THEN yield(a)
       IF a fail? THEN writeErr("",error(a)) ;
                       yield(fail(ioError))
       FI)


FUN traceReading 
    traceWriting: bool**denotation -> com[void]
DEF traceReading(Verbose?,fn) ==
  IF Verbose? THEN (write(stdOut,("reading " )++fn) ;
                                 write(stdOut,"\n")) ;
                                 yield(okay(nil))
  ELSE yield(okay(nil))
  FI

DEF traceWriting(Verbose?,fn) ==
  IF Verbose? THEN (write(stdOut,(" writing " )++fn) ;
                                 write(stdOut,"\n")) ;
                                 yield(okay(nil))
  ELSE yield(okay(nil))
  FI
