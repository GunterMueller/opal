IMPLEMENTATION InterDumpBase
/* %- Copyright 1989 - 1998 by the Opal Group, TU Berlin. All rights reserved
      See OCSHOME/etc/LICENSE or 
      http://uebb.cs.tu-berlin.de/~opal/LICENSE.html for details
*/
-- % $Date: 1998-06-16 15:59:37 $ ($Revision: 1.1.1.1 $)
-- ============================================================================
-- Autor:       ralfi
-- Projekt:     OPAL1-Compiler - Zwischensprache InterOpal
-- Zweck:       Dumproutinen fuer InterOpal, speziell BasisTypen von InterOpal
-- ============================================================================

IMPORT  
        NatConv         ONLY    `
        Format          ONLY    blk format str : denotation -> format
        FormatFun1      ONLY    list
        InterOpal       ONLY    < cart extProperties fct : fct -> kind other region items objects token impl:SORT formula:SORT
                                fct :SORT formal funct : fct ** fct -> fct
                                ident : nat -> ident ident :SORT implementation
                                inst insts intProperties interOpal kind local
                                local? main
                                name : ident ** origin ** inst -> name
                                name :SORT none object:SORT objs origin part
                                pos : part ** nat ** nat -> pos pos :SORT
                                signature sort : kind sort : name -> fct 
                                struct map property
                                symbol : object -> denotation
                                symbol : struct -> denotation unknown
        InterOpalOption ONLY    printNumbers?
        Map             ONLY    ! def? map
        Nat             ONLY    0 nat 1
        Seq             ONLY    % :: <> seq
       Denotation ONLY ++
       Dyn ONLY dyn

FUN dPart : interOpal -> part -> format
DEF dPart(_)(signature) == "SIGNATURE"str
DEF dPart(_)(extProperties) == "EXTERNAL PROPERTIES"str
DEF dPart(_)(implementation) == "IMPLEMENTATION"str
DEF dPart(_)(intProperties) == "INTERNAL PROPERTIES"str

FUN dK : interOpal -> kind -> format
DEF dK (_)(sort) == ":SORT"str
DEF dK (IO)(fct(Fct)) == blk(0,%("("str,dF(IO)(Fct),")"str))
DEF dK(_)(other(id, _)) == str(":" ++ id)

FUN dF : interOpal -> fct -> format
DEF dF (IO)(sort(Name)) == dN(IO)(Name)
DEF dF (IO)(cart(SFct)) == list("("str,"**"str,")"str,IO dF)(SFct)
DEF dF (IO)(funct(AFct,RFct)) ==
        blk(0,%("("str,dF(IO)(AFct),"->"str,dF(IO)(RFct),")"str))

FUN dPos : interOpal -> pos -> format
DEF dPos (_)(unknown) == "<unknown>"str
DEF dPos (IO)(part(Part)) ==
       list("<"str,","str,">"str,\\I.I)(%(dPart(IO)(Part),"unknown"str))
DEF dPos (IO)(pos(Part,Row,Col)) ==
       list("<"str,","str,">"str,\\I.I)(%(dPart(IO)(Part),(Row`)str,(Col`)str))
DEF dPos (IO)(region(Part,Row,Col,eRow, eCol)) ==
  blk(1,%(
      list("<"str,","str,">"str,\\I.I)(%(dPart(IO)(Part),(Row`)str,(Col`)str)),
      str("-"),
      list("<"str,","str,">"str,\\I.I)
          (%(dPart(IO)(Part),(eRow`)str,(eCol`)str))
     ))


FUN dN : interOpal -> name -> format
DEF dN (IO)(name(Ident,Origin,Inst)) ==
  LET   FName   == dId(IO)(Origin)(Ident)
        FOrig   == dO(IO)(Origin)
        FInst   == dI(IO)(Origin)(Inst)
  IN blk(0,%(FName,FOrig,FInst))

FUN dId : interOpal -> origin -> ident -> format
DEF dId (interOpal(_,S))(Origin)(Ident AS ident(No)) ==
IF Origin local? THEN blk(0,%("{local-"str,(No`)str,"}"str))
ELSE
  LET   Struct  == S!Origin
        Objs    == objs(Struct)
        FName   == IF Ident def? Objs THEN symbol(Objs!Ident) str
                   ELSE blk(0,%("unknownID{"str,(No`)str,"}"str)) FI
        FNo     == IF printNumbers? THEN %("{"str,(No`)str,"}"str)
                   ELSE <> FI
  IN blk(0,FName::FNo)
FI

FUN dO : interOpal -> origin -> format
DEF dO (interOpal(_,Structs))(local) ==
  LET   Name    == IF main def? Structs THEN symbol(Structs!main) str
                   ELSE "unknown"str FI
  IN blk(0,%("'"str,Name,"{local}"str))
DEF dO (interOpal(_,Structs))(main) ==
  LET   Name    == IF main def? Structs THEN symbol(Structs!main) str
                   ELSE "unknown"str FI
  IN blk(0,%("'"str,Name,"{main}"str))
DEF dO (interOpal(_,Structs))(Origin AS origin(No)) ==
  LET   FName   == IF Origin def? Structs THEN symbol(Structs!Origin) str
                   ELSE "unknown"str FI
        FNo     == IF printNumbers? THEN %("{"str,(No`)str,"}"str)
                   ELSE <> FI
  IN blk(0,("'"str)::(FName::FNo))

FUN dI : interOpal -> origin -> inst -> format
-- [nat,<,int]{none|formal|n}
DEF dI (IO AS interOpal(_,S))(Orig)(none) == "{none}"str
DEF dI (IO AS interOpal(_,S))(Orig)(formal) ==
  LET   Insts   == insts(S!Orig)
        FNames  == IF formal def? Insts THEN
                        list("["str,","str,"]"str,IO dN)(Insts!formal)
                   ELSE "[undef!!!]"str FI
  IN    IF formal def? Insts THEN blk(0,%(FNames,"{formal}"str))
        ELSE blk(0,%("{formal}"str,"['unknown']"str)) FI
DEF dI (IO AS interOpal(_,S))(Orig)(generic) ==
  LET   Insts   == insts(S!Orig)
        FNames  == IF generic def? Insts THEN
                        list("["str,","str,"]"str,IO dN)(Insts!generic)
                   ELSE "[undef!!!]"str FI
  IN    IF generic def? Insts THEN blk(0,%(FNames,"{generic}"str))
        ELSE blk(0,%("{generic}"str,"['unknown']"str)) FI
DEF dI (IO AS interOpal(_,S))(Orig)(Inst AS inst(No)) ==
  LET   Insts   == insts(S!Orig)
        FNames  == IF Inst def? Insts THEN 
                        list("["str,","str,"]"str,IO dN)(Insts!Inst)
                   ELSE "[undef!!!]"str FI
        FNo     == IF printNumbers? THEN %("{"str,(No`)str,"}"str)
                   ELSE <> FI
  IN    IF Inst def? Insts THEN blk(0,FNames::FNo)
        ELSE blk(0,("['unknown']"str)::FNo) FI


DEF dPragma(IO)(prg) ==
  list(str("Pragma:"), str(" "), str(""), dPragmaItem(IO))(items(prg))

DEF dPragmaItem(IO)(objects(objs)) ==
  list(str("["), str(", "), str("]"), dN(IO))(objs)
DEF dPragmaItem(IO)(token(p,t)) == blk(0, %(dPos(IO)(p), str(t)))
  
