IMPLEMENTATION InterOpalDump
/* %- Copyright 1989 - 1998 by the Opal Group, TU Berlin. All rights reserved
      See OCSHOME/etc/LICENSE or 
      http://uebb.cs.tu-berlin.de/~opal/LICENSE.html for details
*/
-- % $Date: 1998-06-16 15:59:37 $ ($Revision: 1.1.1.1 $)
-- ============================================================================
-- Autor:       ralfi
-- Projekt:     OPAL1-Compiler - Zwischensprache InterOpal
-- Zweck:       Dumproutinen fuer InterOpal
-- ============================================================================

IMPORT  Com             ONLY    ans com okay yield
        ComCompose      ONLY    &
        Stream          ONLY    output stdOut
        NatConv         ONLY    `
        DEBUG           ONLY    PRINT string
        Format          ONLY    blk brk format nl str : denotation -> format write
        FormatFun1      ONLY    list
        /*
        InterOpal       ONLY    < data def eqn:SORT ident :SORT impl:SORT
                                imported induced inst interOpal kind missing
                                name:SORT object origin parameter part pos:SORT
                                property struct variant
        */
        InterOpal       COMPLETELY
        InterDumpBase
                        ONLY    dI dId dK dN dO dPart dPos dPragma dPragmaItem
        InterDumpExpr
                        ONLY    dEq dV
        InterDumpProps
                        ONLY    ident2Prop2Format
        InterOpalOption ONLY    dump? printInterOpal?
        Map             ONLY    ! def? map
        MapConv         ONLY     explode implode
        Nat             ONLY    - 0 100 2 20 4 nat
        Pair            ONLY    & 1st 2nd pair
        Seq             ONLY    % ++ :: seq
        SeqMap          ONLY    *
        Void            ONLY    nil void

-- Hilfsfunktionen
FUN unique: seq[inst] ** seq[inst] -> seq[inst]
DEF unique(S1,S2) == 
        (1st * (explode(implode'MapConv[inst,<,void]((\\I. &(I,nil))*(S1++S2)))))

-- Bug in pretty????? -> write verwendet

FUN dump : interOpal -> format
DEF dump(IO AS interOpal(P,S)) ==
   LET  FPart   == dPart(IO)(P)
        FStructs== (IO dS) * (2nd * explode(
                PRINT(printInterOpal?,"INTEROPALDUMPING",S)))
        All     == blk(0,%(FPart,nl)++FStructs)
   IN   All

FUN dump : interOpal -> com[interOpal]
DEF dump(IO AS interOpal(P,S)) ==
        IF dump? THEN
           LET  FPart   == dPart(IO)(P)
                FStructs== (IO dS) * (2nd * explode(
                        PRINT(printInterOpal?,"INTEROPALDUMPING",S)))
                All     == blk(0,%(FPart,nl)++FStructs)
           IN (write(stdOut,All,100-20)) & (yield(okay(IO)))
        ELSE yield(okay(IO))
        FI

FUN dS : interOpal -> struct -> format
DEF dS (IO)(struct(Pos,Origin,_,Insts,Onlys,Objs,Props,Pragmas)) ==
  LET   FHead   == blk(0,(dO(IO)(Origin))::((IO dPos) * Pos))
        USInst  == unique(1st*(explode(Insts)),1st*(explode(Onlys)))
        FInsts  == list(brk(0),nl,brk(0),In2For)(USInst)
        In2For  == \\I.LET F1   == dI(IO)(Origin)(I)
                           F2   == IF I def? Onlys THEN
                                        list(brk(0),nl,nl,
                                                IO dN)(Onlys!'Map I)
                                   ELSE "'' no entries <bei formal ok>''"str FI
                       IN blk(4,%(F1,nl,F2))
        FObjs   == list(brk(0),nl,brk(0),dOb(IO)(Origin))
                        (2nd * explode(Objs))
        FPragmas == list(str("["), str(", "), str("]"), dPragma(IO))(Pragmas)
        FBody   == blk(2,%("  "str,FInsts,nl,FObjs,nl,FPragmas,nl))
  IN blk(0,%(FHead,nl,FBody,nl))

FUN dOb : interOpal -> origin -> object -> format
DEF dOb (IO)(Origin)(object(Pos,Ident,Symbol,Kind,Def,Props,Pragmas)) ==
  LET   FPos    == list("{"str," "str,"}"str,IO dPos)(Pos)
        FName   == dId(IO)(Origin)(Ident)
        FKind   == dK(IO)(Kind)
        FDef    == dIm(IO)(Def)
        FPragmas == list(str("["), str(", "), str("]"), dPragma(IO))(Pragmas)
        FProps  == list("[%"str,nl,"%]"str,ident2Prop2Format(IO)(Origin))
                                                                        (Props)
  IN blk(0,(%(FName,FPos,nl,FKind,nl))++(%(FDef,nl,FProps,nl)) ++
        %(FPragmas, nl))

FUN dIm : interOpal -> impl -> format
DEF dIm (IO)(missing) == "missing"str
DEF dIm (IO)(imported) == "imported"str
DEF dIm (IO)(parameter(Pos,No)) ==
        blk(2,%("parameter"str,dPos(IO)(Pos),(No`)str))
DEF dIm (IO)(induced(Pos,Sort)) == 
        blk(0,%("induced:"str,dPos(IO)(Pos),dN(IO)(Sort)))
DEF dIm (IO)(data(Vars)) == blk(2,%("data"str,list(nl,nl,nl,IO dV)(Vars)))
DEF dIm (IO)(def(Eqns)) == blk(2,%("def"str,list(nl,nl,nl,IO dEq)(Eqns)))
DEF dIm (IO)(other(Pos, id, _)) ==
  blk(0, %(str("other:"), dPos(IO)(Pos), str(id)))

