IMPLEMENTATION InterDumpExpr
/* %- Copyright 1989 - 1998 by the Opal Group, TU Berlin. All rights reserved
      See OCSHOME/etc/LICENSE or 
      http://uebb.cs.tu-berlin.de/~opal/LICENSE.html for details
*/
-- % $Date: 1998-06-16 15:59:37 $ ($Revision: 1.1.1.1 $)
-- ============================================================================
-- Autor:	ralfi
-- Projekt:	OPAL1-Compiler - Zwischensprache InterOpal
-- Zweck:       Dumproutinen fuer InterOpal, speziell expression
-- ============================================================================

IMPORT	Format		ONLY	blk brk format nl str : denotation -> format
	FormatFun1	ONLY	list
	InterOpal	ONLY	any apply as block cases comp den eqn
				expr :SORT fct :SORT guard ident :SORT
				interOpal :SORT lambda local
				name : pos ** name -> expr
				name : pos ** name -> pattern name :SORT
				origin :SORT pattern pos :SORT tuple var
				variant
	InterDumpBase
			ONLY	dF dId dN dPos
	Nat		ONLY	0 1 2 3 nat
	Option		ONLY	cont nil? option
	Seq		ONLY	% seq

FUN dV : interOpal -> variant -> format
DEF dV (IO)(variant(Pos,Cons,Test,Comps)) ==
	blk(3,%(dPos(IO)(Pos),nl,dN(IO)(Cons),nl,dN(IO)(Test),nl,
		list("("str,","str,")"str,dC(IO))(Comps)))

FUN dC : interOpal -> comp -> format
DEF dC (IO)(comp(Pos,Sel)) == blk(0,(dPos(IO)(Pos))%(dN(IO)(Sel)))

FUN dEq : interOpal -> eqn -> format
DEF dEq (IO)(eqn(Pos,Lhs,Pattern,Rhs)) == 
	blk(0,%("Eq"str,dPos(IO)(Pos),nl,dP(IO)(Lhs),nl,
		list("Pattern:"str,nl,nl,IO dP)(Pattern),dE(IO)(Rhs),nl))

FUN dP : interOpal -> pattern -> format
DEF dP (IO)(any(Pos)) == blk(0,%(dPos(IO)(Pos),"ANY"str))
DEF dP : interOpal -> pattern -> format (IO)(name(Pos,Name)) ==
        blk(0,%(dPos(IO)(Pos),";pn;"str,dN(IO)(Name)))
DEF dP (IO)(var(Pos,Var)) == blk(0,%(";pv;"str,dVar(IO)(Var)))
-- dPos(IO)(Pos), kommt in Var vor!

DEF dP (IO)(as(Pos,Var,Pattern)) ==
	blk(0,%(dVar(IO)(Var),"AS"str,dP(IO)(Pattern)))
-- dPos(IO)(Pos), kommt in Var vor!

DEF dP : interOpal -> pattern -> format (IO)(apply(Pos,Funct,Arg)) ==
        blk(2,%(dPos(IO)(Pos),";pa;"str,dP(IO)(Funct),nl,
                "("str,dP(IO)(Arg),")"str))
DEF dP : interOpal -> pattern -> format (IO)(tuple(Pos,Elems)) ==
        blk(1,%(dPos(IO)(Pos),";pt;"str,nl,
                list("("str,","str,")"str,IO dP)(Elems)))

FUN dVar : interOpal -> var -> format
DEF dVar (IO)(var(Pos,Ident,Symbol,Fct)) == 
	blk(0,%(dPos(IO)(Pos),dId(IO)(local)(Ident),Symbol str,
		":"str,dF(IO)(Fct)))

FUN dE : interOpal -> expr -> format
DEF dE : interOpal -> expr -> format (IO)(name(Pos,Name)) ==
        blk(0,%(dPos(IO)(Pos),";n;"str,dN(IO)(Name)))
DEF dE (IO)(den(Pos,Str)) == blk(0,%(dPos(IO)(Pos),";d;"str,Str str))
DEF dE : interOpal -> expr -> format (IO)(tuple(Pos,Elems)) ==
        blk(1,%(dPos(IO)(Pos),";t;"str,nl,
		list("("str,","str,")"str,IO dE)(Elems)))
DEF dE : interOpal -> expr -> format (IO)(apply(Pos,Funct,Arg)) ==
        blk(2,%(dPos(IO)(Pos),";a;"str,dE(IO)(Funct),nl,
		"("str,dE(IO)(Arg),")"str))
DEF dE (IO)(cases(Pos,SGuards,Else)) ==
  LET	DElse	== IF Else nil? THEN brk(0)
		   ELSE dE(IO)(Else cont) FI
  IN    blk(0,%(list(blk(0,%(dPos(IO)(Pos),";c;"str,nl)),nl,nl,IO dG)(SGuards),
		DElse))
DEF dE (IO)(lambda(Pos,Vars,Body)) ==
        blk(0,%(list(blk(0,%(dPos(IO)(Pos),";\\;"str)),nl,nl,IO dVar)(Vars),
		dE(IO)(Body)))
DEF dE (IO)(block(Pos,Eqns,Body)) ==
        blk(0,%(list(blk(0,%(dPos(IO)(Pos),";b;"str)),nl,nl,IO dEq)(Eqns),
		dE(IO)(Body)))

FUN dG : interOpal -> guard -> format
DEF dG (IO)(guard(Pos,If,Then)) ==
        blk(0,%(dPos(IO)(Pos),";if;"str,nl,"IF"str,dE(IO)(If),nl,"THEN"str,dE(IO)(Then)))


