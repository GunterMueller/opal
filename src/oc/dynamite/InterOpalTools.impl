IMPLEMENTATION InterOpalTools

IMPORT InterOpal COMPLETELY
       InterOpalEquality ONLY = : kind ** kind -> bool
       Map COMPLETELY
       Seq COMPLETELY
       SeqFilter ONLY |
       Nat ONLY 0 1 - succ max
       Set COMPLETELY
       Denotation ONLY = ++ slice #
       Pair ONLY 1st
       Option ONLY avail nil
       OptionMap ONLY *
       Com ONLY succeed break


DEF lookup(Structs, name(Ident, Origin, _)) ==
  objs(Structs ! Origin) ! Ident


DEF formalParams(Struct) ==
  IF formal def? insts(Struct) THEN insts(Struct) ! formal
  ELSE <>
  FI


DEF newOriginNo(Structs) ==
  succ(MaxOriginNo)
  WHERE MaxOriginNo == IF dom(Structs) {}? THEN 0
		       ELSE no(max(dom(Structs)))
		       FI


DEF newIdentNo(Struct) == succ(MaxObj)
  WHERE MaxObj == IF ObjIds {}? THEN 0
		  ELSE no(max(ObjIds))
		  FI
	ObjIds == dom(objs(Struct))


DEF newInstNo(Struct) == succ(MaxInstNo)
  WHERE MaxInstNo == IF MaxInst inst? THEN no(MaxInst)
		     ELSE 0
		     FI
	MaxInst == max(dom(insts(Struct)))


DEF findStruct(name, Structs) ==
  1st * (\\ origin, struct. (symbol(struct) = name)) find? Structs


DEF findSort(name, struct) ==
  1st * (\\ ident, obj. (kind(obj) sort?) and (symbol(obj) = name))
        find? objs(struct)


DEF Object = (Symbol, Kind) ==
  IF symbol(Object) = Symbol THEN kind(Object) = Kind
  ELSE false
  FI


-- FUN ok? : denotation -> option[interOpal] -> com[interOpal]

DEF ok?(_)(avail(IO)) == succeed(IO)
DEF ok?(InterFile)(nil) == 
  break("interopal file " ++ InterFile ++ " could not be read")


-- FUN baseName : denotation -> denotation

DEF baseName(InterFile) ==
  InterFile slice (0, #(InterFile) - #(".????.inter") - 1)

