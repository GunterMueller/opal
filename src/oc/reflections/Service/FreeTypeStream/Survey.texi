@ignore

  $Header: /home/florenz/opal/home_uebb_CVS/CVS/ocs/src/oc/reflections/Service/FreeTypeStream/Survey.texi,v 1.1 1999-03-23 12:37:45 kd Exp $
  $Author: kd $
  $Date: 1999-03-23 12:37:45 $
  $State: Exp $

  $Locker:  $
  $Revision: 1.1 $
  $Name: not supported by cvs2svn $

  $Log: not supported by cvs2svn $
  Revision 1.1  1999/03/20 22:51:42  opaladm
  neu eingefuehrt

  Revision 1.3  1998/11/11 14:26:29  silver
  Correction for html conversion.

  Revision 1.2  1998/11/03 14:16:46  silver
  Finalized first version of documentation.

  Revision 1.1  1998/06/24 13:27:48  silver
  Initial revision


@end ignore

@subsection Introduction

This subsystem intends to provide two things:

@itemize @bullet
@item
A C++ like stream library for Opal.

@item
A generic input/output facility for free types (a pretty printer).
@end itemize

The C++ stream library is a widely used library that has turned to be
quite elegant and easy to use. The @code{FreeTypeStream} system intends
to provide Opal with the same elegance and easy of use for input and
output. Due to the fact that Opal is a side-effect free language, it is
not entirely possible to use exactly the same syntax as C++, but the
stream library comes close...

@subsection Output

In order to use the output facilities of the free type stream system,
you must import two structures: @code{OStream} and
@code{OStreamShift}.

The structur @code{OStream} exports a sort named
@code{ostream}. There are two predefined such output streams:
@code{cout} and @code{cerr}. Furthermore, you can use the function
@code{ofstream} which converts an output file into an @code{ostream}. 

Once you have an output stream, you can stuff things into it. This is
done using the C++ left shift operator. This results in the following
code:

@example
IMPORT  Nat             COMPLETELY
        OStream         COMPLETELY
        OStreamShift    COMPLETELY

FUN generations : nat
DEF generations == 10

FUN rabbit : nat -> nat
DEF rabbit (n) == IF n < 2 THEN 1 
                           ELSE rabbit (n-1) + rabbit (n-2) 
                  FI

DEF main ==
  cout << "Hello user." << endl;
  cout << "Two rabbits produce after " << generations;
  cout << " generations " << rabbit (generations) 
       << " rabits." << endl
@end example


@subsection The small print

The free type stream library is build on top of the normal input/output
library of Opal. That means it is still entirely side effect
free. Consider the following code:

@example
FUN dummy: void
DEF dummy ==
  LET
    print1 == cout << "Hello world." << endl
    print2 == cout << "Hello world again." << endl
    print3 == print1; print2
  IN
    nil
@end example
 
This will not print a single line! The reason is, that the expression
@code{cout << "..." << endl} is a command. By itself, a command does
nothing. You can pass it around, copy it, compose it with other commands 
to build new commands (like the @code{print3} command) and so forth --
this will not have any effect with respect to the output.

Only, if you @emph{execute} a command some output is produced. The funny 
thing is, in Opal you can execute only one (!) command per program -- it 
is the command generated by the top-level function and it gets executed
automatically by the runtime system. 

For example, in the rabbit example we constructed one big output
command, by composing three smaller output commands (the lines starting
with @code{cout << ...}). This one large command was then executed by
the Opal runtime system.

Whenever you wish to output something in Opal, you must ensure that the
command, which produces this output, is composed in some way with the
top level commands. This implies, that output must normally be done
fairly "high" in the program. That is the price to pay for side-effect
freeness. (Note, that these restrictions naturally do not apply to
debugging. There you can simply execute a command whenever you want.)

@subsection Input

Input is not as easy as output, at least with respect to syntax, which
is not the same as the C++ syntax. There reason is, consider the
following typical C++ code:

@example
void main ()

@{
  int i;
  cout << "Please enter a number: " << endl;
  cin >> i;
  cout << "You typed " << i << endl;
@}
@end example

If we were to write in Opal
@example
  -- ...
  cout << "Please enter a number: " << endl;
  cin >> i;
  cout << "You typed " << i << endl
  -- ...
@end example
we would have a problem: The variable @code{i} must either be already
defined or it must be introduced now. If @code{i} is already defined,
then we cannot change its value, so the call @code{cin >> i} would not
make any sense. If @code{i} is not yet defined, it is simply a syntax
error. 

So, what do we do? The main problem is, that we must introduce a new
variable @code{i}, @emph{after} and not @emph{before} the call @code{cin 
>> ...}. The trick is to introduce this variable as the parameter of a
lambda function (this might sound a bit weird and indeed it would be
nicer if the language provided some easier way of introducing new
variables in this context, but life is hard). So, we write the
following:
@example
  -- ...
  cout << "Please enter a number: " << endl;
  cin >> (\\ i.
  cout << "You typed " << i << endl
  -- ...
@end example
This does not look as nice as the C++ construction, but it works fine. 
Here is a more refined version of the rabbit example:
@example
IMPORT  Nat             COMPLETELY
        IStream         COMPLETELY
        IStreamShift    COMPLETELY
        OStream         COMPLETELY
        OStreamShift    COMPLETELY

FUN rabbit : nat -> nat
DEF rabbit (n) == IF n < 2 THEN 1 
                           ELSE rabbit (n-1) + rabbit (n-2) 
                  FI

DEF main ==
  cout << "How many generations? ";
  cin  >> (\\ generations.
  cout << "Two rabbits produce after " << generations;
  cout << " generations " << rabbit (generations)
       << " rabits." << endl)
@end example



@subsection Input filters

A program should always ensure that the user input is valid and
useful. These checks are a little bothersome in a language like Opal,
because the classical loop constructions around a @code{cin >> ...}
statement must be programmed in separate functions and this tends to get 
involved.

A very simple and rudimentary input verification can be constructed
using input filters. To use them, you take an input stream (like
@code{cin}) and then apply a filter using the operator @code{|}. Such a
filter must be a function which takes an argument of the expected type
and returns true if this argument is a valid input. If the user types a
value which does not pass the filter, the user is reprompted and only if 
he or she enters a valid input it is passed to the function following
the @code{cin} operator.

The following code will read a number which is guaranteed to be between
1 and 100:

@example
  cout << "Please enter a number between 1 and 100: ";
  cin | (_ >= 1) | (_ <= 100) >> (\\ i.
  cout << "You entered " << i
@end example

As a small further aid, you can specify a prompt string for the
input. This string is reprompted every time the user inputs an invalid
number. The prompt is passed to the input stream as a parameter like
this:

@example
DEF prompt == "Please enter a number between 1 and 100: "

  -- ...
  cin (prompt) | (_ >= 1) | (_ <= 100) >> (\\ i. 
  cout << "You entered " << i
@end example


@subsection Further examples

Here are some further examples of how to use the stream library:
@example
IMPORT  Password        ONLY    scrambledPassword : string
                                scramble : string -> string

FUN checkPassword: string -> bool
DEF checkPassword (passwd) ==
  scrambledPassword = scramble (passwd)

DEF main ==
  cin ("Password: ") | checkPassword >> (\\ _ .
  cout << "Hi, user" << endl;
  -- ...
@end example

A multiplier:

@example
DEF main ==
  cout << "This program calculates the product of two numbers."
       << endl; 
  cout << "First number: ";
  cin  >> (\\ n1.
  cout << "Second number: ";
  cin  >> (\\ n2.
  cout << n1 << " * " << n2 << " = " << n1 * n2 << endl))
@end example


@subsection Structures of the free type library

The following structures make up the free type library:
@table @code
@item OStream
Declares the type @code{ostream} and production functions for this type.

@item OStreamShift
Declares the operator @code{<<} which is used to output free type objects.

@item IStream
Declares the type @code{istream} and production functions for this
type. Actually, the type @code{istream} is declared elsewhere, but is
reexported by @code{IStream}, so you can use it as if it were defined here.

@item IStreamShift
Declares the operator @code{>>} which is used to input free type objects.

@item InputMonad
This structure declares the type @code{istream} in an "unreflected"
way. This is necessary because the operator @code{>>} takes two sorts and we
do not wish to reflect the second sort. As a user of the system, you will
not need @code{InputMonad}.
@end table
