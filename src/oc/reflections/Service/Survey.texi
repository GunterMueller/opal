@ignore

  $Header: /home/florenz/opal/home_uebb_CVS/CVS/ocs/src/oc/reflections/Service/Survey.texi,v 1.1 1999-03-23 12:37:11 kd Exp $
  $Author: kd $
  $Date: 1999-03-23 12:37:11 $
  $State: Exp $

  $Locker:  $
  $Revision: 1.1 $
  $Name: not supported by cvs2svn $

  $Log: not supported by cvs2svn $
  Revision 1.1  1999/03/20 22:51:33  opaladm
  neu eingefuehrt

  Revision 1.5  1999/01/05 14:45:05  silver
  *** empty log message ***

  Revision 1.4  1998/11/12 14:55:51  silver
  Added short description for new subsystems.

  Revision 1.3  1998/11/11 14:26:29  silver
  Correction for html conversion.

  Revision 1.2  1998/11/03 14:16:46  silver
  Finalized first version of documentation.

  Revision 1.1  1998/06/24 13:27:48  silver
  Initial revision


@end ignore

@section Overview

The service system is a collection of structures which are build on top
of the reflection system. Using the reflection mechanism, these
structures provide functions which would normally not be possible to
implement in Opal. 

The subsystems of the service system rely heavily on the notion of a
@emph{free type}. Put simply, a free type is a type which is introduced
using Opals @code{TYPE} statement and a corresponding @code{DATA}
statement (thus, most types you define in Opal are actually free
types). A more detailed discussion of free types can be found in the
next section.

@table @code
@item FreeTypeStream
A collection of structures which provides a C++ like stream
library. Naturally, it is not possible to implement a "real" C++ stream
library in Opal (the input syntax of C++ simply does not fit), but
@code{FreeTypeStream} comes pretty close. Furthermore, the library
provides generic input and output of free types (something not possible
in C++).

@item FreeTypeOrder
The functions in this system allow you to compare values whose type is a 
free type. Furthermore, specialized comparison versions are provided for 
many build-in types. 

@item FormalTyping
In this system, you will find all functions that are concerned with
manipulating the type of values. Naturally, that does not mean that you can
@emph{change} the type, but rather that you can unify more general types
with more specific ones and vice versa (safely!).

@item OOP
In this system, some elementary object orientated features are
implemented. Most noticably, you will find virtual functions here, build on
top of the reflection mechanism.
@end table


@section Free types without parameters

Free types are best explained by example: Consider the following piece of 
Opal code:

@example
TYPE nat == 0
            succ (predcessor : nat)
@end example

What does this @emph{really} mean? Formally, this @emph{declares} a new
sort named @code{nat} as well as a bunch of functions for creating and
modifying @code{nat}s, namely @code{0 : nat}, @code{0? : nat -> bool},
@code{succ : nat -> nat} and so forth.

The important point is the following: With such a declaration, we only
give a @emph{specification} of the type @code{nat} (actually only a
signature) and not an @emph{implementation}. Naturally, this is a good
thing here -- we will normally want to implement natural numbers in a
clever and efficient way, so a type @emph{specification} should not
already "nail down" a specific implementation. Many people believe that
this difference between specification and implementation is one of the
most important ideas in computer science...

Most implementations (actually all) of the type @code{nat} will not
implement what we normally think of as a natural number. The reason is,
that computer memory is vast, but limited. Thus, most implementations
limit the sort @code{nat} to have only 2^32 different values. Even
worse, you could give an implementation of @code{nat} which implements 
all necessary functions (@code{0:nat} and so on) but calling these
functions produces very strange results (for example, @code{succ} might
multiply the given number by two).

How do we know that an implementation is good? And by the way, how
do we know that the piece of code above actually refers to the natural
numbers? The idea is to define a @emph{free type} induced by the above 
specification. In the free type, every expressions consisting only of
constructor calls is a distinct ("no confusion") element of the free
type and there are no other elements ("no junk"). In our case, there
must be exactly one element representing the expression @code{0},
exactly one representing @code{succ(0)}, exactly one representing
@code{succ(succ(0))} and so forth. Furthermore, the functions in a free
type must be "as expected". Thus, if @emph{a} represents @code{0} and
@emph{b} represents @code{succ(0)} in a free type, then its @code{succ}
operation must map @emph{a} to @emph{b}.

In Opal, there actually exists a statement which produces a free type
implementation for a given specification: the @code{DATA}
statement. However, there may well be several other (better and faster)
free type implementations for a given specification and you are
encouraged to implement them, if you feel that the automatic free type
generated by @code{DATA} is not good enough for your purposes.

Let's put all of this together:

@itemize @bullet
@item
A @code{TYPE} statement only gives a signature of a type. Furthermore,
it often entails an implicit assertion, that the type will be
implemented as a free type -- but do not feel too safe about
this... Normally, if the implementation is not a free type, a @code{SORT} 
statement is used instead of a @code{TYPE} statement.

@item
A free type is an implementation of the type such that there is "no
junk" and "no confusion". There are many possible implementation which
are free types.

@item
The @code{DATA} statement automatically produces a free type
implementation.
@end itemize

For the service system, free types are important as the functions
defined in it will only @emph{work correctly, if the declared types have
a free type implementation}. For example, if you use the @code{DATA}
statement to implement the natural numbers above (not a good idea) then
the function @code{<} from the @code{FreeTypeOrder} system will give a
total ordering of the natural numbers. However, if you implement the
@code{succ} function strangely instead (like multiplying with two), you
no longer have a free type and hence the @code{<} function will no
longer produce a total ordering of whatever strange thing you implemented. 

This is the reason, why most structures of the service subsystem have
@code{FreeType} in their names -- they only work properly for free
types.

@section Free types with parameters

What is a free type implementation of the following specification?  
@example
TYPE seq == <>
            :: (ft : alpha, rt : seq)
@end example

We now have a parameter in the declaration. A free
type implementation must take the parameter sort @code{alpha} into
account. That means, that we are actually interested in a
@emph{mapping}, which takes an implementation for @code{alpha} and gives
us an implementation for @code{seq[alpha]}. Such a mapping is called a
functor. 

We call such a functor a free type functor (or simply free functor), if
for any concrete parameter implementation (for example @code{foo}) the
@code{seq} part of the implementation of @code{seq[foo]} is a free type
implementation of @code{seq} where we add constructors for every element
of type @code{foo}. This way, "no confusion" ensures that @code{apple ::
<>} is different from @code{banana :: <>}, provided that @code{apple} is
different from @code{banana} in @code{foo}. Likewise, "no junk" no means 
that there may not be an element @code{mango :: <>} if there is no
@code{mango} in @code{foo}.

As can be seen, it is not always very easy to check if a functor (an
implementation of @code{seq}) is a free functor. Fortunately, the Opal
construct @code{DATA} will also automatically produce a free functor for 
you.





