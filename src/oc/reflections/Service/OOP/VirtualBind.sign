/* %- Rcs-Info (automatically generated) 

  $Header: /home/florenz/opal/home_uebb_CVS/CVS/ocs/src/oc/reflections/Service/OOP/VirtualBind.sign,v 1.1 1999-03-23 12:37:56 kd Exp $
  $Author: kd $
  $Date: 1999-03-23 12:37:56 $
  $State: Exp $

  $Locker:  $
  $Revision: 1.1 $
  $Name: not supported by cvs2svn $

  $Log: not supported by cvs2svn $
  Revision 1.1  1999/03/20 22:51:45  opaladm
  neu eingefuehrt

  Revision 1.6  1999/03/04 10:30:30  silver
  Fixed typo.

  Revision 1.5  1999/01/27 12:21:27  silver
  Added new forms of virtual functions.

  Revision 1.4  1998/12/19 17:39:28  silver
  Changed to new pragma style.

  Revision 1.3  1998/12/10 23:58:58  silver
  Using pragma now.

  Revision 1.2  1998/11/12 14:47:13  silver
  First documentation.

*/
/* %
This structure allows you to bind functions. Binding is the first step
towards creating a virtual function. For every type you are interested
in, you must provide one function wish is to be called for that
type. This is done by calling the operator @code{::} together with the
function. The type is automatically derived.
*/

SIGNATURE VirtualBind [alpha, aux] 

/$ DYNAMIC [alpha] $/

-- $Author: kd $
-- $Date: 1999-03-23 12:37:56 $
-- $Revision: 1.1 $

SORT alpha
SORT aux

IMPORT	Virtual[aux]		ONLY	methodBinding
					constructorBinding
					accessorBinding
					binAccessorBinding
					method: SORT 
					constructor:SORT 
					accessor:SORT
					binAccessor:SORT
	Seq[methodBinding]	ONLY	seq 
	Seq[accessorBinding]	ONLY	seq
	Seq[binAccessorBinding]	ONLY	seq
	Seq[constructorBinding]	ONLY	seq


-- %$Binding functions$ 
/* % 
You use the following functions as follows: You write a function for
some specific type. For example, for a pretty printer, you might write
a function that prints @code{nat}s. Let's call this function
@code{printNat : nat -> denotation}. Second, you write a function that
prints characters: @code{printChar : char -> denotation}. Then, you
create a binding for both functions by writing: @code{printNat ::
printChar :: <>}.
*/
FUN :: :    (alpha ** aux -> alpha) ** seq[methodBinding] 
	 -> seq[methodBinding]
FUN :: :    (alpha -> aux)  ** seq[accessorBinding]
	 -> seq[accessorBinding]
FUN :: :    (alpha ** alpha -> aux) ** seq[binAccessorBinding]
	 -> seq[binAccessorBinding]
FUN :: :    (aux  -> alpha) ** seq[constructorBinding]
	 -> seq[constructorBinding]


-- %$Sending messages to objects$ 
/* % 
The @code{send} interface follows the OOP-thinking. The idea is, that
an objects gets send a message (function) which acts on the
object. For example, to get the size of a window, you might send the
window the message @code{giveSize}. You could then write
@code{(myWindow send giveSize)}. Likewise, you might move a window by
calling @code{myWindow send (moveUp, 10)}. 
*/
FUN send : alpha ** method ** aux        -> alpha
FUN send : alpha ** accessor             -> aux
FUN send : alpha ** alpha ** binAccessor -> aux
FUN send : constructor ** aux            -> alpha
