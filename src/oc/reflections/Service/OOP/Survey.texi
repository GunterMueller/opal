@ignore

  $Header: /home/florenz/opal/home_uebb_CVS/CVS/ocs/src/oc/reflections/Service/OOP/Survey.texi,v 1.1 1999-03-23 12:37:52 kd Exp $
  $Author: kd $
  $Date: 1999-03-23 12:37:52 $
  $State: Exp $

  $Locker:  $
  $Revision: 1.1 $
  $Name: not supported by cvs2svn $

  $Log: not supported by cvs2svn $
  Revision 1.1  1999/03/20 22:51:45  opaladm
  neu eingefuehrt

  Revision 1.3  1999/01/05 14:44:49  silver
  *** empty log message ***

  Revision 1.2  1998/11/17 17:10:30  silver
  First version,

  Revision 1.1  1998/11/12 14:56:50  silver
  Initial revision


@end ignore



@subsection Overview

Reflections make possible a simple form of object orientated programming in
Opal. Naturally, you cannot expect a full object orientated compiler
backend. Rather, the OOP implementations build on top of the reflection
system allows you to express yourself in the OOP language inside Opal in a
limited way.

Object orientated programming is a wide and ever expanding field. The
absolute minimum of a "real" OOP system consist of the availability of

@itemize @bullet
@item
The notion of an object as a concrete value together with a set of
operations. 

@item 
The notion of a class as an abstract collection of objects. 

@item
The notion of subclassing.

@item
The notion of messaging.
@end itemize

In Opal, objects are represented by values and operations are simply
functions that operate on these values. Furthermore, classes are types, as
types are collections of values. 

Opal does not support subtyping and hence to easy and simple way exists to
implement subclassing and inheritance. 

Hence, only for the concept of messaging, reflections need to be used. More 
precisely, using reflections one can implement @emph{virtual
functions}. What that means is explained presently.


@subsection Virtual functions

A virtual function can be thought of as a function which behaves differently
for different types. Naturally, this means that the function is
polymorphic. 

Opal heavily uses polymorphic function in the library, and supports
polymorphic functions very well, so what's new about virtual functions?

The main difference between a normal polymorphic function and a virtual
function is, that a virtual function needs not be freely generated. Recall
from the introduction to the service system, that a type is said to be
@emph{freely generated} if the implementation of the type is a free functor.
Not only types can be generated freely, but also functions. 

In essence, we called the implementation of a polymorphic type @emph{free},
if it does not "mess" with its parameter sorts. For example, a sequences
over a type @code{foo} must contain for each element of @code{foo} one
sequence of length one, which contains exactly this element. No junk meant,
that a freely generated sequence type will not contain a list @code{mango ::
<>} if there is no @code{mango} in @code{foo}; no confusion meant, that
@code{apple :: <>} and @code{banana :: <>} are not the same if @code{apple}
and @code{banana} are different if @code{foo}.

What happens is, that the implementation of a sequence may not "look inside"
the type @code{foo}, but must rather use the type as is. All normal
polymorphic functions in Opal share this property: If @code{alpha} is the
only parameter type of a structure, there is actually only one function
@code{f : alpha -> alpha}, you can program, namely the identity
function. The reason is, that you cannot "look inside" the type
@code{alpha}. Instead, elements of type @code{alpha} must be passed along
perfectly intact.

For virtual functions, things are different. A virtual function may "look
inside" the type @code{alpha} and for each concrete type @code{alpha} it may
behave differently.


@subsection Building virtual functions

The first step towards using virtual functions is to construct one. As we
pointed out already, a virtual function may behave differently for different
types of input. Obviously, it is most natural to provide one "behaviour" for
each type you are interested in.

As an example, let's say we wish to create a virtual function that works on
number types and computes the n-th power of its input. Let's say, that
already have the functions 

@example
FUN powReal : real ** nat -> real
DEF powReal (x, 0) == "1"!
DEF powReal (x, succ(n)) == x * powReal (x, n)

FUN powInt : int ** nat -> int
DEF powInt (m, 0) == 1
DEF powInt (m, succ(n)) == m * powInt (x, n)
@end example

Now, we wish to build a virtual function which works both on reals and
integers. This is done as follows:

@example
FUN power : method

DEF power ==
  method(powReal :: powInt :: <>)
@end example

A virtual function is normally of type @code{method}. You construct such a
method by giving a list of functions which have functionality @code{f :
alpha ** aux -> alpha}. Here, the type @code{aux} must be equal for all
functions, whereas the type @code{alpha} must be instantiated differently
for each function.

@subsection Calling a function

Having constructed an object of type @code{method} (a virtual function), we
naturally which to use it to compute values. This is done by "sending" an
object this method as a message together with a parameter:

@example
DEF main ==
  cout << "pi^3 = " << pi send (power, 3) << endl;
  cout << "2^16 = " << 2  send (power, 16) << endl
@end example

You might wonder about the strange calling convention, where we write the
method in the middle. The notations becomes clearer, if we have a look at a
more complicated example.

We now have several types like
@example
TYPE point == point (x : real, y : real)
TYPE rect  == rect  (mid : point, h : real, w : real)
TYPE circ  == circ  (mid : point, r : real)
-- ...
@end example

Furthermore, we have several virtual function, like
@example
FUN moveTo : method
DEF moveTo ==
  method ((\\ p : point, to : point. to) ::
          (\\ r, to. rect (to, h(r), w(r))) ::
          (\\ c, to. circ (to, r(c))) :: <>)

FUN moveBy : point ** point -> point
DEF moveBy (p, by) == point(x(p) + x(by), y(p) + y(by))

FUN moveBy : method
DEF moveBy ==
  method ((\\ p : point, by : point. moveBy(p, by)) ::
          (\\ r, to. rect (moveBy(mid(r), by), h(r), w(r))) ::
          (\\ c, to. circ (moveBy(mid(c), by), r(c))) :: <>)

-- ...
@end example

Then, we can now write
@example
DEF example ==
  LET
    p == point (1,1)
    c == circ (point (2,2), 1, 1)
  IN
    c send (moveTo, p send (moveBy, point (2, 3)))
@end example

@subsection Accessors, constructors and methods

Sometimes, a virtual function should not return a new object, but rather a
value of a specific type. You can think of such a virtual function as an
"accessor" function, as it accesses a single aspect of an object and leaves
the object as is. 

An accessor function must have type @code{a : alpha -> aux}. Here, again,
@code{alpha} is the polymorhpic type and @code{aux} is the return value,
which is equal for all functions that make up a virtual function.

@example
FUN area : accessor
DEF area ==
  accessor ((\\ p : point. 0) ::
            (\\ r. h(r) * w(r)) ::
            (\\ c. pi*r(c)*r(c)) :: <>)


FUN unitArea : real
DEF unitArea ==
  circ (point (0, 0), 1) send area
@end example

The inverse of accessors are constructors. These are given a value of a
single specific type and produce objects of the required polymorphic type:

@example
FUN defaultObject : constructor
-- Construct a default object at a given location
DEF defaultObject ==
  constructor ((\\ where. where) ::
               (\\ where. rect(where, 1, 1)) ::
               (\\ where. circ(where, 1)) :: <>)

FUN unitArea2 : real
DEF unitArea2 ==
  (defaultObject send (point (0, 0))) send area
@end example


@subsection Direct calls

Apart from the @code{send} operation, you can also use the function
@code{!}. This works like @code{send}, except that it takes a reflection
instead of a value. For example, the function @code{unitArea2} could have
been written equivalently as

@example
FUN unitArea3 : real
DEF unitArea3 ==
  aera ! (defaultObject ! (reflect[circ], point (0,0)))
@end example

Although it is a bit awkward, that you must construct and deconstruct
reflection when using @code{!}, it is very useful for applying virtual
functions to whole sequences of reflections:

@example
FUN picture : seq[reflection]
DEF picture ==
  reflect (rect (point (1,1), 1, 1)) ::
  reflect (rect (point (3,3), 1, 2)) ::
  reflect (circ (point (1,1), 5)) ::
  -- ...
  reflect (circ (point (5,6), 2)) :: <>

FUN moveUp : real ** seq[reflection] -> seq[reflection]
DEF moveUp (howFar, s) ==
  (\\ refl. moveBy ! (refl, point(0, howFar))) * s
  

DEF main ==
  moveUp (5, picture)
@end example










