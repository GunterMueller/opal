/* %- Rcs-Info 

  $Header: /home/florenz/opal/home_uebb_CVS/CVS/ocs/src/oc/reflections/ReflectionCore/Reflection.sign,v 1.1 1999-03-23 12:36:54 kd Exp $
  $Author: kd $
  $Date: 1999-03-23 12:36:54 $
  $State: Exp $

  $Locker:  $
  $Revision: 1.1 $
  $Name: not supported by cvs2svn $

  $Log: not supported by cvs2svn $
  Revision 1.1  1999/03/20 22:51:23  opaladm
  *** empty log message ***

  Revision 1.14  1999/02/23 14:45:07  schintke
  Implementation of codeReflection

  Revision 1.13  1999/02/22 13:50:57  schintke
  changed internally used type from void to obj'RUNTIME

  Revision 1.12  1998/12/06 20:30:04  silver
  First version with compiler extentions.

  Revision 1.11  1998/11/12 13:20:10  silver
  Implementation of hashed sortReflections.

  Revision 1.10  1998/11/03 16:52:11  silver
  Sort reflection may now also be constructed by the user.

  Revision 1.9  1998/11/03 13:17:42  silver
  Small changes.

  Revision 1.8  1998/10/20 13:35:04  silver
  Fixed a spelling mistake.

  Revision 1.7  1998/10/09 15:54:55  silver
  Moved comparison and equality of sortReflections into REFLECTION.

  Revision 1.6  1998/09/30 17:25:17  silver
  Worked in proposals from meeting on 30sep98.

  Revision 1.5  1998/09/28 16:59:49  silver
  Added further documentation.

  Revision 1.4  1998/06/16 12:13:13  trancon
  Apply and tuple implemented

  Revision 1.3  1998/05/27 13:54:57  silver
  Constructor for sortReflection now named freeType.

  Revision 1.2  1998/05/22 11:07:42  silver
  Till's proposal for namings implemented into code.

  Revision 1.1  1998/05/22 08:55:40  silver
  Initial revision

*/

/* % 
In this structure, the basic types used by the reflection system are
defined. Furthermore, all functions that operate on reflections rather
than values are also defined here. Functions for actually reflecting a
value can be found in @ref{@Sign{ReflectionBuild}}.

There are actually several things you can reflect in a programming
language. This following table gives a list of them:
@table @code
@item reflection
Actually, this should be though of as a
@emph{@code{valueReflection}}. However, its a but cumbersome so we
use the term @code{reflection} instead. Such a value reflection always
encapsulates a value of some type.

@item typeReflection
This reflects an Opal type, which can be a sort, a product of sorts or
a function space. 

@item sortReflection
Once you know that the type of some value actually is a sort, you can
ask further information concerning this sort (its constructors,
selectors and so on). A @code{sortReflection} provides a handle for
talking about a specific Opal sort (instead of the type which happens
to be made up of that sort).

@item codeReflection
A reflection of a piece of code.

@end table
*/


-- %$Declaration and imports$

SIGNATURE Reflection

-- $Author: kd $
-- $Date: 1999-03-23 12:36:54 $
-- $Revision: 1.1 $

IMPORT SortReflection           ONLY sortReflection
       Seq[typeReflection]	ONLY seq
       Option[codeReflection]   ONLY option

-- %$Value Reflection$

/* %
The most important reflection is the reflection of a single @emph{value}.
Applying the function @code{reflect} to a value will result in a
@code{reflection}. You can then use such a reflection to enquire the
value's type and possibly - if available - a reflection of the code
from which this value stems. Note, that this code information is 
available only for values which have been produced in a special way.
See @ref{@Sign{ReflectionBuild}} for details. */

SORT reflection

FUN  type    : reflection -> typeReflection
FUN  code?   : reflection -> bool
FUN  code    : reflection -> option[codeReflection]


-- %$Type Reflection$

/* %
A type reflection reflects the type of an object. In Opal, there are
basically three forms of types:
@itemize @bullet
@item
Every sort is a type.
@item
The cartesian product of types is a type. 
@item 
The function space from one type to another type is a type.
@end itemize
Note, that apart from enquiring a type, you might also wish to
construct your own type reflections and then try to match them
against a given type reflection.
*/

TYPE typeReflection == sort     (sort    : sortReflection)
		       product  (factors : seq[typeReflection])
		       function (domain  : typeReflection, 
		                 codomain: typeReflection)

FUN < = : typeReflection ** typeReflection -> bool


-- %$Code Reflection$

/* %
A code reflection reflects the (InterOpal-) code which is 
executed, if a value is evaluated. Thus, a simple value like
the natural number seven will not have a code reflection. However,
the @emph{function} @code{7} which produces such a number does
have a code reflection.
*/

TYPE codeReflection == named (identifier: denotation,
			      structure : denotation)
		       lambda

/* %
@ignore
*/
-- not for user purpose -------------------------------------------

IMPORT RUNTIME ONLY obj

FUN getValue : reflection -> obj
FUN createReflection : obj ** typeReflection -> reflection
FUN createReflection : obj ** typeReflection ** codeReflection -> reflection


/* %
@end ignore
*/

