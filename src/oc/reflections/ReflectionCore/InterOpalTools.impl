IMPLEMENTATION InterOpalTools

IMPORT
       BOOL 		 COMPLETELY
       Com 		 ONLY succeed break EXEC
       Denotation 	 ONLY = ++ slice #
       InterOpal 	 COMPLETELY
       InterOpalEquality ONLY = : kind ** kind -> bool
       InterOpalIO 	 COMPLETELY
       Map   		 COMPLETELY
       MapConv 		 ONLY asSeq
       MapFilter 	 ONLY |
       Nat 		 ONLY 0 1 - succ max
       Option 		 ONLY avail nil cont avail? nil?
       OptionMap 	 ONLY *
       Pair 		 ONLY 1st 2nd
       Seq 		 COMPLETELY
       SeqFilter 	 ONLY |
       SeqMap 		 ONLY *
       SeqOfSeq 	 ONLY flat
       SeqZip   	 ONLY zip
       Set 		 COMPLETELY

-- %$Functions for browsing interOpal$
DEF lookup(Structs, name(Ident, Origin, _)) ==
  objs(Structs ! Origin) ! Ident

DEF formalParams(Struct) ==
  IF formal def? insts(Struct) THEN insts(Struct) ! formal
  ELSE <>
  FI

DEF findStruct(name, Structs) ==
  1st * (\\ origin, struct. (symbol(struct) = name)) find? Structs

DEF findSort(name, struct) ==
  1st * (\\ ident, obj. (kind(obj) sort?) and (symbol(obj) = name))
        find? objs(struct)

DEF Object = (Symbol, Kind) ==
  IF symbol(Object) = Symbol THEN kind(Object) = Kind
  ELSE false
  FI

DEF getMainStruct (inter) ==
  structs(inter) ! main

DEF findObjectsByName (namedeno, interOpal) ==
  LET mainStruct == getMainStruct(interOpal)
      allObjects == objs(mainStruct)
      predicate == \\ ident, object. (symbol(object) = namedeno)
  IN
    *(2nd, (asSeq(| (predicate, allObjects))))

--FUN getNameAsDeno : interOpal ** name -> denotation
DEF getNameAsDeno(interOpal, name) == 
  LET matchingStruct == structs(interOpal) ! origin(name)	
  IN
    symbol(objs(matchingStruct) ! ident(name))

FUN getModuleNameAsDeno : interOpal ** name -> denotation  
DEF getModuleNameAsDeno(interOpal, name) ==
  LET matchingStruct == structs(interOpal) ! origin(name)
  IN
    symbol(matchingStruct)

-- %$Function to get informations for modifying interOpal$
DEF newOriginNo(Structs) ==
  succ(MaxOriginNo)
  WHERE MaxOriginNo == IF dom(Structs) {}? THEN 0
		       ELSE no(max(dom(Structs)))
		       FI

DEF newIdentNo(Struct) == succ(MaxObj)
  WHERE MaxObj == IF ObjIds {}? THEN 0
		  ELSE no(max(ObjIds))
		  FI
	ObjIds == dom(objs(Struct))

DEF newInstNo(Struct) == succ(MaxInstNo)
  WHERE MaxInstNo == IF MaxInst inst? THEN no(MaxInst)
		     ELSE 0
		     FI
	MaxInst == max(dom(insts(Struct)))

-- %$Functions for interOpal file handling$
-- FUN ok? : denotation -> option[interOpal] -> com[interOpal]
DEF ok?(_)(avail(IO)) == succeed(IO)
DEF ok?(InterFile)(nil) == 
  break("interopal file " ++ InterFile ++ " could not be read")

-- FUN baseName : denotation -> denotation
DEF baseName(InterFile) ==
  InterFile slice (0, #(InterFile) - #(".????.inter") - 1)

DEF getInterOpalFileNames(modulname) ==
  LET path_global == "/usr/ocs/lib/opal_base/"
      path_local  == "OCS/"
      pathseq     == path_local :: path_global :: <>
      filename1   == modulname ++ ".impl.inter"
      filename2   == modulname ++ ".sign.inter"
      result1     == (\\x. x ++ filename1) * pathseq
      result2     == (\\x. x ++ filename2) * pathseq
      result      == flat(zip((\\ x, y . x :: (y :: <>))) (result1, result2))
  IN
    result

DEF getInterOpal(structure) ==
  LET possible_names == getInterOpalFileNames(structure)
  IN
    firstExisting(possible_names)

FUN firstExisting : seq[denotation] -> option[interOpal]
DEF firstExisting(<>) == nil
DEF firstExisting(ft :: rt) ==
  LET interOpal == EXEC(readInterOpal(false, ft))
  IN
    IF interOpal avail? THEN interOpal
    ELSE
      firstExisting(rt)
    FI


