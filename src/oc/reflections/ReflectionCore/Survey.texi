@ignore

  $Header: /home/florenz/opal/home_uebb_CVS/CVS/ocs/src/oc/reflections/ReflectionCore/Survey.texi,v 1.1 1999-03-23 12:37:03 kd Exp $
  $Author: kd $
  $Date: 1999-03-23 12:37:03 $
  $State: Exp $

  $Locker:  $
  $Revision: 1.1 $
  $Name: not supported by cvs2svn $

  $Log: not supported by cvs2svn $
  Revision 1.1  1999/03/20 22:51:23  opaladm
  *** empty log message ***

  Revision 1.5  1998/12/14 16:39:23  silver
  Added sortRefelection.

  Revision 1.4  1998/11/11 15:06:04  silver
  Moved description of FormalTypeConvert to FormalTypeing.texi

  Revision 1.3  1998/11/03 14:16:46  silver
  Finalized first version of documentation.

  Revision 1.2  1998/10/09 16:03:37  silver
  Added further documentation.

  Revision 1.1  1998/06/24 13:27:48  silver
  Initial revision

@end ignore

@section Introduction

The reflection system is at the heart of the reflection project. It contains
all the library files you need to work with reflections. Please note, that
this encompasses only the files you -- as a user -- will need. There are
other internal files managed by the compiler extensions that are
also needed to make reflections work. 

As is customary for Opal libraries, the reflection system consists of
several structures which cooperate to provide the reflection
mechanism. These are:

@table @code
@item Reflection
This structure defines all basic types used by the reflection mechanism
(most noticably the types @code{reflection} and
@code{typeReflection}). Furthermore, all functions can be found here which
manipulate reflections without resorting to actual values. For example, the
function @code{reflect} will not be found here (as it refers to values
instead of reflections). 

@item SortReflection
You cannot only reflect values, but also sorts. In this structure, a type 
@code{sortReflection} is declared together with some useful functions on it. 

@item ReflectionBuild
Here, all functions can be found which convert values into reflections and
vice versa. The most important functions found here are obviously
@code{reflect} and @code{reflects?}.

@item ReflectionFunction
As functions are also infamous first order citizens of Opal, it is only
natural to reflect not only values whose types are sorts, but also
functions. As it is not possible to reflect a function by simply calling the
@code{reflect} function, you can use the functions provided in this
structure to build reflection of functions. (The reason for not being able
to simply call @code{reflect} to reflect a function, has to do with our
approach towards implementing reflections and may well be considered a
short-coming of this approach.)

@end table

@section Basic operations

As stated in the introduction, the basic facility you use when coping with
reflections are the two functions defined in @code{ReflectionBuild}:
@example
FUN reflect   : alpha -> reflection
FUN reflects? : reflection -> option[alpha]
@end example
Here, @code{alpha} is any type (actually a dynamic polymorphic parameter,
but this will become clearer later on) and @code{reflection} is a type
defined in the structure @code{Reflection}. The type @code{option[alpha]} is
a type you will find documented in the standard library -- it simply either
contains a value of type @code{alpha} or no value at all. (Actually, an
@code{option} is Opal-speak for the extension of the type @code{alpha} with
a bottom element.)

Once you have a reflection, you can enquire two things: First, the value
stored inside (using the function @code{reflects?} just introduced) and the
type of the object stored inside. This is done using the function
@example
FUN type      : reflection -> typeReflection
@end example
A @code{typeReflection} is an abstraction of the Opal type mechanism,
defined in @code{Reflection}. You can easily compare two such types and
enquire further information concerning their structure. Please see the
explanations at the definition of @code{typeReflection} for details.
