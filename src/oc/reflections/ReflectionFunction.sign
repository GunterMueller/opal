/* %- Rcs-Info (automatically generated) 

  $Header: /home/florenz/opal/home_uebb_CVS/CVS/ocs/src/oc/reflections/ReflectionFunction.sign,v 1.2 1999-10-09 16:43:38 kd Exp $
  $Author: kd $
  $Date: 1999-10-09 16:43:38 $
  $State: Exp $

  $Locker:  $
  $Revision: 1.2 $
  $Name: not supported by cvs2svn $

  $Log: not supported by cvs2svn $
  Revision 1.1  1999/10/08 19:25:59  kd
  neue Fassung von Baltasar

  Revision 1.8  1999/03/04 10:23:05  silver
  Fixed typo.

  Revision 1.7  1999/03/03 11:08:45  silver
  Documentation changes.

  Revision 1.6  1999/02/24 12:15:26  schintke
  added documentation.

  Revision 1.5  1999/02/23 19:18:09  schintke
  Implemented findSortVariants
  beautyfications

  Revision 1.4  1999/02/22 13:55:33  schintke
  Implemented findFunction

  Revision 1.3  1998/11/03 13:30:36  silver
  Documentation changes.

  Revision 1.2  1998/10/20 13:38:45  silver
  Fixed a spelling mistake.

  Revision 1.1  1998/09/30 17:26:51  silver
  Initial revision

*/

/* %
Apart from the reflection of simple values (more specifically: values
having a sort as type) via the @code{ReflectionBuild} interface, you
can also reflect functions. This is done by searching for a reflection
of some function. Once you have found such a reflection for a function,
you can apply it to another reflection, which must obviously store a
value of the correct type.

There are some subtleties about working with function reflections:
@itemize @bullet
@item 
Reflections of functions can only be applied the reflections of
values whose types is the domain type of the function.

@item
Many functions take more than one argument (think of the function
@code{+ : nat ** nat -> nat}). In this case, the domain of the
function is the (cartesian) product type of the types @code{nat} and
@code{nat}. So, in order to apply a reflection of @code{+} to an
reflection, this reflection must reflect a @emph{pair} of natural
numbers.

@item
You cannot directly reflect a tuple of values. Instead, you can
reflect all the values that make up the tuple and you can then apply
the function @code{x}, which will construct a reflection of such a
pair.
@end itemize
*/

-- %$Declaration and imports$

SIGNATURE ReflectionFunction

-- $Author: kd $
-- $Date: 1999-10-09 16:43:38 $
-- $Revision: 1.2 $

IMPORT Reflection               ONLY value:SORT sort:SORT type:SORT
       Seq[value]               ONLY seq
       Seq[sortVariant]         ONLY seq
       Option[value]            ONLY option

-- %$Finding arbitrary functions$

/* %
In order to search for a specific function, you have to build a
@code{typeReflection}. The functions @code{***} and @code{-->} help
you to do this in a nice and simple way. With @code{***} you can build
product types and with @code{-->} you can build function types. In the
following example, would find the well known function @code{+'Nat}.
@example
LET nat == sort(reflect[nat]) 
IN
  findFunction("+", "Nat", (nat *** nat) --> nat)
@end example
The actual functions are declared as follows: */ 

FUN *** --> : type ** type -> type

/* % 
You can search for a function in two different ways. You must specify
the name of the function and its structure. If appropriate, 
you can also give a typeReflection to specify the functionality of the 
function you search for. */

FUN findFunction : denotation ** denotation ** type -> option[value] 

FUN findFunction : denotation ** denotation -> seq[value] 

-- %$Finding sort variants$

/* % One of the most interesting set of functions you can search for
is the set of constructors, selectors and discriminators associated
with a sort. This is done by the following function: */

TYPE sortVariant    == variant (constructor    : value,
                                selectors      : seq[value],
                                discriminator  : value)

FUN findSortVariants : sort -> seq[sortVariant]

-- %$Using function reflections$

/* %
Once you have generated a reflection of a function, you will want to
apply this function to some value. The most natural way to do so is to
take a reflection of a function and a reflection of a value and then
using the @code{apply} function.

In order for this to work, you might wish to check if the function is 
*/

FUN applicable? : value ** value -> bool

/* % 
to the value (i.e. check if the types match). If so, you can call 
*/

FUN apply : value ** value -> option[value]

/* % 
If you are sure that the command succeeds, you can also use
*/

FUN apply : value ** value -> value

/* %
Sometimes you want to apply some functions in sequence.
Therefore there are some additional @code{apply} functions
for service. Then you don't have to use @code{cont} to get
the result of a previous apply. If an argument is @code{nil}
the result will also be @code{nil}.
*/
FUN apply : option[value] ** value -> option[value]
FUN apply : value ** option[value] -> option[value]
FUN apply : option[value] ** option[value] -> option[value]

-- %$Reflecting a tuple of values$

/* %
In order to apply function reflections to value reflections, you will
sometimes need to create tuples of values. For example if
@code{plus_refl} is reflection of the @code{+} function, then you
will need a reflection of a pair of natural numbers in order to apply
the @code{plus_refl} to its value reflection (which must be such a
pair).

The trouble is, in Opal you cannot directly call the function
@code{reflect} for this. (The call @code{reflect[nat ** nat] ((5,6))}
will simply produce a compiler error.) Instead, you can reflect the
two values @code{5} and @code{6} independently and then use the tuple
construction functions to build a reflection of a tuple which contains
the two value 5 and 6.

To start off, the empty tuple is reflected by @code{<>}:
*/
FUN <>  : value
FUN <>? : value -> bool

/* %
Reflections can be composed using the operator @code{x} to create
reflections of product typed values. The resulting tuple is always
flat, i.e., the reflection product is associative.
*/
FUN x : value ** value -> value

/* %
The functions @code{asTuple} and @code{asSeq} convert between a
sequence of reflections and a tuple reflection of the same
elements. 
*/
FUN asTuple : seq[value] -> value
FUN asSeq : value -> seq[value]



