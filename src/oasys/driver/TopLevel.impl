IMPLEMENTATION TopLevel

IMPORT	Com		COMPLETELY
	ComCompose	COMPLETELY
	ComCheck	COMPLETELY
	ProcessArgs	COMPLETELY
	Char		COMPLETELY
	Nat		COMPLETELY
	NatConv		COMPLETELY
	File		COMPLETELY
	Tcl[void]	COMPLETELY
	Void		COMPLETELY
	Option		COMPLETELY
	ReadLine	COMPLETELY
	Denotation	COMPLETELY
	String		COMPLETELY
	StringConv	COMPLETELY
	FileSystem	COMPLETELY
	FileName	COMPLETELY
	ProcessComInterrupt COMPLETELY
	
IMPORT
	RepoGlobalAccess COMPLETELY
	RepoCom1	COMPLETELY
	RepoEvent	COMPLETELY
	RepoMaintain	COMPLETELY
	RepoFocus	COMPLETELY
	RepoNameConv	COMPLETELY
	
IMPORT
	ComTty		COMPLETELY
	OasysCmdtable	COMPLETELY
	OasysInterface	COMPLETELY
	TclInterface	COMPLETELY
	EchoEvent	COMPLETELY


-- should got to the library
FUN exists? : denotation -> com[bool]
DEF exists?(FileName) ==
    stat(FileName)		; (\\ Ans .
    succeed(okay?(Ans))
    )

-- %$Driver$ ==============================================================

FUN oasysbin : com[void]
DEF oasysbin ==
    write(stdOut, "oasys version 1.1a (ocs version 2.3a), ")	& (\\ _ .
    writeLine(stdOut, "(c) 1989-1997 The OPAL Group, TU-Berlin")& (\\ _ .
    check(\\Msg . "top-level error: " ++ Msg,
	argCount				& (\\Argc.
	IF false -- Argc <= 1
	  THEN write(stdErr,"Syntax: oasys [option]* repoPath\n") &
		exit(1)
	  ELSE -- command line syntax is ok
	       -- ignore the options at first
	       (IF Argc <= 1 THEN succeed("")
		ELSE arg(Argc-1) FI /* last arg. */)
						& (\\RepoPath.
	       register(echoEvent)		& (\\ _ .
	       selectRepo(RepoPath)		& (\\Repo.
	       with(Repo,	
		 initOasys			& (\\ _ .
		 initTcl			& (\\TclInterp.
		 loadStartupFiles(TclInterp)	& (\\ _ .
		 mainLoop(TclInterp)		)))
	       )				& 
	       succeed(nil)			)))
	FI					)
    )))

-- %$Selecting a Repository$ ===============================================

FUN selectRepo : denotation -> com[repo]
DEF selectRepo(RepoPath) ==
     exists?(RepoPath)				& (\\Exists? .
     IF Exists?
       THEN -- file exists
	    write(stdOut,"reading project `" ++ RepoPath ++ "'\n")	
						& (\\ _ .
	    openRepo(RepoPath)			
	    )
       ELSE -- file does not exists or unable to open
	    newRepo(RepoPath)			
      FI					)

-- %$Loading Startup Files$ ===============================================

FUN loadStartupFiles : interpreter -> com[void]
DEF loadStartupFiles(TclInterp) ==
    oasysLibDir						    & (\\ OasysDir .
    (env("OASYSGLOBALRC") | 
	succeed(normPath(OasysDir) ++ "startup.oasys"))	    & (\\ SysRc .
    (env("HOME") | succeed("~/"))			    & (\\ HomeDir .
    (env("OASYSRC") | 
	succeed(normPath(HomeDir)  ++ ".oasysrc"))	    & (\\ UsrRc .
    exists?(SysRc)					    & (\\ HaveSysRc.
    (IF HaveSysRc THEN
	 source(TclInterp, SysRc)
     ELSE succeed(<>) FI)				    & (\\ _ .
    exists?(UsrRc)					    & (\\ HaveUsrRc.
    (IF HaveUsrRc THEN
	 source(TclInterp, UsrRc)
     ELSE succeed(<>) FI)				    & (\\ _ .
    succeed(nil)					    ))))))))
	

-- %$Command Loop$ ========================================================


FUN mainLoop : interpreter -> com[void]
DEF mainLoop(TclInterp) ==
    readLines					; (\\Cmd? .
    (IF okay?(Cmd?) THEN
    	 yield(Cmd?)
     ELSE
     	 writeLine(stdOut, "^D (quit)") &
	 succeed(!("oasys-quit"))
     FI)					& (\\Cmd .
    TclInterp @ Cmd				; (\\AnsResult .
    LET Res == IF AnsResult okay? THEN
		   `(data(AnsResult))
	       ELSE error(AnsResult) FI
    IN
    IF #(Res) > 0 THEN
	IF Res ! #(Res) - 1 |= newline THEN
	    writeLine(stdOut,Res) & (\\ _ .
	    mainLoop(TclInterp)
	    )		
	ELSE
	    write(stdOut,Res)	& (\\ _ .
	    mainLoop(TclInterp)
	    )		
	FI
    ELSE 
	mainLoop(TclInterp)
    FI
    )))

FUN readLines : com[string]
DEF readLines ==
    focus?					& (\\ UName? .
    (IF avail?(UName?) THEN
	 asDeno(symbolic)(cont(UName?))
     ELSE succeed("") FI)			& (\\ Prompt .
    readLine(Prompt ++ ">",completer) & readOtherLines(Prompt)
    ))

FUN readOtherLines: denotation -> denotation -> com[string]
DEF readOtherLines(Prompt)(ReadInput) ==
    IF !(ReadInput) commandComplete?
      THEN succeed(!(ReadInput)) 
      ELSE readLine(Prompt ++ "?") & (\\Line.
	   readOtherLines(Prompt)(ReadInput++Line))
    FI


