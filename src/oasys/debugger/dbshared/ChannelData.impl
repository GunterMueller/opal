IMPLEMENTATION ChannelData

IMPORT  Nat             COMPLETELY
        Fmt             COMPLETELY
        FmtBasicTypes   COMPLETELY
        FmtSeq          COMPLETELY
        FmtOption       COMPLETELY
        FmtArray        COMPLETELY
        FmtMap          COMPLETELY
        Expression      COMPLETELY
        ProcessCtrlConv COMPLETELY

DATA task ==
        register
        sync(           id:             nat)
        eval(           id:             evalId,
                        expr:           expr,
                        fct:            fct)
        internEval(     id:             evalId,
                        expr:           expr)
        exec(           id:             evalId,
                        expr:           expr,
                        fct:            fct) 
        declare(        decls:          seq[declare])
        define(         defins:         seq[define])
        breakPoint(     bp:             breakPoint)
        assocPrintFuns( prints:         seq[assocPrintFun])
        break
        continue
        singleStep(     no:             nat)
        evalStates
        bt
        select(         no:             nat)
        debug
        exit
        iprint(         id:             evalId,
                        tpos:           seq[nat],
                        fct:            fct)
        setRepo(        repo:           repo)

DATA declare ==
        function(
                id:             objectId,
                para:           seq[objectId],  -- formal parameters only
                struct:         denotation,
                ident:          nat
        )
        sort(   id:             objectId,
                para:           seq[objectId]
        )
        formal( id:             objectId
        )


DATA define ==
        interpreted(
                id:     objectId,
                rank:   nat,
                dim:    nat,
                expr:   expr
        )
        coded(
                id:             objectId,
                dims:           array[nat]
        )

DATA breakPoint ==
        bp(             id:             objectId)
        guardedBp(      id:             objectId,
                        guard:          expr,
                        rank:           nat,
                        dim:            nat)

DATA assocPrintFun ==
        assocPrintFun(
                sortInfo:       sortInfo, -- basic name only
                printId:        objectId,
                paraSorts:      option[seq[sortInfo]]
                                        -- sorts only (may be formal)
        )

DATA answer ==
        ready
        sync(           id:             nat)
        error(          msg:            denotation)
        register(       pid:            process)
        result(         id:             evalId,
                        result:         denotation)
        iResult(        id:             evalId,
                        result:         obj)
        fail(           id:             evalId,
                        error:          denotation)
        broken(         id:             evalId)
        aborted(        id:             evalId,
                        reason:         denotation)
        evalStates(     evalStates:     map[evalId,<,evalState])
        bt(             stack:          seq[reducedName])
        selection(      selection:      selection)
        iprint(         result:         denotation)

DATA evalState == ready broken aborted unknown


DATA selection == 
        selection(      name:           reducedName,
                        pos:            tpos,
                        bindOffsets:    seq[seq[bindOffset]])

DATA reducedName ==
        name(           name:           name,
                        kind:           kind)
        toplevel
        escaped

FUN fmtFmt : fmt -> fmt
DEF fmtFmt(F) == F

FUN fmtProcess : process -> fmt
DEF fmtProcess(P) == lit(`(P))

-- % formats generated by ordinatrice
FUN fmtAnswer : answer -> fmt
DEF fmtAnswer(ready) == ;(;(beg(2),lit("ready")),end)
DEF fmtAnswer(sync(v0)) == ;(;(beg(2),lit("sync")),;(;(lit("("),;(fmtNat(v0),lit(")"))),end))
DEF fmtAnswer(error(v0)) == ;(;(beg(2),lit("error")),;(;(lit("("),;(fmtDenotation(v0),lit(")"))),end))
DEF fmtAnswer(register(v0)) == ;(;(beg(2),lit("register")),;(;(lit("("),;(fmtProcess(v0),lit(")"))),end))
DEF fmtAnswer(result(v0,v1)) == ;(;(beg(2),lit("result")),;(;(lit("("),;(;(fmtEvalId(v0),;(lit(", "),fmtDenotation(v1))),lit(")"))),end))
DEF fmtAnswer(fail(v0,v1)) == ;(;(beg(2),lit("fail")),;(;(lit("("),;(;(fmtEvalId(v0),;(lit(", "),fmtDenotation(v1))),lit(")"))),end))
DEF fmtAnswer(broken(v0)) == ;(;(beg(2),lit("broken")),;(;(lit("("),;(fmtEvalId(v0),lit(")"))),end))
DEF fmtAnswer(aborted(v0,v1)) == ;(;(beg(2),lit("aborted")),;(;(lit("("),;(;(fmtEvalId(v0),;(lit(", "),fmtDenotation(v1))),lit(")"))),end))
DEF fmtAnswer(evalStates(v0)) == ;(;(beg(2),lit("evalStates")),;(;(lit("("),;(fmtMap(fmtEvalId,fmtEvalState)(v0),lit(")"))),end))
DEF fmtAnswer(bt(v0)) == ;(;(beg(2),lit("bt")),;(;(lit("("),;(fmtSeq(fmtReducedName)(v0),lit(")"))),end))
DEF fmtAnswer(selection(v0)) == ;(;(beg(2),lit("selection")),;(;(lit("("),;(fmtSelection(v0),lit(")"))),end))
-- folgendes per Hand ergänzt
DEF fmtAnswer(iprint(v0)) == beg(2); lit("iprint("); lit(v0); lit(")"); end
DEF fmtAnswer(iResult(v0, _)) == beg(2); lit("iresult("); fmtEvalId(v0); lit(",<some>)"); end
FUN fmtSelection : selection -> fmt
DEF fmtSelection(selection(v0,v1,v2)) == ;(;(beg(2),lit("selection")),;(;(lit("("),;(;(;(fmtReducedName(v0),;(lit(", "),fmtTpos(v1))),;(lit(", "),fmtSeq(fmtSeq(fmtBindOffset))(v2))),lit(")"))),end))
FUN fmtReducedName : reducedName -> fmt
DEF fmtReducedName(name(v0,v1)) == ;(;(beg(2),lit("name")),;(;(lit("("),;(;(fmtName(v0),;(lit(", "),fmtKind(v1))),lit(")"))),end))
DEF fmtReducedName(toplevel) == ;(;(beg(2),lit("toplevel")),end)
DEF fmtReducedName(escaped) == ;(;(beg(2),lit("escaped")),end)
FUN fmtEvalState : evalState -> fmt
DEF fmtEvalState(ready) == ;(;(beg(2),lit("ready")),end)
DEF fmtEvalState(broken) == ;(;(beg(2),lit("broken")),end)
DEF fmtEvalState(aborted) == ;(;(beg(2),lit("aborted")),end)
DEF fmtEvalState(unknown) == ;(;(beg(2),lit("unknown")),end)
FUN fmtBreakPoint : breakPoint -> fmt
DEF fmtBreakPoint(bp(v0)) == ;(;(beg(2),lit("bp")),;(;(lit("("),;(fmtObjectId(v0),lit(")"))),end))
DEF fmtBreakPoint(guardedBp(v0,v1,v2,v3)) == ;(;(beg(2),lit("guardedBp")),;(;(lit("("),;(;(;(;(fmtObjectId(v0),;(lit(", "),fmtExpr(v1))),;(lit(", "),fmtNat(v2))),;(lit(", "),fmtNat(v3))),lit(")"))),end))
FUN fmtAssocPrintFun : assocPrintFun -> fmt
DEF fmtAssocPrintFun(assocPrintFun(v0,v1,v2)) == ;(;(beg(2),lit("assocPrintFun")),;(;(lit("("),;(;(;(fmtSortInfo(v0),;(lit(", "),fmtObjectId(v1))),;(lit(", "),fmtOption(fmtSeq(fmtSortInfo))(v2))),lit(")"))),end))
FUN fmtDeclare : declare -> fmt
DEF fmtDeclare(function(v0,v1,v2,v3)) == ;(;(beg(2),lit("function")),;(;(lit("("),;(;(;(;(fmtObjectId(v0),;(lit(", "),fmtSeq(fmtObjectId)(v1))),;(lit(", "),fmtDenotation(v2))),;(lit(", "),fmtNat(v3))),lit(")"))),end))
DEF fmtDeclare(sort(v0,v1)) == ;(;(beg(2),lit("sort")),;(;(lit("("),;(;(fmtObjectId(v0),;(lit(", "),fmtSeq(fmtObjectId)(v1))),lit(")"))),end))
DEF fmtDeclare(formal(v0)) == ;(;(beg(2),lit("formal")),;(;(lit("("),;(fmtObjectId(v0),lit(")"))),end))
FUN fmtDefine : define -> fmt
DEF fmtDefine(interpreted(v0,v1,v2,v3)) == ;(;(beg(2),lit("interpreted")),;(;(lit("("),;(;(;(;(fmtObjectId(v0),;(lit(", "),fmtNat(v1))),;(lit(", "),fmtNat(v2))),;(lit(", "),fmtExpr(v3))),lit(")"))),end))
DEF fmtDefine(coded(v0,v1)) == ;(;(beg(2),lit("coded")),;(;(lit("("),;(;(fmtObjectId(v0),;(lit(", "),fmtArray(fmtNat)(v1))),lit(")"))),end))
FUN fmtTask : task -> fmt
DEF fmtTask(register) == ;(;(beg(2),lit("register")),end)
DEF fmtTask(sync(v0)) == ;(;(beg(2),lit("sync")),;(;(lit("("),;(fmtNat(v0),lit(")"))),end))
DEF fmtTask(eval(v0,v1,v2)) == ;(;(beg(2),lit("eval")),;(;(lit("("),;(;(;(fmtEvalId(v0),;(lit(", "),fmtExpr(v1))),;(lit(", "),fmtFct(v2))),lit(")"))),end))
DEF fmtTask(exec(v0,v1,v2)) == ;(;(beg(2),lit("exec")),;(;(lit("("),;(;(;(fmtEvalId(v0),;(lit(", "),fmtExpr(v1))),;(lit(", "),fmtFct(v2))),lit(")"))),end))
DEF fmtTask(declare(v0)) == ;(;(beg(2),lit("declare")),;(;(lit("("),;(fmtSeq(fmtDeclare)(v0),lit(")"))),end))
DEF fmtTask(define(v0)) == ;(;(beg(2),lit("define")),;(;(lit("("),;(fmtSeq(fmtDefine)(v0),lit(")"))),end))
DEF fmtTask(breakPoint(v0)) == ;(;(beg(2),lit("breakPoint")),;(;(lit("("),;(fmtBreakPoint(v0),lit(")"))),end))
DEF fmtTask(assocPrintFuns(v0)) == ;(;(beg(2),lit("assocPrintFuns")),;(;(lit("("),;(fmtSeq(fmtAssocPrintFun)(v0),lit(")"))),end))
DEF fmtTask(break) == ;(;(beg(2),lit("break")),end)
DEF fmtTask(continue) == ;(;(beg(2),lit("continue")),end)
DEF fmtTask(singleStep(v0)) == ;(;(beg(2),lit("singleStep")),;(;(lit("("),;(fmtNat(v0),lit(")"))),end))
DEF fmtTask(evalStates) == ;(;(beg(2),lit("evalStates")),end)
DEF fmtTask(bt) == ;(;(beg(2),lit("bt")),end)
DEF fmtTask(select(v0)) == ;(;(beg(2),lit("select")),;(;(lit("("),;(fmtNat(v0),lit(")"))),end))
DEF fmtTask(debug) == ;(;(beg(2),lit("debug")),end)
DEF fmtTask(exit) == ;(;(beg(2),lit("exit")),end)
-- folgendes per Hand ergänzt
DEF fmtTask(iprint(v0,v1,v2)) ==
  beg(2); lit("iprint("); fmtEvalId(v0); lit(", "); fmtSeq(fmtNat)(v1);
  lit(", "); fmtFct(v2); lit(")"); end
DEF fmtTask(internEval(v0,v1)) == ;(;(beg(2),lit("eval")),;(;(lit("("),;(;(fmtEvalId(v0),;(lit(", "),fmtExpr(v1))),lit(")"))),end))
DEF fmtTask(setRepo(v0)) == beg(2); lit("setRepo(...)"); end