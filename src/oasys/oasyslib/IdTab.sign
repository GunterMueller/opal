/* %
This structure provides tables indexed by identifiers (@ref{Id Overview}).
A table is similar to a finite mapping with the following restrictions:
(1) tables can only be constructed by special functions, and not by
the usual @code{def} function on mappings (2) once an entry is defined in 
a table, it cannot be undefined.  These two restrictions allow a very efficient 
implementation based on monolitihic arrays.

For arbitrary finite mappings on identifiers,  see @ref{IdMap Overview}.
*/

SIGNATURE IdTab [codom:SORT]

SORT codom

IMPORT	Id		ONLY id:SORT < : id ** id -> bool
	IdSet		ONLY idset:SORT
	IdMap[codom]	ONLY idmap:SORT
	Seq[id]		ONLY seq:SORT
	Seq[codom]	ONLY seq:SORT
	Seq[pair]	ONLY seq:SORT
	Pair[id,codom]	ONLY pair:SORT
	Option[codom]	ONLY option:SORT
	Option[pair]	ONLY option:SORT
	Nat		ONLY nat:SORT
	Fmt		ONLY fmt:SORT


SORT idtab

FUN {}	 : idtab
FUN {}?	 : idtab	-> bool
	
/* %
Tables are constructed	by the functions below:
*/

FUN new		: (id -> codom) ** idtab -> id ** idtab
FUN multiNew	: nat ** (seq[id] -> seq[codom]) ** idtab -> seq[id] ** idtab
FUN free	: idtab	-> id

FUN asTab	: seq[pair[id,codom]] ** codom		-> idtab

FUN enrich	: idtab ** idmap ** codom		-> idtab

FUN join	: idtab ** idtab ** (codom ** (id -> id) -> codom) 
					-> idtab ** (id -> id)

/* %
@code{new(Fun, Tab)} generates a new identifier and calls
@code{Fun(Id)} to create the initial table entry. The function
@code{multiNew} is used to simultaneously create a set of entries
which may refer to each other.	The function @code{free} returns the 
next identifier which would be generated by @code{new} or @code{multiNew}.

@code{asTab(Seqi, Default)} converts a sequence of identifier-codom
pairs into a table. @code{Default} is inserted at `wholes'.

The function @code{enrich(T, M, Default)} enriches a table by a 
mapping. Entries in @code{M} with identifiers in the domain of @code{T}
overwrite entries in the result, for other entries the result table
is accordingly extended, inserting @code{Default} at wholes. It holds
that @code{enrich(T, M, Default) === asTab(asSeq(T) ++ asSeq(M), Default)}.

The function @code{join(T1, T2, Map)} joins the second table to the 
first one, mapping all identifiers from @code{T2} to new ones which are
disjunct from those in @code{T1}.  For each entry of @code{T2} the function  
@code{Map(Codom,Renaming)} is called, where @code{Renaming} is a function
constructed by @code{enrich} which maps the identifiers from @code{T2} to 
their new values. The renaming function is also returned 
by @code{enrich} such that it can be applied to other structures containing 
identifiers from @code{T2}. The renaming function is total and behaves
like identity if it is applied to an identifier not in the domain of 
@code{T2}.
*/


/* %
@sp 2
The remaining functions mostly follow the conventions for finit mappings
in the OPAL library. Note, however, that @code{def} is not defined
if the identifier is not in the tables domain.
*/

FUN def		: id ** codom ** idtab			-> idtab
FUN upd		: id ** (codom -> codom) ** idtab	-> idtab

FUN !		: idtab ** id				-> codom
FUN !?		: idtab ** id				-> option[codom]
FUN def?	: id ** idtab				-> bool

FUN exists?	: (codom -> bool) ** idtab		-> bool
FUN forall?	: (codom -> bool) ** idtab		-> bool
FUN find?	: (codom -> bool) ** idtab		-> option[codom]
FUN find?	: (id ** codom -> bool) ** idtab	
						-> option[pair[id,codom]]

FUN dom		: idtab					-> idset
FUN codom	: idtab					-> seq[codom]
FUN codomST	: idtab ** (codom -> bool)		-> seq[codom]

FUN asSeq	: idtab					-> seq[pair[id,codom]]


FUN fmtIdtab	: (codom -> fmt) -> idtab		-> fmt

