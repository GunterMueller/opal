
IMPLEMENTATION ArgSpec[state]

/* subject:  	argument specification, checking and completion
   version:  	1.0 (proposed)
   created:   	wg 5-94
   modified:    wg@cs.tu-berlin.de Tue Sep 12 18:41:10 1995
*/



IMPORT	Nat				ONLY nat <
	Denotation			ONLY < ++ =
	String				COMPLETELY
	StringFilter			COMPLETELY
	StringConv			ONLY `
	Option				COMPLETELY
	Seq				ONLY seq :: <> ::? front last %
	SeqMap				ONLY *
	SeqFold				ONLY /
	Seq[denotation]			ONLY seq
	Map[nat,<,seq[denotation]]  	ONLY {} def !?
	Set  				ONLY set {} % + in
	SetConv				ONLY asSet asSeq
	Com				ONLY com yield ans okay fail
	ComCompose			ONLY &


-- =========================================================================

FUN scanArgs : denotation ** (char -> bool) -> seq[denotation]
DEF scanArgs(Line, Sep) == scanArgs(!(Line), Sep)

FUN scanArgs : string ** (char -> bool) -> seq[denotation]
DEF scanArgs(Line, Sep) == 
    LET Line1 == drop(Sep, Line)
	(Word, Line2) == split(\\Ch. ~(Sep(Ch)), Line1)
    IN
    IF <>?(Word) THEN <>
		 ELSE `(Word) :: scanArgs(Line2, Sep) FI



-- =========================================================================

DATA argSpec ==
    -- primitives
    lit(
	token		: nat,
			-- token used to identify argument
	value		: denotation
			-- literal value expected
    )
    var(
	token		: nat,
			-- token used to identify argument
	descriptor	: denotation,
			-- name used in description
	completer	: state ** denotation -> com[seq[denotation]]
			-- completer command. 

    )

    -- compositions
    o (left: argSpec, right: argSpec)	-- sequential composition
    | (left: argSpec, right: argSpec) 	-- alternate composition
    ? (spec	: argSpec)		-- optional
    * (spec	: argSpec)		-- repetition 0..n
	

-- --------------------------------------------------------------------------

FUN var: nat ** denotation -> argSpec
    -- shortcut for variable without completer

DEF var(Tok, Den) == var(Tok, Den, \\ _, _ . yield(fail("")))


-- =========================================================================

FUN checkArgs : seq[string]     ** argSpec -> com[map[nat,<,seq[denotation]]]
    checkArgs : seq[denotation] ** argSpec -> com[map[nat,<,seq[denotation]]]

    /*
	checks the sequence of arguments according to argument specification
    	and returns a mapping of argument labels to values. 
    */

DEF checkArgs(Args, Spec) == 
    LET (Map, RtArgs) == check(Args, Spec, {})
    IN
    IF nil?(Map) or ::?(RtArgs) THEN
	yield(fail("syntax error; should be:\n  " ++ usage(Spec)))
    ELSE
	yield(okay(cont(Map)))
    FI

DEF checkArgs(Args, Spec) ==
    checkArgs(` * Args, Spec)

-- --------------------------------------------------------------------------

FUN check : seq[denotation] ** argSpec ** map -> option[map] ** seq[denotation]

DEF check(Args AS Arg :: RtArgs, lit(Tok, Val), Map) ==
    IF Val = Arg THEN
	(avail(push(Tok, Arg, Map)), RtArgs)
    ELSE (nil, Args) FI

DEF check(<>, lit(_, _), _) == (nil,<>)

DEF check(Arg :: RtArgs, var(Tok, _, _), Map) ==
    (avail(push(Tok, Arg, Map)), RtArgs)

DEF check(<>, var(_, _, _), _) == (nil,<>)

DEF check(Args, Left o Right, Map) ==
    LET (Map1, RtArgs) == check(Args, Left, Map)
    IN
    IF avail?(Map1) THEN
	check(RtArgs, Right, cont(Map1))
    ELSE (nil, Args) FI

DEF check(Args, Left | Right, Map) ==
    LET (Map1, RtArgs) == check(Args, Left, Map)
    IN
    IF avail?(Map1) THEN
	(Map1, RtArgs)
    ELSE
	check(Args, Right, Map)
    FI

DEF check(Args, *(Spec), Map) ==
    LET (Map1, RtArgs) == check(Args, Spec, Map)
    IN
    IF avail?(Map1) THEN
	check(RtArgs, *(Spec), cont(Map1))
    ELSE
	-- stop
	(avail(Map), Args)
    FI

DEF check(Args, ?(Spec), Map) ==
    LET (Map1, RtArgs) == check(Args, Spec, Map)
    IN
    IF avail?(Map1) THEN
	(Map1, RtArgs)
    ELSE
	(avail(Map), Args)
    FI


-- --------------------------------------------------------------------------

FUN push : nat ** denotation ** map[nat,<,seq[denotation]]
			     -> map[nat,<,seq[denotation]]
DEF push(Tok, Val, Map) ==
    LET Old? == Map !? Tok
    IN
    IF avail?(Old?) THEN def(Tok, Val :: cont(Old?), Map)
		    ELSE def(Tok, %(Val), Map) FI

-- ===========================================================================

FUN completeArgs : state ** seq[string]     ** seq[argSpec] -> com[seq[denotation]]
    completeArgs : state ** seq[denotation] ** seq[argSpec] -> com[seq[denotation]]

    /* 
	attempt to complete the last component of (partial) sequence
	of arguments. 

    */

DEF completeArgs(S, Args, Specs) == 
    IF ::?(Specs) THEN
        LET (Ctx, _) == findctx(front(Args), | / Specs)
        IN
        IF stop?(Ctx) THEN
	    completions(S, spec(Ctx), last(Args))	& (\\Cs.
	    yield(okay(asSeq(Cs)))
	    )
        ELSE
	    yield(okay(<>))
        FI
    ELSE
	yield(okay(<>))
    FI

DEF completeArgs(S, Args, Specs) == completeArgs(S, ` * Args, Specs)

-- --------------------------------------------------------------------------

DATA ctx == fail done stop(spec: argSpec)

FUN findctx : seq[denotation] ** argSpec -> ctx ** seq[denotation]


DEF findctx(<>, Spec) == (stop(Spec), <>)

DEF findctx(Args AS Arg :: RtArgs, lit(Tok, Val)) ==
    IF Val = Arg THEN
	(done, RtArgs)
    ELSE (fail, Args) FI

DEF findctx(Arg :: RtArgs, var(Tok, _, _)) ==
    (done, RtArgs)

DEF findctx(Args AS _ :: _, Left o Right) ==
    LET (Res, RtArgs) == findctx(Args, Left)
    IN
    IF done?(Res) THEN
	findctx(RtArgs, Right)
    IF stop?(Res) THEN
	IF epsilon?(Left) THEN
	    -- combine with possibilities in Right
	    LET (RRes, RRtArgs) == findctx(Args, Right)
	    IN
	    IF stop?(RRes) THEN
		(stop(spec(Res) o spec(RRes)), RtArgs)
	    ELSE
		(Res, RtArgs)
	    FI
	ELSE
	    (Res, RtArgs)
	FI
    ELSE
	(Res, Args)
    FI

DEF findctx(Args AS _ :: _, Left | Right) ==
    LET (Res, RtArgs) == findctx(Args, Left)
    IN
    IF done?(Res) THEN
	(Res, RtArgs)
    IF stop?(Res) THEN
	-- combine with possibilities in Right
	LET (RRes, RRtArgs) == findctx(Args, Right)
	IN
	IF stop?(RRes) THEN
	    (stop(spec(Res) | spec(RRes)), RRtArgs)
	ELSE
	    (Res, RtArgs)
	FI
    ELSE
	findctx(Args, Right)
    FI

DEF findctx(Args AS _ :: _, *(Spec)) ==
    LET (Res, RtArgs) == findctx(Args, Spec)
    IN
    IF done?(Res) THEN
	findctx(RtArgs, *(Spec))
    IF stop?(Res) THEN
	(Res, RtArgs)
    ELSE
	(done, Args)
    FI

DEF findctx(Args AS _ :: _, ?(Spec)) ==
    LET (Res, RtArgs) == findctx(Args, Spec)
    IN
    IF done?(Res) THEN
	(Res, RtArgs)
    IF stop?(Res) THEN
	(Res, RtArgs)
    ELSE
	(done, Args)
    FI

-- -------------------------------------------------------------------------

FUN completions : state ** argSpec ** denotation -> com[set[denotation,<]]

DEF completions(S, lit(_,Val),Cand) == 
    IF Cand <| Val THEN yield(okay(%(Val)))
    		   ELSE yield(okay({})) FI

DEF completions(S, var(_,_,Completer),Cand) == 
    Completer(S, Cand)	& (\\Seq. yield(okay(asSet(Seq))))

DEF completions(S, Left o Right, Cand ) ==
    IF epsilon?(Left) THEN
	completions(S, Left, Cand) + completions(S, Right, Cand) 
    ELSE
	completions(S, Left, Cand) 
    FI

DEF completions(S, Left | Right, Cand ) ==
    completions(S, Left, Cand) + completions(S, Right, Cand) 

DEF completions(S, *(Spec), Cand ) ==
    completions(S, Spec, Cand) 

DEF completions(S, ?(Spec), Cand ) ==
    completions(S, Spec, Cand) 


FUN + : com[set[denotation,<]] ** com[set[denotation,<]]
			       -> com[set[denotation,<]]
DEF Left + Right ==
    Left	& (\\CLeft.
    Right	& (\\CRight.
    yield(okay(CLeft + CRight))
    ))


-- -------------------------------------------------------------------------

FUN epsilon? : argSpec -> bool
DEF epsilon?(Left | Right) ==
    epsilon?(Left) or epsilon?(Right)

DEF epsilon?(Left o Right) ==
    epsilon?(Left) and epsilon?(Right)

DEF epsilon?(?(Left)) == true
DEF epsilon?(*(Left)) == true

DEF epsilon?(_) == false


-- =========================================================================

FUN usage : argSpec -> denotation

DEF usage(lit(_, Val)) == Val

DEF usage(var(_, Descr, _)) == Descr

DEF usage(Spec1 o Spec2) == protectAlt(Spec1) ++ " " ++ protectAlt(Spec2)

DEF usage(Spec1 | Spec2) == usage(Spec1) ++ " | " ++ usage(Spec2)

DEF usage(*(Spec)) == "{ " ++ usage(Spec) ++ " }"

DEF usage(?(Spec)) == "[ " ++ usage(Spec) ++ " ]"

FUN protectAlt : argSpec -> denotation
DEF protectAlt(Spec AS _ | _) == "( " ++ usage(Spec) ++ " )"
DEF protectAlt(Spec) == usage(Spec)



