IMPLEMENTATION Format

IMPORT  Char		ONLY blank newline |=
	Compose		ONLY o
	Nat             COMPLETELY
        String          COMPLETELY
        StringFilter	ONLY split
        Seq 		COMPLETELY
	SeqMap		ONLY *
	SeqReduce	ONLY /
        ABORT 		COMPLETELY

DATA fmt == fmt(fun:state -> state)

DATA state == pretty(rightMargin : nat,
		     currLine : string, -- last line
		     addSpaces : nat,
		     prevLines : seq[string],
		     state: state)
	      nil
	      
DEF fmt(Fun1) ; fmt(Fun2) == fmt(Fun2 o Fun1)
DEF none == fmt(\\x.x)

FUN minBreakFill minSpace: nat
DEF minBreakFill == 4
DEF minSpace  == 8

FUN begFun : nat -> state -> state
DEF begFun(Ind)(State AS pretty(Margin, Line, AddSpace, _, PrevState)) == 
        LET LineLen == #(Line) + AddSpace
	    CurrInd == IF Ind = 0 THEN 0 
		       IF LineLen = 0 THEN Ind
		      OTHERWISE
		      IF LineLen < minBreakFill ANDIF Ind < minBreakFill THEN
			((LineLen / Ind) * Ind) + (IF 0?(LineLen % Ind) THEN 0
						 ELSE 1 FI)
		      ELSE Ind
		      FI
	    ActInd == IF Margin > CurrInd + minSpace THEN CurrInd ELSE 0 FI
        IN 
	        pretty(Margin - ActInd, <>, 0, <>, State) 


FUN endFun : state -> state
DEF endFun(pretty(Margin, Line, AddSpace,
                    PrevLines, 
                    pretty(OldMargin, 
                           OldLine, OldAddSpace, 
                           OldPrevLines, OldSave))) ==
    LET Ind == OldMargin - Margin
	OldLineLen == #(OldLine) + OldAddSpace
    IN
	IF <>?(PrevLines) THEN -- block is just a single line
		IF <>?(Line) THEN
			pretty(OldMargin, OldLine, AddSpace + OldAddSpace,
				OldPrevLines, OldSave)
		ELSE IF OldLineLen + #(Line) <= OldMargin 
			ORIF OldLineLen < minBreakFill
		     THEN
			-- fit on a single line
		        pretty(OldMargin, OldLine ++ space(OldAddSpace) ++ Line,
				 AddSpace, OldPrevLines, OldSave)
		     ELSE -- break line
			pretty(OldMargin, indent(Ind)(Line), AddSpace,
				OldLine :: OldPrevLines, OldSave)
		     FI
		FI
	IF ::?(PrevLines) THEN -- real block with line breaks
		LET (NewLine, NewSpace) == 
			IF <>?(Line) THEN
				(Line, AddSpace + Ind) 
			ELSE (indent(Ind)(Line), AddSpace) FI
		    BegLine == last(PrevLines)
		IN
		IF OldLineLen <= Ind ORIF OldLineLen < minBreakFill THEN 
			LET Spaces == IF Ind > OldLineLen THEN Ind - OldLineLen
					ELSE 0 FI
			IN  
			-- melt lines 
			pretty(OldMargin, NewLine, NewSpace,
				(indent(Ind) * front(PrevLines)) ++
				(OldLine ++ space(AddSpace + Spaces) ++ 
				last(PrevLines)) :: OldPrevLines, OldSave)
		ELSE
		      pretty(OldMargin, NewLine, NewSpace,
				 (indent(Ind) * PrevLines) ++ 
				 OldLine :: OldPrevLines, OldSave)
		FI
	FI

FUN litFun : string -> state -> state
DEF litFun(Str)(State AS pretty(Margin, Line, AddSpace, PrevLines, PrevState)) ==
	LET (NextLine, Rest) == split((_ |= newline), Str) 
	    LineLen == #(Line) + AddSpace
	    CurrState == 
	  IF <>?(NextLine) THEN State
	  ELSE pretty(Margin, NewLine, 0, NewPrevLines, PrevState) 
		WHERE
	    (NewLine, NewPrevLines) == 
		IF #(NextLine) <= Margin THEN
			IF LineLen + #(NextLine) <= Margin
				ORIF LineLen < minBreakFill THEN
				(Line ++ space(AddSpace) ++ NextLine, PrevLines)
			ELSE (NextLine, Line :: PrevLines) FI
		ELSE LET SplitLines == split(Margin + minBreakFill, 
					Line ++ space(AddSpace) ++ NextLine)
		     IN (<>, revert(SplitLines) ++ PrevLines)
		FI
	  FI
	IN
		IF <>?(Rest) THEN CurrState
		ELSE litFun(rt(Rest))(brkFun(CurrState))
		FI

FUN split : nat ** string -> seq[string]
DEF split(N, Str) == 
	IF #(Str) < N THEN %(Str)
	ELSE LET (Ft, Rt) == split(pred(N), Str) IN
		Ft :: split(N, Rt) 
	FI

FUN brkFun : state -> state
DEF brkFun(pretty(Margin, Line, AddSpace, PrevLines, PrevState)) ==
	pretty(Margin, <>, 0, Line :: PrevLines, PrevState) 

FUN spcFun : nat -> state -> state
DEF spcFun(N)(pretty(Margin, Line, AddSpace, PrevLines, PrevState)) ==
	pretty(Margin, Line, AddSpace + N, PrevLines, PrevState) 

DEF lit(Str) == fmt(litFun(Str))
DEF lit(Den) == fmt(litFun(Den!))
DEF beg(Ind) == fmt(begFun(Ind))
DEF end == fmt(endFun)
DEF block(N, Fmt) == beg(N) ; Fmt ; end
DEF spc(N) == fmt(spcFun(N))
DEF brk == fmt(brkFun)

DEF pretty(Left, Right, fmt(Fun)) == 
LET Erg == Fun(pretty((Right-2) - Left, <>, 0, <>, nil))
    Lines == IF <>?(currLine(Erg)) THEN prevLines(Erg)
		ELSE currLine(Erg) :: prevLines(Erg) FI
    IndLines == IF Left > 1 THEN indent(pred(Left)) * Lines 
			ELSE Lines FI
IN revert(IndLines)
    
DEF pretty(Fmt) == /(\\S,Rt. S ++ !("\n") ++ Rt, <>)(pretty(1, "70"!, Fmt))

FUN space : nat -> string
DEF space(N) == IF N > 0 THEN init(N,blank) ELSE <> FI

FUN indent : nat -> string -> string
DEF indent(Ind)(Str) == IF Ind > 0 THEN space(Ind) ++ Str
                                   ELSE Str FI

