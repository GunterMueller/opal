IMPLEMENTATION Dbm

-- Simple Data Base Manager (based on GNU gdbm)
-- $Header: /home/florenz/opal/home_uebb_CVS/CVS/ocs/src/tivi2/libext/Dbm.impl,v 1.1 1998-07-30 11:57:58 kd Exp $


IMPORT	Nat		COMPLETELY
	Com		COMPLETELY
	ComCompose	COMPLETELY
	Denotation	ONLY ++ =
	Seq		COMPLETELY
	ComSeqReduce	ONLY /&
	Dyn		COMPLETELY


DATA db ==
    db(name:	denotation,		-- file name
       dbf:     dbf,		        -- data base file
       access:	access,			-- current access
       mode:	mode,
       cache:	nat
    )

DATA dbf == primitive		-- handcoded; simulate storage class


DATA mode == sync async

FUN mode2nat : mode -> nat
DEF mode2nat(sync) == syncMode
DEF mode2nat(async) == asyncMode

FUN access2nat : access -> nat
DEF access2nat(reader) == readerAccess
DEF access2nat(writer) == writerAccess
DEF access2nat(tryReader) == tryReaderAccess
DEF access2nat(tryWriter) == tryWriterAccess

FUN syncMode asyncMode 
    readerAccess writerAccess tryReaderAccess tryWriterAccess: nat
DEF syncMode == 0
DEF asyncMode == 1
DEF readerAccess == 0
DEF writerAccess == 1
DEF tryReaderAccess == 2
DEF tryWriterAccess == 3

FUN normAcc : access -> access
DEF normAcc(tryReader) == reader
DEF normAcc(tryWriter) == writer
DEF normAcc(Acc) == Acc

DEF create(Name) == create(Name,sync,0)

DEF create(Name,Mode,Cache) == 
    call(Create(Name,mode2nat(Mode),Cache)) & (\\Dbf.
    yield(okay(db(Name, Dbf, writer, Mode, Cache)))
    )

    FUN Create : denotation ** nat ** nat -> void -> ans[dbf]


DEF open(Name,Msg,Acc) == open(Name,Msg,Acc,sync,0)
DEF open(Name,Msg,Acc,Mode,Cache) ==
    call(Open(Name,Msg,access2nat(Acc),mode2nat(Mode),Cache)) & (\\Dbf.
    yield(okay(db(Name, Dbf, normAcc(Acc), Mode, Cache)))
    )

    FUN Open : denotation ** denotation ** nat ** nat ** nat 
				-> void -> ans[dbf]
    

DEF reopen(Db, Msg, NewAcc) ==
    IF access2nat(access(Db)) = access2nat(normAcc(NewAcc)) THEN
	-- access already acquired
	yield(okay(Db))
    ELSE
	call(Close(dbf(Db)))			& (\\ _ .
	call(Open(name(Db), Msg, 
		  access2nat(NewAcc),
		  mode2nat(mode(Db)),
		  cache(Db)))			& (\\Dbf.
	yield(okay(db(name(Db), Dbf, normAcc(NewAcc), 
		      mode(Db), cache(Db))))
	))
    FI


DEF cantBeReader?(Ans) == 
    IF fail?(Ans) THEN error(Ans) = cantBeReader
		  ELSE false FI

	
DEF cantBeWriter?(Ans) == 
    IF fail?(Ans) THEN error(Ans) = cantBeWriter
		  ELSE false FI

    FUN cantBeReader cantBeWriter : denotation

	

DEF close(Db) == call(Close(dbf(Db)))

    FUN Close : dbf -> void -> ans[void]


DEF (Db, Key) := Data == 
    call(Update(dbf(Db), Key, Data))

    FUN Update : dbf ** denotation ** dyn -> void -> ans[void]

DEF Db ! Key == 
    call(Select(dbf(Db),Key))

    FUN Select : dbf ** denotation -> void -> ans[dyn]


DEF Key def? Db == 
    call(Exists(dbf(Db), Key))

    FUN Exists : dbf ** denotation -> void -> ans[bool]


DEF delete(Db, Key) == 
    call(Delete(dbf(Db), Key))

    FUN Delete : dbf ** denotation -> void -> ans[void]


DEF dom(Db) == 
    call(Dom(dbf(Db)))

    FUN Dom : dbf -> void -> ans[seq[denotation]]


DEF reorganize(Db) == call(Reorganize(dbf(Db)))

    FUN Reorganize : dbf -> void -> ans[void]


DEF sync(Db) == call(Sync(dbf(Db)))

    FUN Sync : dbf -> void -> ans[void]

