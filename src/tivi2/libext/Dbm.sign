SIGNATURE Dbm

-- Simple Data Base Manager (based on GNU gdbm)
-- Version 1.1



IMPORT	Nat		ONLY nat
	Void		ONLY void
	Seq[denotation]	ONLY seq
	Com[void]	ONLY com
	Com[db]		ONLY com ans
	Com[seq[denotation]]	ONLY com
	Com[bool]	ONLY com
	Com[dyn]	ONLY com

IMPORT	Dyn		ONLY dyn


SORT db		-- the sort of data bases


IMPORT	DbmAccess ONLY access reader reader? 
			      tryReader tryReader?
			      writer writer?
			      tryWriter tryWriter?
    -- kind of access to data base. N readers or 1 writer are
    -- allowed at the same time, never both.

TYPE mode == sync async
    -- in sync mode every written data is immediatly flushed.
    -- in async (or fast) mode it is flushed with explicite calls to sync 
    -- or on close.


FUN create	: denotation 			-> com[db]
    create	: denotation ** mode ** nat	-> com[db]
    -- create(Name, ...) creates new dyn base with writer access.
    -- 2nd form allows to configure, with 3th argument beeing the
    -- bucket cache size (see gdbm(3)). using 0 selects the gdbm default.

FUN open	: denotation ** denotation ** access		-> com[db]
    open	: denotation ** denotation ** access ** mode ** nat -> com[db]
    -- open(Name, Msg, ...) opens an existing data base either
    -- as reader or as writer. 
    -- if access is not one of the "try" variants, and if access
    -- is not immediatly granted, Msg, if not empty, is printed
    -- to stdErr and the process waits until access is granted.

FUN reopen	: db ** denotation ** access			-> com[db]
    -- reopen(Db, Msg, Access) reopens data base with new access.
    -- note that on failure, the old Db is not longer
    -- open, and that during a reopen other processes may
    -- have acquired write access to the data base and changed
    -- its contents.


FUN cantBeReader? : ans[db]	-> bool
    cantBeWriter? : ans[db]	-> bool
    -- test for failure because of ungranted access. 

FUN close	: db					-> com[void]
    -- close data base


FUN :=		: db ** denotation ** dyn		-> com[void]
    -- insert a new entry or update an existing one.


FUN !		: db ** denotation 			-> com[dyn]
    -- select an entry


FUN def?	: denotation ** db 			-> com[bool]
    -- test if entry is defined in dyn base


FUN delete	: db ** denotation			-> com[void]
    -- delete entry in dyn base


FUN dom		: db			-> com[seq[denotation]]
    -- get all defined keys in dyn base


FUN reorganize	: db					-> com[void]
    -- reorganize data base; usefull to minimize disk space
    -- after significant deletions

FUN sync	: db					-> com[void]
    -- flush unwritten data
