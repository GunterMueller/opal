IMPLEMENTATION IOordinatrice

IMPORT InterOpal COMPLETELY
       Fmt COMPLETELY
       FmtBasicTypes COMPLETELY
       FmtOption COMPLETELY
       FmtSeq COMPLETELY
       Nat ONLY nat 2 < =
       Seq ONLY seq < =
       Denotation ONLY < =
       OptionAdd ONLY < =

FUN fmtDyn: dyn -> fmt
DEF fmtDyn(_) == lit("[dyn]")



-- this is output of ordinatrice verte for free type guard
FUN < : guard ** guard -> bool
DEF <(guard(a,b,c),guard(A,B,C)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
IF <(c,C) THEN true
IF <(C,c) THEN false
ELSE
false
FI
FI
FI

FUN = : guard ** guard -> bool
DEF =(guard(a,b,c),guard(A,B,C)) == IF =(a,A) THEN IF =(b,B) THEN IF =(c,C) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI

FUN :=_then : guard ** expr -> guard
DEF :=_then(guard(1,v2,_),new) == guard(1,v2,new)

FUN :=_if : guard ** expr -> guard
DEF :=_if(guard(1,_,3),new) == guard(1,new,3)

FUN :=_pos : guard ** pos -> guard
DEF :=_pos(guard(_,v2,3),new) == guard(new,v2,3)

FUN fmtGuard : guard -> fmt
DEF fmtGuard(guard(v0,v1,v2)) == ;(;(beg(2),lit("guard")),;(;(lit("("),;(;(;(fmtPos(v0),;(lit(", "),fmtExpr(v1))),;(lit(", "),fmtExpr(v2))),lit(")"))),end))



-- this is output of ordinatrice verte for free type name
-- FUN < : name ** name -> bool

FUN = : name ** name -> bool
DEF =(name(a,b,c),name(A,B,C)) == IF =(a,A) THEN IF =(b,B) THEN IF =(c,C) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI

FUN :=_inst : name ** inst -> name
DEF :=_inst(name(1,v2,_),new) == name(1,v2,new)

FUN :=_origin : name ** origin -> name
DEF :=_origin(name(1,_,3),new) == name(1,new,3)

FUN :=_ident : name ** ident -> name
DEF :=_ident(name(_,v2,3),new) == name(new,v2,3)

FUN fmtName : name -> fmt
DEF fmtName(name(v0,v1,v2)) == ;(;(beg(2),lit("name")),;(;(lit("("),;(;(;(fmtIdent(v0),;(lit(", "),fmtOrigin(v1))),;(lit(", "),fmtInst(v2))),lit(")"))),end))



-- this is output of ordinatrice verte for free type origin
-- FUN < : origin ** origin -> bool

FUN = : origin ** origin -> bool
DEF =(local,local) == true
DEF =(local,main) == false
DEF =(local,origin(_)) == false
DEF =(main,local) == false
DEF =(main,main) == true
DEF =(main,origin(_)) == false
DEF =(origin(_),local) == false
DEF =(origin(_),main) == false
DEF =(origin(a),origin(A)) == IF =(a,A) THEN true
ELSE
false
FI

FUN :=_no : origin ** nat -> origin
DEF :=_no(origin(_),new) == origin(new)

FUN fmtOrigin : origin -> fmt
DEF fmtOrigin(local) == ;(;(beg(2),lit("local")),end)
DEF fmtOrigin(main) == ;(;(beg(2),lit("main")),end)
DEF fmtOrigin(origin(v0)) == ;(;(beg(2),lit("origin")),;(;(lit("("),;(fmtNat(v0),lit(")"))),end))



-- this is output of ordinatrice verte for free type inst
-- FUN < : inst ** inst -> bool

FUN = : inst ** inst -> bool
DEF =(none,none) == true
DEF =(none,formal) == false
DEF =(none,inst(_)) == false
DEF =(formal,none) == false
DEF =(formal,formal) == true
DEF =(formal,inst(_)) == false
DEF =(inst(_),none) == false
DEF =(inst(_),formal) == false
DEF =(inst(a),inst(A)) == IF =(a,A) THEN true
ELSE
false
FI

FUN :=_no : inst ** nat -> inst
DEF :=_no(inst(_),new) == inst(new)

FUN fmtInst : inst -> fmt
DEF fmtInst(none) == ;(;(beg(2),lit("none")),end)
DEF fmtInst(formal) == ;(;(beg(2),lit("formal")),end)
DEF fmtInst(inst(v0)) == ;(;(beg(2),lit("inst")),;(;(lit("("),;(fmtNat(v0),lit(")"))),end))



-- this is output of ordinatrice verte for free type ident
-- FUN < : ident ** ident -> bool

FUN = : ident ** ident -> bool
DEF =(ident(a),ident(A)) == IF =(a,A) THEN true
ELSE
false
FI

FUN :=_no : ident ** nat -> ident
DEF :=_no(ident(_),new) == ident(new)

FUN fmtIdent : ident -> fmt
DEF fmtIdent(ident(v0)) == ;(;(beg(2),lit("ident")),;(;(lit("("),;(fmtNat(v0),lit(")"))),end))



-- this is output of ordinatrice verte for free type fct
FUN < : fct ** fct -> bool
DEF <(sort(a),sort(A)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
false
FI
DEF <(sort(_),cart(_)) == true
DEF <(sort(_),funct(_,_)) == true
DEF <(cart(_),sort(_)) == false
DEF <(cart(a),cart(A)) == IF <(<)(a,A) THEN true
IF <(<)(A,a) THEN false
ELSE
false
FI
DEF <(cart(_),funct(_,_)) == true
DEF <(funct(_,_),sort(_)) == false
DEF <(funct(_,_),cart(_)) == false
DEF <(funct(a,b),funct(A,B)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
false
FI
FI

FUN = : fct ** fct -> bool
DEF =(sort(a),sort(A)) == IF =(a,A) THEN true
ELSE
false
FI
DEF =(sort(_),cart(_)) == false
DEF =(sort(_),funct(_,_)) == false
DEF =(cart(_),sort(_)) == false
DEF =(cart(a),cart(A)) == IF =(=)(a,A) THEN true
ELSE
false
FI
DEF =(cart(_),funct(_,_)) == false
DEF =(funct(_,_),sort(_)) == false
DEF =(funct(_,_),cart(_)) == false
DEF =(funct(a,b),funct(A,B)) == IF =(a,A) THEN IF =(b,B) THEN true
ELSE
false
FI
ELSE
false
FI

FUN :=_codom : fct ** fct -> fct
DEF :=_codom(funct(1,_),new) == funct(1,new)

FUN :=_dom : fct ** fct -> fct
DEF :=_dom(funct(_,v2),new) == funct(new,v2)

FUN :=_elems : fct ** seq[fct] -> fct
DEF :=_elems(cart(_),new) == cart(new)

FUN :=_sort : fct ** name -> fct
DEF :=_sort(sort(_),new) == sort(new)

FUN fmtFct : fct -> fmt
DEF fmtFct(sort(v0)) == ;(;(beg(2),lit("sort")),;(;(lit("("),;(fmtName(v0),lit(")"))),end))
DEF fmtFct(cart(v0)) == ;(;(beg(2),lit("cart")),;(;(lit("("),;(fmtSeq(fmtFct)(v0),lit(")"))),end))
DEF fmtFct(funct(v0,v1)) == ;(;(beg(2),lit("funct")),;(;(lit("("),;(;(fmtFct(v0),;(lit(", "),fmtFct(v1))),lit(")"))),end))



-- this is output of ordinatrice verte for free type pos

FUN < : pos ** pos -> bool
DEF <(unknown,unknown) == false
DEF <(unknown,part(_)) == true
DEF <(unknown,pos(_,_,_)) == true
DEF <(unknown,region(_,_,_,_,_)) == true
DEF <(part(_),unknown) == false
DEF <(part(a),part(A)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
false
FI
DEF <(part(_),pos(_,_,_)) == true
DEF <(part(_),region(_,_,_,_,_)) == true
DEF <(pos(_,_,_),unknown) == false
DEF <(pos(_,_,_),part(_)) == false
DEF <(pos(a,b,c),pos(A,B,C)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
IF <(c,C) THEN true
IF <(C,c) THEN false
ELSE
false
FI
FI
FI
DEF <(pos(_,_,_),region(_,_,_,_,_)) == true
DEF <(region(_,_,_,_,_),unknown) == false
DEF <(region(_,_,_,_,_),part(_)) == false
DEF <(region(_,_,_,_,_),pos(_,_,_)) == false
DEF <(region(a,b,c,d,e),region(A,B,C,D,E)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
IF <(c,C) THEN true
IF <(C,c) THEN false
ELSE
IF <(d,D) THEN true
IF <(D,d) THEN false
ELSE
IF <(e,E) THEN true
IF <(E,e) THEN false
ELSE
false
FI
FI
FI
FI
FI

FUN = : pos ** pos -> bool
DEF =(unknown,unknown) == true
DEF =(unknown,part(_)) == false
DEF =(unknown,pos(_,_,_)) == false
DEF =(unknown,region(_,_,_,_,_)) == false
DEF =(part(_),unknown) == false
DEF =(part(a),part(A)) == IF =(a,A) THEN true
ELSE
false
FI
DEF =(part(_),pos(_,_,_)) == false
DEF =(part(_),region(_,_,_,_,_)) == false
DEF =(pos(_,_,_),unknown) == false
DEF =(pos(_,_,_),part(_)) == false
DEF =(pos(a,b,c),pos(A,B,C)) == IF =(a,A) THEN IF =(b,B) THEN IF =(c,C) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
DEF =(pos(_,_,_),region(_,_,_,_,_)) == false
DEF =(region(_,_,_,_,_),unknown) == false
DEF =(region(_,_,_,_,_),part(_)) == false
DEF =(region(_,_,_,_,_),pos(_,_,_)) == false
DEF =(region(a,b,c,d,e),region(A,B,C,D,E)) == IF =(a,A) THEN IF =(b,B) THEN IF =(c,C) THEN IF =(d,D) THEN IF =(e,E) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI

FUN :=_endCol : pos ** nat -> pos
DEF :=_endCol(region(1,n2,3,4,_),new) == region(1,n2,3,4,new)

FUN :=_endRow : pos ** nat -> pos
DEF :=_endRow(region(1,n2,3,_,5),new) == region(1,n2,3,new,5)

FUN :=_col : pos ** nat -> pos
DEF :=_col(region(1,n2,_,4,5),new) == region(1,n2,new,4,5)
DEF :=_col(pos(1,n2,_),new) == pos(1,n2,new)

FUN :=_row : pos ** nat -> pos
DEF :=_row(region(1,_,3,4,5),new) == region(1,new,3,4,5)
DEF :=_row(pos(1,_,3),new) == pos(1,new,3)

FUN :=_part : pos ** part -> pos
DEF :=_part(region(_,n2,3,4,5),new) == region(new,n2,3,4,5)
DEF :=_part(pos(_,n2,3),new) == pos(new,n2,3)
DEF :=_part(part(_),new) == part(new)

FUN fmtPos : pos -> fmt
DEF fmtPos(unknown) == ;(;(beg(2),lit("unknown")),end)
DEF fmtPos(part(v0)) == ;(;(beg(2),lit("part")),;(;(lit("("),;(fmtPart(v0),lit(")"))),end))
DEF fmtPos(pos(v0,v1,v2)) == ;(;(beg(2),lit("pos")),;(;(lit("("),;(;(;(fmtPart(v0),;(lit(", "),fmtNat(v1))),;(lit(", "),fmtNat(v2))),lit(")"))),end))
DEF fmtPos(region(v0,v1,v2,v3,v4)) == ;(;(beg(2),lit("region")),;(;(lit("("),;(;(;(;(;(fmtPart(v0),;(lit(", "),fmtNat(v1))),;(lit(", "),fmtNat(v2))),;(lit(", "),fmtNat(v3))),;(lit(", "),fmtNat(v4))),lit(")"))),end))



-- this is output of ordinatrice verte for free type kind
FUN < : kind ** kind -> bool
DEF <(sort,sort) == false
DEF <(sort,fct(_)) == true
DEF <(sort,other(_,_)) == true
DEF <(fct(_),sort) == false
DEF <(fct(a),fct(A)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
false
FI
DEF <(fct(_),other(_,_)) == true
DEF <(other(_,_),sort) == false
DEF <(other(_,_),fct(_)) == false
DEF <(other(a,_),other(A,_)) == <(a,A)

FUN = : kind ** kind -> bool
DEF =(sort,sort) == true
DEF =(sort,fct(_)) == false
DEF =(sort,other(_,_)) == false
DEF =(fct(_),sort) == false
DEF =(fct(a),fct(A)) == IF =(a,A) THEN true
ELSE
false
FI
DEF =(fct(_),other(_,_)) == false
DEF =(other(_,_),sort) == false
DEF =(other(_,_),fct(_)) == false
DEF =(other(a,_),other(A,_)) ==  =(a,A)

FUN :=_data : kind ** dyn -> kind
DEF :=_data(other(1,_),new) == other(1,new)

FUN :=_id : kind ** denotation -> kind
DEF :=_id(other(_,2),new) == other(new,2)

FUN :=_fct : kind ** fct -> kind
DEF :=_fct(fct(_),new) == fct(new)

FUN fmtKind : kind -> fmt
DEF fmtKind(sort) == ;(;(beg(2),lit("sort")),end)
DEF fmtKind(fct(v0)) == ;(;(beg(2),lit("fct")),;(;(lit("("),;(fmtFct(v0),lit(")"))),end))
DEF fmtKind(other(v0,v1)) == ;(;(beg(2),lit("other")),;(;(lit("("),;(;(fmtDenotation(v0),;(lit(", "),fmtDyn(v1))),lit(")"))),end))


-- this is output of ordinatrice verte for free type eqn
FUN < : eqn ** eqn -> bool
DEF <(eqn(a,b,c,d),eqn(A,B,C,D)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
IF <(<)(c,C) THEN true
IF <(<)(C,c) THEN false
ELSE
IF <(d,D) THEN true
IF <(D,d) THEN false
ELSE
false
FI
FI
FI
FI

FUN = : eqn ** eqn -> bool
DEF =(eqn(a,b,c,d),eqn(A,B,C,D)) == IF =(a,A) THEN IF =(b,B) THEN IF =(=)(c,C) THEN IF =(d,D) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI

FUN :=_rhs : eqn ** expr -> eqn
DEF :=_rhs(eqn(1,v2,3,_),new) == eqn(1,v2,3,new)

FUN :=_patterns : eqn ** seq[pattern] -> eqn
DEF :=_patterns(eqn(1,v2,_,4),new) == eqn(1,v2,new,4)

FUN :=_lhs : eqn ** pattern -> eqn
DEF :=_lhs(eqn(1,_,3,4),new) == eqn(1,new,3,4)

FUN :=_pos : eqn ** pos -> eqn
DEF :=_pos(eqn(_,v2,3,4),new) == eqn(new,v2,3,4)

FUN fmtEqn : eqn -> fmt
DEF fmtEqn(eqn(v0,v1,v2,v3)) == ;(;(beg(2),lit("eqn")),;(;(lit("("),;(;(;(;(fmtPos(v0),;(lit(", "),fmtPattern(v1))),;(lit(", "),fmtSeq(fmtPattern)(v2))),;(lit(", "),fmtExpr(v3))),lit(")"))),end))



-- this is output of ordinatrice verte for free type var
FUN < : var ** var -> bool
DEF <(var(a,b,c,d),var(A,B,C,D)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
IF <(c,C) THEN true
IF <(C,c) THEN false
ELSE
IF <(d,D) THEN true
IF <(D,d) THEN false
ELSE
false
FI
FI
FI
FI

FUN = : var ** var -> bool
DEF =(var(a,b,c,d),var(A,B,C,D)) == IF =(a,A) THEN IF =(b,B) THEN IF =(c,C) THEN IF =(d,D) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI

FUN :=_fct : var ** fct -> var
DEF :=_fct(var(1,v2,3,_),new) == var(1,v2,3,new)

FUN :=_symbol : var ** denotation -> var
DEF :=_symbol(var(1,v2,_,4),new) == var(1,v2,new,4)

FUN :=_ident : var ** ident -> var
DEF :=_ident(var(1,_,3,4),new) == var(1,new,3,4)

FUN :=_pos : var ** pos -> var
DEF :=_pos(var(_,v2,3,4),new) == var(new,v2,3,4)

FUN fmtVar : var -> fmt
DEF fmtVar(var(v0,v1,v2,v3)) == ;(;(beg(2),lit("var")),;(;(lit("("),;(;(;(;(fmtPos(v0),;(lit(", "),fmtIdent(v1))),;(lit(", "),fmtDenotation(v2))),;(lit(", "),fmtFct(v3))),lit(")"))),end))



-- this is output of ordinatrice verte for free type expr
FUN < : expr ** expr -> bool
DEF < : expr ** expr -> bool(name(a,b),name(A,B)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
false
FI
FI
DEF < : expr ** expr -> bool(name(_,_),den(_,_)) == true
DEF < : expr ** expr -> bool(name(_,_),tuple(_,_)) == true
DEF < : expr ** expr -> bool(name(_,_),apply(_,_,_)) == true
DEF < : expr ** expr -> bool(name(_,_),cases(_,_,_)) == true
DEF < : expr ** expr -> bool(name(_,_),lambda(_,_,_)) == true
DEF < : expr ** expr -> bool(name(_,_),block(_,_,_)) == true
DEF < : expr ** expr -> bool(den(_,_),name(_,_)) == false
DEF < : expr ** expr -> bool(den(a,b),den(A,B)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
false
FI
FI
DEF <(den(_,_),tuple(_,_)) == true
DEF <(den(_,_),apply(_,_,_)) == true
DEF <(den(_,_),cases(_,_,_)) == true
DEF <(den(_,_),lambda(_,_,_)) == true
DEF <(den(_,_),block(_,_,_)) == true
DEF <(tuple(_,_),(name(_,_)):expr) == false
DEF <(tuple(_,_),den(_,_)) == false
DEF < : expr ** expr -> bool(tuple(a,b),tuple(A,B)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(<)(b,B) THEN true
IF <(<)(B,b) THEN false
ELSE
false
FI
FI
DEF < : expr ** expr -> bool(tuple(_,_),apply(_,_,_)) == true
DEF <(tuple(_,_),cases(_,_,_)) == true
DEF <(tuple(_,_),lambda(_,_,_)) == true
DEF <(tuple(_,_),block(_,_,_)) == true
DEF < : expr ** expr -> bool(apply(_,_,_),name(_,_)) == false
DEF <(apply(_,_,_),den(_,_)) == false
DEF < : expr ** expr -> bool(apply(_,_,_),tuple(_,_)) == false
DEF < : expr ** expr -> bool(apply(a,b,c),apply(A,B,C)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
IF <(c,C) THEN true
IF <(C,c) THEN false
ELSE
false
FI
FI
FI
DEF <(apply(_,_,_),cases(_,_,_)) == true
DEF <(apply(_,_,_),lambda(_,_,_)) == true
DEF <(apply(_,_,_),block(_,_,_)) == true
DEF <(cases(_,_,_),name(_,_)) == false
DEF <(cases(_,_,_),den(_,_)) == false
DEF <(cases(_,_,_),tuple(_,_)) == false
DEF <(cases(_,_,_),apply(_,_,_)) == false
DEF <(cases(a,b,c),cases(A,B,C)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(<)(b,B) THEN true
IF <(<)(B,b) THEN false
ELSE
IF <(<)(c,C) THEN true
IF <(<)(C,c) THEN false
ELSE
false
FI
FI
FI
DEF <(cases(_,_,_),lambda(_,_,_)) == true
DEF <(cases(_,_,_),block(_,_,_)) == true
DEF <(lambda(_,_,_),name(_,_)) == false
DEF <(lambda(_,_,_),den(_,_)) == false
DEF <(lambda(_,_,_),tuple(_,_)) == false
DEF <(lambda(_,_,_),apply(_,_,_)) == false
DEF <(lambda(_,_,_),cases(_,_,_)) == false
DEF <(lambda(a,b,c),lambda(A,B,C)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(<)(b,B) THEN true
IF <(<)(B,b) THEN false
ELSE
IF <(c,C) THEN true
IF <(C,c) THEN false
ELSE
false
FI
FI
FI
DEF <(lambda(_,_,_),block(_,_,_)) == true
DEF <(block(_,_,_),name(_,_)) == false
DEF <(block(_,_,_),den(_,_)) == false
DEF <(block(_,_,_),tuple(_,_)) == false
DEF <(block(_,_,_),apply(_,_,_)) == false
DEF <(block(_,_,_),cases(_,_,_)) == false
DEF <(block(_,_,_),lambda(_,_,_)) == false
DEF <(block(a,b,c),block(A,B,C)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(<)(b,B) THEN true
IF <(<)(B,b) THEN false
ELSE
IF <(c,C) THEN true
IF <(C,c) THEN false
ELSE
false
FI
FI
FI

FUN = : expr ** expr -> bool
DEF = : expr ** expr -> bool(name(a,b),name(A,B)) == IF =(a,A) THEN IF =(b,B) THEN true
ELSE
false
FI
ELSE
false
FI
DEF =(name(_,_),den(_,_)) == false
DEF = : expr ** expr -> bool(name(_,_),tuple(_,_)) == false
DEF = : expr ** expr -> bool(name(_,_),apply(_,_,_)) == false
DEF =(name(_,_),cases(_,_,_)) == false
DEF =(name(_,_),lambda(_,_,_)) == false
DEF =(name(_,_),block(_,_,_)) == false
DEF =(den(_,_),name(_,_)) == false
DEF =(den(a,b),den(A,B)) == IF =(a,A) THEN IF =(b,B) THEN true
ELSE
false
FI
ELSE
false
FI
DEF =(den(_,_),tuple(_,_)) == false
DEF =(den(_,_),apply(_,_,_)) == false
DEF =(den(_,_),cases(_,_,_)) == false
DEF =(den(_,_),lambda(_,_,_)) == false
DEF =(den(_,_),block(_,_,_)) == false
DEF = : expr ** expr -> bool(tuple(_,_),name(_,_)) == false
DEF =(tuple(_,_),den(_,_)) == false
DEF = : expr ** expr -> bool(tuple(a,b),tuple(A,B)) == IF =(a,A) THEN IF =(=)(b,B) THEN true
ELSE
false
FI
ELSE
false
FI
DEF = : expr ** expr -> bool(tuple(_,_),apply(_,_,_)) == false
DEF =(tuple(_,_),cases(_,_,_)) == false
DEF =(tuple(_,_),lambda(_,_,_)) == false
DEF =(tuple(_,_),block(_,_,_)) == false
DEF = : expr ** expr -> bool(apply(_,_,_),name(_,_)) == false
DEF =(apply(_,_,_),den(_,_)) == false
DEF = : expr ** expr -> bool(apply(_,_,_),tuple(_,_)) == false
DEF = : expr ** expr -> bool(apply(a,b,c),apply(A,B,C)) == IF =(a,A) THEN IF =(b,B) THEN IF =(c,C) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
DEF =(apply(_,_,_),cases(_,_,_)) == false
DEF =(apply(_,_,_),lambda(_,_,_)) == false
DEF =(apply(_,_,_),block(_,_,_)) == false
DEF =(cases(_,_,_),name(_,_)) == false
DEF =(cases(_,_,_),den(_,_)) == false
DEF =(cases(_,_,_),tuple(_,_)) == false
DEF =(cases(_,_,_),apply(_,_,_)) == false
DEF =(cases(a,b,c),cases(A,B,C)) == IF =(a,A) THEN IF =(=)(b,B) THEN IF =(=)(c,C) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
DEF =(cases(_,_,_),lambda(_,_,_)) == false
DEF =(cases(_,_,_),block(_,_,_)) == false
DEF =(lambda(_,_,_),name(_,_)) == false
DEF =(lambda(_,_,_),den(_,_)) == false
DEF =(lambda(_,_,_),tuple(_,_)) == false
DEF =(lambda(_,_,_),apply(_,_,_)) == false
DEF =(lambda(_,_,_),cases(_,_,_)) == false
DEF =(lambda(a,b,c),lambda(A,B,C)) == IF =(a,A) THEN IF =(=)(b,B) THEN IF =(c,C) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
DEF =(lambda(_,_,_),block(_,_,_)) == false
DEF =(block(_,_,_),name(_,_)) == false
DEF =(block(_,_,_),den(_,_)) == false
DEF =(block(_,_,_),tuple(_,_)) == false
DEF =(block(_,_,_),apply(_,_,_)) == false
DEF =(block(_,_,_),cases(_,_,_)) == false
DEF =(block(_,_,_),lambda(_,_,_)) == false
DEF =(block(a,b,c),block(A,B,C)) == IF =(a,A) THEN IF =(=)(b,B) THEN IF =(c,C) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI

FUN :=_body : expr ** expr -> expr
DEF :=_body(block(1,v2,_),new) == block(1,v2,new)
DEF :=_body(lambda(1,v2,_),new) == lambda(1,v2,new)

FUN :=_eqns : expr ** seq[eqn] -> expr
DEF :=_eqns(block(1,_,3),new) == block(1,new,3)

FUN :=_pos : expr ** pos -> expr
DEF :=_pos(block(_,v2,3),new) == block(new,v2,3)
DEF :=_pos(lambda(_,v2,3),new) == lambda(new,v2,3)
DEF :=_pos(cases(_,v2,3),new) == cases(new,v2,3)
DEF :=_pos(apply(_,v2:expr,3),new) == apply(new,v2,3)
DEF :=_pos(tuple(_,v2: seq[expr]),new) == tuple(new,v2)
DEF :=_pos(den(_,v2),new) == den(new,v2)
DEF :=_pos : expr ** pos -> expr(name(_,v2),new) == name(new,v2)

FUN :=_vars : expr ** seq[var] -> expr
DEF :=_vars(lambda(1,_,3),new) == lambda(1,new,3)

FUN :=_else : expr ** option[expr] -> expr
DEF :=_else(cases(1,v2,_),new) == cases(1,v2,new)

FUN :=_guards : expr ** seq[guard] -> expr
DEF :=_guards(cases(1,_,3),new) == cases(1,new,3)

FUN :=_arg : expr ** expr -> expr
DEF :=_arg((apply(1,v2,_)):expr,new) == apply(1,v2,new)

FUN :=_funct : expr ** expr -> expr
DEF :=_funct((apply(1,_,3)):expr,new) == apply(1,new,3)

FUN :=_elems : expr ** seq[expr] -> expr
DEF :=_elems((tuple(1,_)):expr,new) == tuple(1,new)

FUN :=_rep : expr ** denotation -> expr
DEF :=_rep(den(1,_),new) == den(1,new)

FUN :=_name : expr ** name -> expr
DEF :=_name((name(1,_)):expr,new) == name(1,new)

FUN fmtExpr : expr -> fmt
DEF fmtExpr(name(v0,v1)) == ;(;(beg(2),lit("name")),;(;(lit("("),;(;(fmtPos(v0),;(lit(", "),fmtName(v1))),lit(")"))),end))
DEF fmtExpr(den(v0,v1)) == ;(;(beg(2),lit("den")),;(;(lit("("),;(;(fmtPos(v0),;(lit(", "),fmtDenotation(v1))),lit(")"))),end))
DEF fmtExpr(tuple(v0,v1)) == ;(;(beg(2),lit("tuple")),;(;(lit("("),;(;(fmtPos(v0),;(lit(", "),fmtSeq(fmtExpr)(v1))),lit(")"))),end))
DEF fmtExpr(apply(v0,v1,v2)) == ;(;(beg(2),lit("apply")),;(;(lit("("),;(;(;(fmtPos(v0),;(lit(", "),fmtExpr(v1))),;(lit(", "),fmtExpr(v2))),lit(")"))),end))
DEF fmtExpr(cases(v0,v1,v2)) == ;(;(beg(2),lit("cases")),;(;(lit("("),;(;(;(fmtPos(v0),;(lit(", "),fmtSeq(fmtGuard)(v1))),;(lit(", "),fmtOption(fmtExpr)(v2))),lit(")"))),end))
DEF fmtExpr(lambda(v0,v1,v2)) == ;(;(beg(2),lit("lambda")),;(;(lit("("),;(;(;(fmtPos(v0),;(lit(", "),fmtSeq(fmtVar)(v1))),;(lit(", "),fmtExpr(v2))),lit(")"))),end))
DEF fmtExpr(block(v0,v1,v2)) == ;(;(beg(2),lit("block")),;(;(lit("("),;(;(;(fmtPos(v0),;(lit(", "),fmtSeq(fmtEqn)(v1))),;(lit(", "),fmtExpr(v2))),lit(")"))),end))



-- this is output of ordinatrice verte for free type pattern
FUN < : pattern ** pattern -> bool
DEF <(any(a),any(A)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
false
FI
DEF <(any(_),name(_,_)) == true
DEF <(any(_),var(_,_)) == true
DEF <(any(_),as(_,_,_)) == true
DEF <(any(_),apply(_,_,_)) == true
DEF <(any(_),tuple(_,_)) == true
DEF <(name(_,_),any(_)) == false
DEF < : pattern ** pattern -> bool(name(a,b), name(A,B)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
false
FI
FI
DEF <(name(_,_),var(_,_)) == true
DEF <(name(_,_),as(_,_,_)) == true
DEF < : pattern ** pattern -> bool(name(_,_),apply(_,_,_)) == true
DEF < : pattern ** pattern -> bool(name(_,_),tuple(_,_)) == true
DEF <(var(_,_),any(_)) == false
DEF <(var(_,_),name(_,_)) == false
DEF <(var(a,b),var(A,B)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
false
FI
FI
DEF <(var(_,_),as(_,_,_)) == true
DEF <(var(_,_),apply(_,_,_)) == true
DEF <(var(_,_),tuple(_,_)) == true
DEF <(as(_,_,_),any(_)) == false
DEF <(as(_,_,_),name(_,_)) == false
DEF <(as(_,_,_),var(_,_)) == false
DEF <(as(a,b,c),as(A,B,C)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
IF <(c,C) THEN true
IF <(C,c) THEN false
ELSE
false
FI
FI
FI
DEF <(as(_,_,_),apply(_,_,_)) == true
DEF <(as(_,_,_),tuple(_,_)) == true
DEF <(apply(_,_,_),any(_)) == false
DEF < : pattern ** pattern -> bool(apply(_,_,_),name(_,_)) == false
DEF <(apply(_,_,_),var(_,_)) == false
DEF <(apply(_,_,_),as(_,_,_)) == false
DEF < : pattern ** pattern -> bool(apply(a,b,c),apply(A,B,C)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
IF <(c,C) THEN true
IF <(C,c) THEN false
ELSE
false
FI
FI
FI
DEF < : pattern ** pattern -> bool(apply(_,_,_),tuple(_,_)) == true
DEF <(tuple(_,_),any(_)) == false
DEF < : pattern ** pattern -> bool(tuple(_,_),name(_,_)) == false
DEF <(tuple(_,_),var(_,_)) == false
DEF <(tuple(_,_),as(_,_,_)) == false
DEF < : pattern ** pattern -> bool(tuple(_,_),apply(_,_,_)) == false
DEF < : pattern ** pattern -> bool(tuple(a,b),tuple(A,B)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(<)(b,B) THEN true
IF <(<)(B,b) THEN false
ELSE
false
FI
FI

FUN = : pattern ** pattern -> bool
DEF =(any(a),any(A)) == IF =(a,A) THEN true
ELSE
false
FI
DEF =(any(_),name(_,_)) == false
DEF =(any(_),var(_,_)) == false
DEF =(any(_),as(_,_,_)) == false
DEF =(any(_),apply(_,_,_)) == false
DEF =(any(_),tuple(_,_)) == false
DEF =(name(_,_),any(_)) == false
DEF = : pattern ** pattern -> bool(name(a,b),name(A,B)) == IF =(a,A) THEN IF =(b,B) THEN true
ELSE
false
FI
ELSE
false
FI
DEF =(name(_,_),var(_,_)) == false
DEF =(name(_,_),as(_,_,_)) == false
DEF = : pattern ** pattern -> bool(name(_,_),apply(_,_,_)) == false
DEF = : pattern ** pattern -> bool(name(_,_),tuple(_,_)) == false
DEF =(var(_,_),any(_)) == false
DEF =(var(_,_),name(_,_)) == false
DEF =(var(a,b),var(A,B)) == IF =(a,A) THEN IF =(b,B) THEN true
ELSE
false
FI
ELSE
false
FI
DEF =(var(_,_),as(_,_,_)) == false
DEF =(var(_,_),apply(_,_,_)) == false
DEF =(var(_,_),tuple(_,_)) == false
DEF =(as(_,_,_),any(_)) == false
DEF =(as(_,_,_),name(_,_)) == false
DEF =(as(_,_,_),var(_,_)) == false
DEF =(as(a,b,c),as(A,B,C)) == IF =(a,A) THEN IF =(b,B) THEN IF =(c,C) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
DEF =(as(_,_,_),apply(_,_,_)) == false
DEF =(as(_,_,_),tuple(_,_)) == false
DEF =(apply(_,_,_),any(_)) == false
DEF = : pattern ** pattern -> bool(apply(_,_,_),name(_,_)) == false
DEF =(apply(_,_,_),var(_,_)) == false
DEF =(apply(_,_,_),as(_,_,_)) == false
DEF = : pattern ** pattern -> bool(apply(a,b,c),apply(A,B,C)) == IF =(a,A) THEN IF =(b,B) THEN IF =(c,C) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
DEF = : pattern ** pattern -> bool(apply(_,_,_),tuple(_,_)) == false
DEF =(tuple(_,_),any(_)) == false
DEF = : pattern ** pattern -> bool(tuple(_,_),name(_,_)) == false
DEF =(tuple(_,_),var(_,_)) == false
DEF =(tuple(_,_),as(_,_,_)) == false
DEF = : pattern ** pattern -> bool(tuple(_,_),apply(_,_,_)) == false
DEF = : pattern ** pattern -> bool(tuple(a,b),tuple(A,B)) == IF =(a,A) THEN IF =(=)(b,B) THEN true
ELSE
false
FI
ELSE
false
FI

FUN :=_elems : pattern ** seq[pattern] -> pattern
DEF :=_elems(tuple(1,_ : seq[pattern]),new) == tuple(1,new)

FUN :=_pos : pattern ** pos -> pattern
DEF :=_pos(tuple(_,v2:seq[pattern]),new) == tuple(new,v2)
DEF :=_pos(apply(_,v2:pattern,3),new) == apply(new,v2,3)
DEF :=_pos(as(_,v2,3),new) == as(new,v2,3)
DEF :=_pos(var(_,v2),new) == var(new,v2)
DEF :=_pos : pattern ** pos -> pattern(name(_,v2),new) == name(new,v2)
DEF :=_pos(any(_),new) == any(new)

FUN :=_arg : pattern ** pattern -> pattern
DEF :=_arg(apply(1,v2:pattern,_),new) == apply(1,v2,new)

FUN :=_funct : pattern ** pattern -> pattern
DEF :=_funct(apply(1,_ :pattern,3),new) == apply(1,new,3)

FUN :=_pattern : pattern ** pattern -> pattern
DEF :=_pattern(as(1,v2,_),new) == as(1,v2,new)

FUN :=_var : pattern ** var -> pattern
DEF :=_var(as(1,_,3),new) == as(1,new,3)
DEF :=_var(var(1,_),new) == var(1,new)

FUN :=_name : pattern ** name -> pattern
DEF :=_name : pattern ** name -> pattern(name(1,_),new) == name(1,new)

FUN fmtPattern : pattern -> fmt
DEF fmtPattern(any(v0)) == ;(;(beg(2),lit("any")),;(;(lit("("),;(fmtPos(v0),lit(")"))),end))
DEF fmtPattern(name(v0,v1)) == ;(;(beg(2),lit("name")),;(;(lit("("),;(;(fmtPos(v0),;(lit(", "),fmtName(v1))),lit(")"))),end))
DEF fmtPattern(var(v0,v1)) == ;(;(beg(2),lit("var")),;(;(lit("("),;(;(fmtPos(v0),;(lit(", "),fmtVar(v1))),lit(")"))),end))
DEF fmtPattern(as(v0,v1,v2)) == ;(;(beg(2),lit("as")),;(;(lit("("),;(;(;(fmtPos(v0),;(lit(", "),fmtVar(v1))),;(lit(", "),fmtPattern(v2))),lit(")"))),end))
DEF fmtPattern(apply(v0,v1,v2)) == ;(;(beg(2),lit("apply")),;(;(lit("("),;(;(;(fmtPos(v0),;(lit(", "),fmtPattern(v1))),;(lit(", "),fmtPattern(v2))),lit(")"))),end))
DEF fmtPattern(tuple(v0,v1)) == ;(;(beg(2),lit("tuple")),;(;(lit("("),;(;(fmtPos(v0),;(lit(", "),fmtSeq(fmtPattern)(v1))),lit(")"))),end))



-- this is output of ordinatrice verte for free type object
FUN < : object ** object -> bool
DEF <(object(a,b,c,d,e,f,g),object(A,B,C,D,E,F,G)) == IF <(<)(a,A) THEN true
IF <(<)(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
IF <(c,C) THEN true
IF <(C,c) THEN false
ELSE
IF <(d,D) THEN true
IF <(D,d) THEN false
ELSE
IF <(e,E) THEN true
IF <(E,e) THEN false
ELSE
IF <(<)(f,F) THEN true
IF <(<)(F,f) THEN false
ELSE
IF <(<)(g,G) THEN true
IF <(<)(G,g) THEN false
ELSE
false
FI
FI
FI
FI
FI
FI
FI

FUN = : object ** object -> bool
DEF =(object(a,b,c,d,e,f,g),object(A,B,C,D,E,F,G)) == IF =(=)(a,A) THEN IF =(b,B) THEN IF =(c,C) THEN IF =(d,D) THEN IF =(e,E) THEN IF =(=)(f,F) THEN IF =(=)(g,G) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI

FUN :=_pragmas : object ** seq[pragma] -> object
DEF :=_pragmas(object(1,2,3,4,5,6,_),new) == object(1,2,3,4,5,6,new)

FUN :=_props : object ** seq[ident] -> object
DEF :=_props(object(1,2,3,4,5,_,7),new) == object(1,2,3,4,5,new,7)

FUN :=_def : object ** impl -> object
DEF :=_def(object(1,2,3,4,_,6,7),new) == object(1,2,3,4,new,6,7)

FUN :=_kind : object ** kind -> object
DEF :=_kind(object(1,2,3,_,5,6,7),new) == object(1,2,3,new,5,6,7)

FUN :=_symbol : object ** denotation -> object
DEF :=_symbol(object(1,2,_,4,5,6,7),new) == object(1,2,new,4,5,6,7)

FUN :=_ident : object ** ident -> object
DEF :=_ident(object(1,_,3,4,5,6,7),new) == object(1,new,3,4,5,6,7)

FUN :=_pos : object ** seq[pos] -> object
DEF :=_pos(object(_,2,3,4,5,6,7),new) == object(new,2,3,4,5,6,7)

FUN fmtObject : object -> fmt
DEF fmtObject(object(v0,v1,v2,v3,v4,v5,v6)) == ;(;(beg(2),lit("object")),;(;(lit("("),;(;(;(;(;(;(;(fmtSeq(fmtPos)(v0),;(lit(", "),fmtIdent(v1))),;(lit(", "),fmtDenotation(v2))),;(lit(", "),fmtKind(v3))),;(lit(", "),fmtImpl(v4))),;(lit(", "),fmtSeq(fmtIdent)(v5))),;(lit(", "),fmtSeq(fmtPragma)(v6))),lit(")"))),end))

-- this is output of ordinatrice verte for free type variant
FUN < : variant ** variant -> bool
DEF <(variant(a,b,c,d),variant(A,B,C,D)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
IF <(c,C) THEN true
IF <(C,c) THEN false
ELSE
IF <(<)(d,D) THEN true
IF <(<)(D,d) THEN false
ELSE
false
FI
FI
FI
FI

FUN = : variant ** variant -> bool
DEF =(variant(a,b,c,d),variant(A,B,C,D)) == IF =(a,A) THEN IF =(b,B) THEN IF =(c,C) THEN IF =(=)(d,D) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI

FUN :=_comps : variant ** seq[comp] -> variant
DEF :=_comps(variant(1,v2,3,_),new) == variant(1,v2,3,new)

FUN :=_test : variant ** name -> variant
DEF :=_test(variant(1,v2,_,4),new) == variant(1,v2,new,4)

FUN :=_cons : variant ** name -> variant
DEF :=_cons(variant(1,_,3,4),new) == variant(1,new,3,4)

FUN :=_pos : variant ** pos -> variant
DEF :=_pos(variant(_,v2,3,4),new) == variant(new,v2,3,4)

FUN fmtVariant : variant -> fmt
DEF fmtVariant(variant(v0,v1,v2,v3)) == ;(;(beg(2),lit("variant")),;(;(lit("("),;(;(;(;(fmtPos(v0),;(lit(", "),fmtName(v1))),;(lit(", "),fmtName(v2))),;(lit(", "),fmtSeq(fmtComp)(v3))),lit(")"))),end))



-- this is output of ordinatrice verte for free type comp
FUN < : comp ** comp -> bool
DEF <(comp(a,b),comp(A,B)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
false
FI
FI

FUN = : comp ** comp -> bool
DEF =(comp(a,b),comp(A,B)) == IF =(a,A) THEN IF =(b,B) THEN true
ELSE
false
FI
ELSE
false
FI

FUN :=_sel : comp ** name -> comp
DEF :=_sel(comp(1,_),new) == comp(1,new)

FUN :=_pos : comp ** pos -> comp
DEF :=_pos(comp(_,v2),new) == comp(new,v2)

FUN fmtComp : comp -> fmt
DEF fmtComp(comp(v0,v1)) == ;(;(beg(2),lit("comp")),;(;(lit("("),;(;(fmtPos(v0),;(lit(", "),fmtName(v1))),lit(")"))),end))



-- this is output of ordinatrice verte for free type impl
FUN < : impl ** impl -> bool
DEF <(missing,missing) == false
DEF <(missing,imported) == true
DEF <(missing,parameter(_,_)) == true
DEF <(missing,induced(_,_)) == true
DEF <(missing,data(_)) == true
DEF <(missing,def(_)) == true
DEF <(missing:impl,other(_,_,_)) == true
DEF <(imported,missing) == false
DEF <(imported,imported) == false
DEF <(imported,parameter(_,_)) == true
DEF <(imported,induced(_,_)) == true
DEF <(imported,data(_)) == true
DEF <(imported,def(_)) == true
DEF <(imported:impl,other(_,_,_)) == true
DEF <(parameter(_,_),missing) == false
DEF <(parameter(_,_),imported) == false
DEF <(parameter(a,b),parameter(A,B)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
false
FI
FI
DEF <(parameter(_,_),induced(_,_)) == true
DEF <(parameter(_,_),data(_)) == true
DEF <(parameter(_,_),def(_)) == true
DEF <(parameter(_,_),other(_,_,_)) == true
DEF <(induced(_,_),missing) == false
DEF <(induced(_,_),imported) == false
DEF <(induced(_,_),parameter(_,_)) == false
DEF <(induced(a,b),induced(A,B)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
false
FI
FI
DEF <(induced(_,_),data(_)) == true
DEF <(induced(_,_),def(_)) == true
DEF <(induced(_,_),other(_,_,_)) == true
DEF <(data(_),missing) == false
DEF <(data(_),imported) == false
DEF <(data(_),parameter(_,_)) == false
DEF <(data(_),induced(_,_)) == false
DEF <(data(a),data(A)) == IF <(<)(a,A) THEN true
IF <(<)(A,a) THEN false
ELSE
false
FI
DEF <(data(_),def(_)) == true
DEF <(data(_),other(_,_,_)) == true
DEF <(def(_),missing) == false
DEF <(def(_),imported) == false
DEF <(def(_),parameter(_,_)) == false
DEF <(def(_),induced(_,_)) == false
DEF <(def(_),data(_)) == false
DEF <(def(a),def(A)) == IF <(<)(a,A) THEN true
IF <(<)(A,a) THEN false
ELSE
false
FI
DEF <(def(_),other(_,_,_)) == true
DEF <(other(_,_,_),missing:impl) == false
DEF <(other(_,_,_),imported:impl) == false
DEF <(other(_,_,_),parameter(_,_)) == false
DEF <(other(_,_,_),induced(_,_)) == false
DEF <(other(_,_,_),data(_)) == false
DEF <(other(_,_,_),def(_)) == false
DEF <(other:pos**denotation**dyn->impl(a,b,_),other(A,B,_)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
false
FI
FI

FUN = : impl ** impl -> bool
DEF =(missing,missing) == true
DEF =(missing,imported) == false
DEF =(missing,parameter(_,_)) == false
DEF =(missing,induced(_,_)) == false
DEF =(missing,data(_)) == false
DEF =(missing,def(_)) == false
DEF =(missing:impl,other(_,_,_)) == false
DEF =(imported,missing) == false
DEF =(imported,imported) == true
DEF =(imported,parameter(_,_)) == false
DEF =(imported,induced(_,_)) == false
DEF =(imported,data(_)) == false
DEF =(imported,def(_)) == false
DEF =(imported:impl,other(_,_,_)) == false
DEF =(parameter(_,_),missing) == false
DEF =(parameter(_,_),imported) == false
DEF =(parameter(a,b),parameter(A,B)) == IF =(a,A) THEN IF =(b,B) THEN true
ELSE
false
FI
ELSE
false
FI
DEF =(parameter(_,_),induced(_,_)) == false
DEF =(parameter(_,_),data(_)) == false
DEF =(parameter(_,_),def(_)) == false
DEF =(parameter(_,_),other(_,_,_)) == false
DEF =(induced(_,_),missing) == false
DEF =(induced(_,_),imported) == false
DEF =(induced(_,_),parameter(_,_)) == false
DEF =(induced(a,b),induced(A,B)) == IF =(a,A) THEN IF =(b,B) THEN true
ELSE
false
FI
ELSE
false
FI
DEF =(induced(_,_),data(_)) == false
DEF =(induced(_,_),def(_)) == false
DEF =(induced(_,_),other(_,_,_)) == false
DEF =(data(_),missing) == false
DEF =(data(_),imported) == false
DEF =(data(_),parameter(_,_)) == false
DEF =(data(_),induced(_,_)) == false
DEF =(data(a),data(A)) == IF =(=)(a,A) THEN true
ELSE
false
FI
DEF =(data(_),def(_)) == false
DEF =(data(_),other(_,_,_)) == false
DEF =(def(_),missing) == false
DEF =(def(_),imported) == false
DEF =(def(_),parameter(_,_)) == false
DEF =(def(_),induced(_,_)) == false
DEF =(def(_),data(_)) == false
DEF =(def(a),def(A)) == IF =(=)(a,A) THEN true
ELSE
false
FI
DEF =(def(_),other(_,_,_)) == false
DEF =(other(_,_,_),missing:impl) == false
DEF =(other(_,_,_),imported:impl) == false
DEF =(other(_,_,_),parameter(_,_)) == false
DEF =(other(_,_,_),induced(_,_)) == false
DEF =(other(_,_,_),data(_)) == false
DEF =(other(_,_,_),def(_)) == false
DEF = :impl**impl->bool(other(a,b,_),other(A,B,_)) == IF =(a,A) THEN =(b,B) ELSE false FI

FUN :=_data : impl ** dyn -> impl
DEF :=_data(other(1,2,_),new) == (other(1,2,new)):impl

FUN :=_id : impl ** denotation -> impl
DEF :=_id(other(1,_,3),new) == (other(1,new,3)):impl

FUN :=_pos : impl ** pos -> impl
DEF :=_pos(other(_,2,3),new) == (other(new,2,3)):impl
DEF :=_pos(induced(_,2),new) == induced(new,2)
DEF :=_pos(parameter(_,n2),new) == parameter(new,n2)

FUN :=_eqns : impl ** seq[eqn] -> impl
DEF :=_eqns(def(_),new) == def(new)

FUN :=_variants : impl ** seq[variant] -> impl
DEF :=_variants(data(_),new) == data(new)

FUN :=_sort : impl ** name -> impl
DEF :=_sort(induced(1,_),new) == induced(1,new)

FUN :=_no : impl ** nat -> impl
DEF :=_no(parameter(1,_),new) == parameter(1,new)

FUN fmtImpl : impl -> fmt
DEF fmtImpl(missing) == ;(;(beg(2),lit("missing")),end)
DEF fmtImpl(imported) == ;(;(beg(2),lit("imported")),end)
DEF fmtImpl(parameter(v0,v1)) == ;(;(beg(2),lit("parameter")),;(;(lit("("),;(;(fmtPos(v0),;(lit(", "),fmtNat(v1))),lit(")"))),end))
DEF fmtImpl(induced(v0,v1)) == ;(;(beg(2),lit("induced")),;(;(lit("("),;(;(fmtPos(v0),;(lit(", "),fmtName(v1))),lit(")"))),end))
DEF fmtImpl(data(v0)) == ;(;(beg(2),lit("data")),;(;(lit("("),;(fmtSeq(fmtVariant)(v0),lit(")"))),end))
DEF fmtImpl(def(v0)) == ;(;(beg(2),lit("def")),;(;(lit("("),;(fmtSeq(fmtEqn)(v0),lit(")"))),end))
DEF fmtImpl(other(v0,v1,v2)) == ;(;(beg(2),lit("other")),;(;(lit("("),;(;(;(fmtPos(v0),;(lit(", "),fmtDenotation(v1))),;(lit(", "),fmtDyn(v2))),lit(")"))),end))



-- this is output of ordinatrice verte for free type property

FUN < : property ** property -> bool
DEF <(freeType(a,b,c,d,e),freeType(A,B,C,D,E)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
IF <(c,C) THEN true
IF <(C,c) THEN false
ELSE
IF <(<)(d,D) THEN true
IF <(<)(D,d) THEN false
ELSE
IF <(<)(e,E) THEN true
IF <(<)(E,e) THEN false
ELSE
false
FI
FI
FI
FI
FI
DEF <(freeType(_,_,_,_,_),law(_,_,_,_,_)) == true
DEF <(freeType(_,_,_,_,_),other(_,_,_,_)) == true
DEF <(law(_,_,_,_,_),freeType(_,_,_,_,_)) == false
DEF <(law(a,b,c,d,e),law(A,B,C,D,E)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
IF <(<)(c,C) THEN true
IF <(<)(C,c) THEN false
ELSE
IF <(d,D) THEN true
IF <(D,d) THEN false
ELSE
IF <(<)(e,E) THEN true
IF <(<)(E,e) THEN false
ELSE
false
FI
FI
FI
FI
FI
DEF <(law(_,_,_,_,_),other(_,_,_,_)) == true
DEF <(other(_,_,_,_),freeType(_,_,_,_,_)) == false
DEF <(other(_,_,_,_),law(_,_,_,_,_)) == false
DEF <(other(a,b,_,d),other(A,B,_,D)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
IF <(<)(d,D) THEN true
IF <(<)(D,d) THEN false
ELSE
false
FI
FI
FI


FUN = : property ** property -> bool
DEF =(freeType(a,b,c,d,e),freeType(A,B,C,D,E)) == IF =(a,A) THEN IF =(b,B) THEN IF =(c,C) THEN IF =(=)(d,D) THEN IF =(=)(e,E) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
DEF =(freeType(_,_,_,_,_),law(_,_,_,_,_)) == false
DEF =(freeType(_,_,_,_,_),other(_,_,_,_)) == false
DEF =(law(_,_,_,_,_),freeType(_,_,_,_,_)) == false
DEF =(law(a,b,c,d,e),law(A,B,C,D,E)) == IF =(a,A) THEN IF =(b,B) THEN IF =(=)(c,C) THEN IF =(d,D) THEN IF =(=)(e,E) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
DEF =(law(_,_,_,_,_),other(_,_,_,_)) == false
DEF =(other(_,_,_,_),freeType(_,_,_,_,_)) == false
DEF =(other(_,_,_,_),law(_,_,_,_,_)) == false
DEF =(other(a,b,_,d),other(A,B,_,D)) == IF =(a,A) THEN IF =(b,B) THEN IF =(=)(d,D) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI

FUN :=_pragmas : property ** seq[pragma] -> property
DEF :=_pragmas(other(1,2,3,_),new) == other(1,2,3,new)
DEF :=_pragmas(law(1,2,3,4,_),new) == law(1,2,3,4,new)
DEF :=_pragmas(freeType(1,2,3,4,_),new) == freeType(1,2,3,4,new)

FUN :=_data : property ** dyn -> property
DEF :=_data(other(1,2,_,4),new) == other(1,2,new,4)

FUN :=_id : property ** denotation -> property
DEF :=_id(other(1,_,3,4),new) == other(1,new,3,4)

FUN :=_pos : property ** pos -> property
DEF :=_pos(other(_,2,3,4),new) == other(new,2,3,4)
DEF :=_pos(law(_,2,3,4,5),new) == law(new,2,3,4,5)
DEF :=_pos(freeType(_,2,3,4,5),new) == freeType(new,2,3,4,5)

FUN :=_formula : property ** formula -> property
DEF :=_formula(law(1,2,3,_,5),new) == law(1,2,3,new,5)

FUN :=_symbol : property ** option[denotation] -> property
DEF :=_symbol(law(1,2,_,4,5),new) == law(1,2,new,4,5)

FUN :=_ident : property ** ident -> property
DEF :=_ident(law(1,_,3,4,5),new) == law(1,new,3,4,5)
DEF :=_ident(freeType(1,_,3,4,5),new) == freeType(1,new,3,4,5)

FUN :=_variants : property ** seq[variant] -> property
DEF :=_variants(freeType(1,2,3,_,5),new) == freeType(1,2,3,new,5)

FUN :=_sort : property ** name -> property
DEF :=_sort(freeType(1,2,_,4,5),new) == freeType(1,2,new,4,5)

FUN fmtProperty : property -> fmt
DEF fmtProperty(freeType(v0,v1,v2,v3,v4)) == ;(;(beg(2),lit("freeType")),;(;(lit("("),;(;(;(;(;(fmtPos(v0),;(lit(", "),fmtIdent(v1))),;(lit(", "),fmtName(v2))),;(lit(", "),fmtSeq(fmtVariant)(v3))),;(lit(", "),fmtSeq(fmtPragma)(v4))),lit(")"))),end))
DEF fmtProperty(law(v0,v1,v2,v3,v4)) == ;(;(beg(2),lit("law")),;(;(lit("("),;(;(;(;(;(fmtPos(v0),;(lit(", "),fmtIdent(v1))),;(lit(", "),fmtOption(fmtDenotation)(v2))),;(lit(", "),fmtFormula(v3))),;(lit(", "),fmtSeq(fmtPragma)(v4))),lit(")"))),end))
DEF fmtProperty(other(v0,v1,v2,v3)) == ;(;(beg(2),lit("other")),;(;(lit("("),;(;(;(;(fmtPos(v0),;(lit(", "),fmtDenotation(v1))),;(lit(", "),fmtDyn(v2))),;(lit(", "),fmtSeq(fmtPragma)(v3))),lit(")"))),end))


-- this is output of ordinatrice verte for free type formula
FUN < : formula ** formula -> bool
DEF <(dfd(a,b),dfd(A,B)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
false
FI
FI
DEF <(dfd(_,_),approx(_,_,_)) == true
DEF <(dfd(_,_),cong(_,_,_)) == true
DEF <(dfd(_,_),neg(_,_)) == true
DEF <(dfd(_,_),conj(_,_,_)) == true
DEF <(dfd(_,_),disj(_,_,_)) == true
DEF <(dfd(_,_),impl(_,_,_)) == true
DEF <(dfd(_,_),equiv(_,_,_)) == true
DEF <(dfd(_,_),forall(_,_,_)) == true
DEF <(dfd(_,_),exist(_,_,_)) == true
DEF <(dfd(_,_),informal(_,_)) == true
DEF <(dfd(_,_),other(_,_,_)) == true
DEF <(approx(_,_,_),dfd(_,_)) == false
DEF <(approx(a,b,c),approx(A,B,C)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
IF <(c,C) THEN true
IF <(C,c) THEN false
ELSE
false
FI
FI
FI
DEF <(approx(_,_,_),cong(_,_,_)) == true
DEF <(approx(_,_,_),neg(_,_)) == true
DEF <(approx(_,_,_),conj(_,_,_)) == true
DEF <(approx(_,_,_),disj(_,_,_)) == true
DEF <(approx(_,_,_),impl(_,_,_)) == true
DEF <(approx(_,_,_),equiv(_,_,_)) == true
DEF <(approx(_,_,_),forall(_,_,_)) == true
DEF <(approx(_,_,_),exist(_,_,_)) == true
DEF <(approx(_,_,_),informal(_,_)) == true
DEF <(approx(_,_,_),other(_,_,_)) == true
DEF <(cong(_,_,_),dfd(_,_)) == false
DEF <(cong(_,_,_),approx(_,_,_)) == false
DEF <(cong(a,b,c),cong(A,B,C)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
IF <(c,C) THEN true
IF <(C,c) THEN false
ELSE
false
FI
FI
FI
DEF <(cong(_,_,_),neg(_,_)) == true
DEF <(cong(_,_,_),conj(_,_,_)) == true
DEF <(cong(_,_,_),disj(_,_,_)) == true
DEF <(cong(_,_,_),impl(_,_,_)) == true
DEF <(cong(_,_,_),equiv(_,_,_)) == true
DEF <(cong(_,_,_),forall(_,_,_)) == true
DEF <(cong(_,_,_),exist(_,_,_)) == true
DEF <(cong(_,_,_),informal(_,_)) == true
DEF <(cong(_,_,_),other(_,_,_)) == true
DEF <(neg(_,_),dfd(_,_)) == false
DEF <(neg(_,_),approx(_,_,_)) == false
DEF <(neg(_,_),cong(_,_,_)) == false
DEF <(neg(a,b),neg(A,B)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
false
FI
FI
DEF <(neg(_,_),conj(_,_,_)) == true
DEF <(neg(_,_),disj(_,_,_)) == true
DEF <(neg(_,_),impl(_,_,_)) == true
DEF <(neg(_,_),equiv(_,_,_)) == true
DEF <(neg(_,_),forall(_,_,_)) == true
DEF <(neg(_,_),exist(_,_,_)) == true
DEF <(neg(_,_),informal(_,_)) == true
DEF <(neg(_,_),other(_,_,_)) == true
DEF <(conj(_,_,_),dfd(_,_)) == false
DEF <(conj(_,_,_),approx(_,_,_)) == false
DEF <(conj(_,_,_),cong(_,_,_)) == false
DEF <(conj(_,_,_),neg(_,_)) == false
DEF <(conj(a,b,c),conj(A,B,C)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
IF <(c,C) THEN true
IF <(C,c) THEN false
ELSE
false
FI
FI
FI
DEF <(conj(_,_,_),disj(_,_,_)) == true
DEF <(conj(_,_,_),impl(_,_,_)) == true
DEF <(conj(_,_,_),equiv(_,_,_)) == true
DEF <(conj(_,_,_),forall(_,_,_)) == true
DEF <(conj(_,_,_),exist(_,_,_)) == true
DEF <(conj(_,_,_),informal(_,_)) == true
DEF <(conj(_,_,_),other(_,_,_)) == true
DEF <(disj(_,_,_),dfd(_,_)) == false
DEF <(disj(_,_,_),approx(_,_,_)) == false
DEF <(disj(_,_,_),cong(_,_,_)) == false
DEF <(disj(_,_,_),neg(_,_)) == false
DEF <(disj(_,_,_),conj(_,_,_)) == false
DEF <(disj(a,b,c),disj(A,B,C)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
IF <(c,C) THEN true
IF <(C,c) THEN false
ELSE
false
FI
FI
FI
DEF <(disj(_,_,_),impl(_,_,_)) == true
DEF <(disj(_,_,_),equiv(_,_,_)) == true
DEF <(disj(_,_,_),forall(_,_,_)) == true
DEF <(disj(_,_,_),exist(_,_,_)) == true
DEF <(disj(_,_,_),informal(_,_)) == true
DEF <(disj(_,_,_),other(_,_,_)) == true
DEF <(impl(_,_,_),dfd(_,_)) == false
DEF <(impl(_,_,_),approx(_,_,_)) == false
DEF <(impl(_,_,_),cong(_,_,_)) == false
DEF <(impl(_,_,_),neg(_,_)) == false
DEF <(impl(_,_,_),conj(_,_,_)) == false
DEF <(impl(_,_,_),disj(_,_,_)) == false
DEF <(impl(a,b,c),impl(A,B,C)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
IF <(c,C) THEN true
IF <(C,c) THEN false
ELSE
false
FI
FI
FI
DEF <(impl(_,_,_),equiv(_,_,_)) == true
DEF <(impl(_,_,_),forall(_,_,_)) == true
DEF <(impl(_,_,_),exist(_,_,_)) == true
DEF <(impl(_,_,_),informal(_,_)) == true
DEF <(impl(_,_,_),other(_,_,_)) == true
DEF <(equiv(_,_,_),dfd(_,_)) == false
DEF <(equiv(_,_,_),approx(_,_,_)) == false
DEF <(equiv(_,_,_),cong(_,_,_)) == false
DEF <(equiv(_,_,_),neg(_,_)) == false
DEF <(equiv(_,_,_),conj(_,_,_)) == false
DEF <(equiv(_,_,_),disj(_,_,_)) == false
DEF <(equiv(_,_,_),impl(_,_,_)) == false
DEF <(equiv(a,b,c),equiv(A,B,C)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
IF <(c,C) THEN true
IF <(C,c) THEN false
ELSE
false
FI
FI
FI
DEF <(equiv(_,_,_),forall(_,_,_)) == true
DEF <(equiv(_,_,_),exist(_,_,_)) == true
DEF <(equiv(_,_,_),informal(_,_)) == true
DEF <(equiv(_,_,_),other(_,_,_)) == true
DEF <(forall(_,_,_),dfd(_,_)) == false
DEF <(forall(_,_,_),approx(_,_,_)) == false
DEF <(forall(_,_,_),cong(_,_,_)) == false
DEF <(forall(_,_,_),neg(_,_)) == false
DEF <(forall(_,_,_),conj(_,_,_)) == false
DEF <(forall(_,_,_),disj(_,_,_)) == false
DEF <(forall(_,_,_),impl(_,_,_)) == false
DEF <(forall(_,_,_),equiv(_,_,_)) == false
DEF <(forall(a,b,c),forall(A,B,C)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(<)(b,B) THEN true
IF <(<)(B,b) THEN false
ELSE
IF <(c,C) THEN true
IF <(C,c) THEN false
ELSE
false
FI
FI
FI
DEF <(forall(_,_,_),exist(_,_,_)) == true
DEF <(forall(_,_,_),informal(_,_)) == true
DEF <(forall(_,_,_),other(_,_,_)) == true
DEF <(exist(_,_,_),dfd(_,_)) == false
DEF <(exist(_,_,_),approx(_,_,_)) == false
DEF <(exist(_,_,_),cong(_,_,_)) == false
DEF <(exist(_,_,_),neg(_,_)) == false
DEF <(exist(_,_,_),conj(_,_,_)) == false
DEF <(exist(_,_,_),disj(_,_,_)) == false
DEF <(exist(_,_,_),impl(_,_,_)) == false
DEF <(exist(_,_,_),equiv(_,_,_)) == false
DEF <(exist(_,_,_),forall(_,_,_)) == false
DEF <(exist(a,b,c),exist(A,B,C)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(<)(b,B) THEN true
IF <(<)(B,b) THEN false
ELSE
IF <(c,C) THEN true
IF <(C,c) THEN false
ELSE
false
FI
FI
FI
DEF <(exist(_,_,_),informal(_,_)) == true
DEF <(exist(_,_,_),other(_,_,_)) == true
DEF <(informal(_,_),dfd(_,_)) == false
DEF <(informal(_,_),approx(_,_,_)) == false
DEF <(informal(_,_),cong(_,_,_)) == false
DEF <(informal(_,_),neg(_,_)) == false
DEF <(informal(_,_),conj(_,_,_)) == false
DEF <(informal(_,_),disj(_,_,_)) == false
DEF <(informal(_,_),impl(_,_,_)) == false
DEF <(informal(_,_),equiv(_,_,_)) == false
DEF <(informal(_,_),forall(_,_,_)) == false
DEF <(informal(_,_),exist(_,_,_)) == false
DEF <(informal(a,b),informal(A,B)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
false
FI
FI
DEF <(informal(_,_),other(_,_,_)) == true
DEF <(other(_,_,_),dfd(_,_)) == false
DEF <(other(_,_,_),approx(_,_,_)) == false
DEF <(other(_,_,_),cong(_,_,_)) == false
DEF <(other(_,_,_),neg(_,_)) == false
DEF <(other(_,_,_),conj(_,_,_)) == false
DEF <(other(_,_,_),disj(_,_,_)) == false
DEF <(other(_,_,_),impl(_,_,_)) == false
DEF <(other(_,_,_),equiv(_,_,_)) == false
DEF <(other(_,_,_),forall(_,_,_)) == false
DEF <(other(_,_,_),exist(_,_,_)) == false
DEF <(other(_,_,_),informal(_,_)) == false
DEF < :formula**formula->bool(other(a,b,_),other(A,B,_)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
false
FI
FI

FUN = : formula ** formula -> bool
DEF =(dfd(a,b),dfd(A,B)) == IF =(a,A) THEN IF =(b,B) THEN true
ELSE
false
FI
ELSE
false
FI
DEF =(dfd(_,_),approx(_,_,_)) == false
DEF =(dfd(_,_),cong(_,_,_)) == false
DEF =(dfd(_,_),neg(_,_)) == false
DEF =(dfd(_,_),conj(_,_,_)) == false
DEF =(dfd(_,_),disj(_,_,_)) == false
DEF =(dfd(_,_),impl(_,_,_)) == false
DEF =(dfd(_,_),equiv(_,_,_)) == false
DEF =(dfd(_,_),forall(_,_,_)) == false
DEF =(dfd(_,_),exist(_,_,_)) == false
DEF =(dfd(_,_),informal(_,_)) == false
DEF =(dfd(_,_),other(_,_,_)) == false
DEF =(approx(_,_,_),dfd(_,_)) == false
DEF =(approx(a,b,c),approx(A,B,C)) == IF =(a,A) THEN IF =(b,B) THEN IF =(c,C) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
DEF =(approx(_,_,_),cong(_,_,_)) == false
DEF =(approx(_,_,_),neg(_,_)) == false
DEF =(approx(_,_,_),conj(_,_,_)) == false
DEF =(approx(_,_,_),disj(_,_,_)) == false
DEF =(approx(_,_,_),impl(_,_,_)) == false
DEF =(approx(_,_,_),equiv(_,_,_)) == false
DEF =(approx(_,_,_),forall(_,_,_)) == false
DEF =(approx(_,_,_),exist(_,_,_)) == false
DEF =(approx(_,_,_),informal(_,_)) == false
DEF =(approx(_,_,_),other(_,_,_)) == false
DEF =(cong(_,_,_),dfd(_,_)) == false
DEF =(cong(_,_,_),approx(_,_,_)) == false
DEF =(cong(a,b,c),cong(A,B,C)) == IF =(a,A) THEN IF =(b,B) THEN IF =(c,C) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
DEF =(cong(_,_,_),neg(_,_)) == false
DEF =(cong(_,_,_),conj(_,_,_)) == false
DEF =(cong(_,_,_),disj(_,_,_)) == false
DEF =(cong(_,_,_),impl(_,_,_)) == false
DEF =(cong(_,_,_),equiv(_,_,_)) == false
DEF =(cong(_,_,_),forall(_,_,_)) == false
DEF =(cong(_,_,_),exist(_,_,_)) == false
DEF =(cong(_,_,_),informal(_,_)) == false
DEF =(cong(_,_,_),other(_,_,_)) == false
DEF =(neg(_,_),dfd(_,_)) == false
DEF =(neg(_,_),approx(_,_,_)) == false
DEF =(neg(_,_),cong(_,_,_)) == false
DEF =(neg(a,b),neg(A,B)) == IF =(a,A) THEN IF =(b,B) THEN true
ELSE
false
FI
ELSE
false
FI
DEF =(neg(_,_),conj(_,_,_)) == false
DEF =(neg(_,_),disj(_,_,_)) == false
DEF =(neg(_,_),impl(_,_,_)) == false
DEF =(neg(_,_),equiv(_,_,_)) == false
DEF =(neg(_,_),forall(_,_,_)) == false
DEF =(neg(_,_),exist(_,_,_)) == false
DEF =(neg(_,_),informal(_,_)) == false
DEF =(neg(_,_),other(_,_,_)) == false
DEF =(conj(_,_,_),dfd(_,_)) == false
DEF =(conj(_,_,_),approx(_,_,_)) == false
DEF =(conj(_,_,_),cong(_,_,_)) == false
DEF =(conj(_,_,_),neg(_,_)) == false
DEF =(conj(a,b,c),conj(A,B,C)) == IF =(a,A) THEN IF =(b,B) THEN IF =(c,C) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
DEF =(conj(_,_,_),disj(_,_,_)) == false
DEF =(conj(_,_,_),impl(_,_,_)) == false
DEF =(conj(_,_,_),equiv(_,_,_)) == false
DEF =(conj(_,_,_),forall(_,_,_)) == false
DEF =(conj(_,_,_),exist(_,_,_)) == false
DEF =(conj(_,_,_),informal(_,_)) == false
DEF =(conj(_,_,_),other(_,_,_)) == false
DEF =(disj(_,_,_),dfd(_,_)) == false
DEF =(disj(_,_,_),approx(_,_,_)) == false
DEF =(disj(_,_,_),cong(_,_,_)) == false
DEF =(disj(_,_,_),neg(_,_)) == false
DEF =(disj(_,_,_),conj(_,_,_)) == false
DEF =(disj(a,b,c),disj(A,B,C)) == IF =(a,A) THEN IF =(b,B) THEN IF =(c,C) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
DEF =(disj(_,_,_),impl(_,_,_)) == false
DEF =(disj(_,_,_),equiv(_,_,_)) == false
DEF =(disj(_,_,_),forall(_,_,_)) == false
DEF =(disj(_,_,_),exist(_,_,_)) == false
DEF =(disj(_,_,_),informal(_,_)) == false
DEF =(disj(_,_,_),other(_,_,_)) == false
DEF =(impl(_,_,_),dfd(_,_)) == false
DEF =(impl(_,_,_),approx(_,_,_)) == false
DEF =(impl(_,_,_),cong(_,_,_)) == false
DEF =(impl(_,_,_),neg(_,_)) == false
DEF =(impl(_,_,_),conj(_,_,_)) == false
DEF =(impl(_,_,_),disj(_,_,_)) == false
DEF =(impl(a,b,c),impl(A,B,C)) == IF =(a,A) THEN IF =(b,B) THEN IF =(c,C) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
DEF =(impl(_,_,_),equiv(_,_,_)) == false
DEF =(impl(_,_,_),forall(_,_,_)) == false
DEF =(impl(_,_,_),exist(_,_,_)) == false
DEF =(impl(_,_,_),informal(_,_)) == false
DEF =(impl(_,_,_),other(_,_,_)) == false
DEF =(equiv(_,_,_),dfd(_,_)) == false
DEF =(equiv(_,_,_),approx(_,_,_)) == false
DEF =(equiv(_,_,_),cong(_,_,_)) == false
DEF =(equiv(_,_,_),neg(_,_)) == false
DEF =(equiv(_,_,_),conj(_,_,_)) == false
DEF =(equiv(_,_,_),disj(_,_,_)) == false
DEF =(equiv(_,_,_),impl(_,_,_)) == false
DEF =(equiv(a,b,c),equiv(A,B,C)) == IF =(a,A) THEN IF =(b,B) THEN IF =(c,C) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
DEF =(equiv(_,_,_),forall(_,_,_)) == false
DEF =(equiv(_,_,_),exist(_,_,_)) == false
DEF =(equiv(_,_,_),informal(_,_)) == false
DEF =(equiv(_,_,_),other(_,_,_)) == false
DEF =(forall(_,_,_),dfd(_,_)) == false
DEF =(forall(_,_,_),approx(_,_,_)) == false
DEF =(forall(_,_,_),cong(_,_,_)) == false
DEF =(forall(_,_,_),neg(_,_)) == false
DEF =(forall(_,_,_),conj(_,_,_)) == false
DEF =(forall(_,_,_),disj(_,_,_)) == false
DEF =(forall(_,_,_),impl(_,_,_)) == false
DEF =(forall(_,_,_),equiv(_,_,_)) == false
DEF =(forall(a,b,c),forall(A,B,C)) == IF =(a,A) THEN IF =(=)(b,B) THEN IF =(c,C) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
DEF =(forall(_,_,_),exist(_,_,_)) == false
DEF =(forall(_,_,_),informal(_,_)) == false
DEF =(forall(_,_,_),other(_,_,_)) == false
DEF =(exist(_,_,_),dfd(_,_)) == false
DEF =(exist(_,_,_),approx(_,_,_)) == false
DEF =(exist(_,_,_),cong(_,_,_)) == false
DEF =(exist(_,_,_),neg(_,_)) == false
DEF =(exist(_,_,_),conj(_,_,_)) == false
DEF =(exist(_,_,_),disj(_,_,_)) == false
DEF =(exist(_,_,_),impl(_,_,_)) == false
DEF =(exist(_,_,_),equiv(_,_,_)) == false
DEF =(exist(_,_,_),forall(_,_,_)) == false
DEF =(exist(a,b,c),exist(A,B,C)) == IF =(a,A) THEN IF =(=)(b,B) THEN IF =(c,C) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
DEF =(exist(_,_,_),informal(_,_)) == false
DEF =(exist(_,_,_),other(_,_,_)) == false
DEF =(informal(_,_),dfd(_,_)) == false
DEF =(informal(_,_),approx(_,_,_)) == false
DEF =(informal(_,_),cong(_,_,_)) == false
DEF =(informal(_,_),neg(_,_)) == false
DEF =(informal(_,_),conj(_,_,_)) == false
DEF =(informal(_,_),disj(_,_,_)) == false
DEF =(informal(_,_),impl(_,_,_)) == false
DEF =(informal(_,_),equiv(_,_,_)) == false
DEF =(informal(_,_),forall(_,_,_)) == false
DEF =(informal(_,_),exist(_,_,_)) == false
DEF =(informal(a,b),informal(A,B)) == IF =(a,A) THEN IF =(b,B) THEN true
ELSE
false
FI
ELSE
false
FI
DEF =(informal(_,_),other(_,_,_)) == false
DEF =(other(_,_,_),dfd(_,_)) == false
DEF =(other(_,_,_),approx(_,_,_)) == false
DEF =(other(_,_,_),cong(_,_,_)) == false
DEF =(other(_,_,_),neg(_,_)) == false
DEF =(other(_,_,_),conj(_,_,_)) == false
DEF =(other(_,_,_),disj(_,_,_)) == false
DEF =(other(_,_,_),impl(_,_,_)) == false
DEF =(other(_,_,_),equiv(_,_,_)) == false
DEF =(other(_,_,_),forall(_,_,_)) == false
DEF =(other(_,_,_),exist(_,_,_)) == false
DEF =(other(_,_,_),informal(_,_)) == false
DEF = :formula**formula->bool(other(a,b,_),other(A,B,_)) == IF =(a,A) THEN =(b,B) ELSE false FI

FUN :=_data : formula ** dyn -> formula
DEF :=_data(other(1,2,_),new) == (other(1,2,new)):formula

FUN :=_id : formula ** denotation -> formula
DEF :=_id(other(1,_,3),new) == (other(1,new,3)):formula

FUN :=_pos : formula ** pos -> formula
DEF :=_pos(other(_,2,3),new) == (other(new,2,3)):formula
DEF :=_pos(informal(_,2),new) == informal(new,2)
DEF :=_pos(exist(_,2,3),new) == exist(new,2,3)
DEF :=_pos(forall(_,2,3),new) == forall(new,2,3)
DEF :=_pos(equiv(_,2,3),new) == equiv(new,2,3)
DEF :=_pos(impl(_,2,3),new) == impl(new,2,3)
DEF :=_pos(disj(_,2,3),new) == disj(new,2,3)
DEF :=_pos(conj(_,2,3),new) == conj(new,2,3)
DEF :=_pos(neg(_,2),new) == neg(new,2)
DEF :=_pos(cong(_,2,3),new) == cong(new,2,3)
DEF :=_pos(approx(_,2,3),new) == approx(new,2,3)
DEF :=_pos(dfd(_,2),new) == dfd(new,2)

FUN :=_text : formula ** denotation -> formula
DEF :=_text(informal(1,_),new) == informal(1,new)

FUN :=_range : formula ** formula -> formula
DEF :=_range(exist(1,2,_),new) == exist(1,2,new)
DEF :=_range(forall(1,2,_),new) == forall(1,2,new)

FUN :=_vars : formula ** seq[var] -> formula
DEF :=_vars(exist(1,_,3),new) == exist(1,new,3)
DEF :=_vars(forall(1,_,3),new) == forall(1,new,3)

FUN :=_right : formula ** formula -> formula
DEF :=_right(equiv(1,2,_),new) == equiv(1,2,new)
DEF :=_right(disj(1,2,_),new) == disj(1,2,new)
DEF :=_right(conj(1,2,_),new) == conj(1,2,new)

FUN :=_left : formula ** formula -> formula
DEF :=_left(equiv(1,_,3),new) == equiv(1,new,3)
DEF :=_left(disj(1,_,3),new) == disj(1,new,3)
DEF :=_left(conj(1,_,3),new) == conj(1,new,3)

FUN :=_conclusion : formula ** formula -> formula
DEF :=_conclusion(impl(1,2,_),new) == impl(1,2,new)

FUN :=_premise : formula ** formula -> formula
DEF :=_premise(impl(1,_,3),new) == impl(1,new,3)

FUN :=_formula : formula ** formula -> formula
DEF :=_formula(neg(1,_),new) == neg(1,new)

FUN :=_right : formula ** expr -> formula
DEF :=_right(cong(1,2,_),new) == cong(1,2,new)
DEF :=_right(approx(1,2,_),new) == approx(1,2,new)

FUN :=_left : formula ** expr -> formula
DEF :=_left(cong(1,_,3),new) == cong(1,new,3)
DEF :=_left(approx(1,_,3),new) == approx(1,new,3)

FUN :=_expr : formula ** expr -> formula
DEF :=_expr(dfd(1,_),new) == dfd(1,new)

FUN fmtFormula : formula -> fmt
DEF fmtFormula(dfd(v0,v1)) == ;(;(beg(2),lit("dfd")),;(;(lit("("),;(;(fmtPos(v0),;(lit(", "),fmtExpr(v1))),lit(")"))),end))
DEF fmtFormula(approx(v0,v1,v2)) == ;(;(beg(2),lit("approx")),;(;(lit("("),;(;(;(fmtPos(v0),;(lit(", "),fmtExpr(v1))),;(lit(", "),fmtExpr(v2))),lit(")"))),end))
DEF fmtFormula(cong(v0,v1,v2)) == ;(;(beg(2),lit("cong")),;(;(lit("("),;(;(;(fmtPos(v0),;(lit(", "),fmtExpr(v1))),;(lit(", "),fmtExpr(v2))),lit(")"))),end))
DEF fmtFormula(neg(v0,v1)) == ;(;(beg(2),lit("neg")),;(;(lit("("),;(;(fmtPos(v0),;(lit(", "),fmtFormula(v1))),lit(")"))),end))
DEF fmtFormula(conj(v0,v1,v2)) == ;(;(beg(2),lit("conj")),;(;(lit("("),;(;(;(fmtPos(v0),;(lit(", "),fmtFormula(v1))),;(lit(", "),fmtFormula(v2))),lit(")"))),end))
DEF fmtFormula(disj(v0,v1,v2)) == ;(;(beg(2),lit("disj")),;(;(lit("("),;(;(;(fmtPos(v0),;(lit(", "),fmtFormula(v1))),;(lit(", "),fmtFormula(v2))),lit(")"))),end))
DEF fmtFormula(impl(v0,v1,v2)) == ;(;(beg(2),lit("impl")),;(;(lit("("),;(;(;(fmtPos(v0),;(lit(", "),fmtFormula(v1))),;(lit(", "),fmtFormula(v2))),lit(")"))),end))
DEF fmtFormula(equiv(v0,v1,v2)) == ;(;(beg(2),lit("equiv")),;(;(lit("("),;(;(;(fmtPos(v0),;(lit(", "),fmtFormula(v1))),;(lit(", "),fmtFormula(v2))),lit(")"))),end))
DEF fmtFormula(forall(v0,v1,v2)) == ;(;(beg(2),lit("forall")),;(;(lit("("),;(;(;(fmtPos(v0),;(lit(", "),fmtSeq(fmtVar)(v1))),;(lit(", "),fmtFormula(v2))),lit(")"))),end))
DEF fmtFormula(exist(v0,v1,v2)) == ;(;(beg(2),lit("exist")),;(;(lit("("),;(;(;(fmtPos(v0),;(lit(", "),fmtSeq(fmtVar)(v1))),;(lit(", "),fmtFormula(v2))),lit(")"))),end))
DEF fmtFormula(informal(v0,v1)) == ;(;(beg(2),lit("informal")),;(;(lit("("),;(;(fmtPos(v0),;(lit(", "),fmtDenotation(v1))),lit(")"))),end))
DEF fmtFormula(other(v0,v1,v2)) == ;(;(beg(2),lit("other")),;(;(lit("("),;(;(;(fmtPos(v0),;(lit(", "),fmtDenotation(v1))),;(lit(", "),fmtDyn(v2))),lit(")"))),end))


-- this is output of ordinatrice verte for free type part
FUN < : part ** part -> bool
DEF <(signature,signature) == false
DEF <(signature,extProperties) == true
DEF <(signature,implementation) == true
DEF <(signature,intProperties) == true
DEF <(extProperties,signature) == false
DEF <(extProperties,extProperties) == false
DEF <(extProperties,implementation) == true
DEF <(extProperties,intProperties) == true
DEF <(implementation,signature) == false
DEF <(implementation,extProperties) == false
DEF <(implementation,implementation) == false
DEF <(implementation,intProperties) == true
DEF <(intProperties,signature) == false
DEF <(intProperties,extProperties) == false
DEF <(intProperties,implementation) == false
DEF <(intProperties,intProperties) == false

FUN = : part ** part -> bool
DEF =(signature,signature) == true
DEF =(signature,extProperties) == false
DEF =(signature,implementation) == false
DEF =(signature,intProperties) == false
DEF =(extProperties,signature) == false
DEF =(extProperties,extProperties) == true
DEF =(extProperties,implementation) == false
DEF =(extProperties,intProperties) == false
DEF =(implementation,signature) == false
DEF =(implementation,extProperties) == false
DEF =(implementation,implementation) == true
DEF =(implementation,intProperties) == false
DEF =(intProperties,signature) == false
DEF =(intProperties,extProperties) == false
DEF =(intProperties,implementation) == false
DEF =(intProperties,intProperties) == true


FUN fmtPart : part -> fmt
DEF fmtPart(signature) == ;(;(beg(2),lit("signature")),end)
DEF fmtPart(extProperties) == ;(;(beg(2),lit("extProperties")),end)
DEF fmtPart(implementation) == ;(;(beg(2),lit("implementation")),end)
DEF fmtPart(intProperties) == ;(;(beg(2),lit("intProperties")),end)



-- this is output of ordinatrice verte for free type struct
/*
FUN < : struct ** struct -> bool
DEF <(struct(a,b,c,d,e,f,g),struct(A,B,C,D,E,F,G)) == IF <(<)(a,A) THEN true
IF <(<)(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
IF <(c,C) THEN true
IF <(C,c) THEN false
ELSE
IF <(<,<(<))(d,D) THEN true
IF <(<,<(<))(D,d) THEN false
ELSE
IF <(<,<(<))(e,E) THEN true
IF <(<,<(<))(E,e) THEN false
ELSE
IF <(<,<)(f,F) THEN true
IF <(<,<)(F,f) THEN false
ELSE
IF <(<,<)(g,G) THEN true
IF <(<,<)(G,g) THEN false
ELSE
false
FI
FI
FI
FI
FI
FI
FI
*/

/*
FUN = : struct ** struct -> bool
DEF =(struct(a,b,c,d,e,f,g),struct(A,B,C,D,E,F,G)) == IF =(=)(a,A) THEN IF =(b,B) THEN IF =(c,C) THEN IF =(=,=(=))(d,D) THEN IF =(=,=(=))(e,E) THEN IF =(=,=)(f,F) THEN IF =(=,=)(g,G) THEN true
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
ELSE
false
FI
*/

-- FUN :=_pragmas : struct ** seq -> struct
DEF :=_pragmas(struct(1,2,3,4,5,6,7,_),new) == struct(1,2,3,4,5,6,7,new)

-- FUN :=_props : struct ** map -> struct
DEF :=_props(struct(1,2,3,4,5,6,_,8),new) == struct(1,2,3,4,5,6,new,8)

-- FUN :=_objs : struct ** map -> struct
DEF :=_objs(struct(1,2,3,4,5,_,7,8),new) == struct(1,2,3,4,5,new,7,8)

-- FUN :=_onlys : struct ** map -> struct
DEF :=_onlys(struct(1,2,3,4,_,6,7,8),new) == struct(1,2,3,4,new,6,7,8)

-- FUN :=_insts : struct ** map -> struct
DEF :=_insts(struct(1,2,3,_,5,6,7,8),new) == struct(1,2,3,new,5,6,7,8)

-- FUN :=_symbol : struct ** denotation -> struct
DEF :=_symbol(struct(1,2,_,4,5,6,7,8),new) == struct(1,2,new,4,5,6,7,8)

-- FUN :=_origin : struct ** origin -> struct
DEF :=_origin(struct(1,_,3,4,5,6,7,8),new) == struct(1,new,3,4,5,6,7,8)

-- FUN :=_pos : struct ** seq -> struct
DEF :=_pos(struct(_,2,3,4,5,6,7,8),new) == struct(new,2,3,4,5,6,7,8)

-- FUN fmtStruct : struct -> fmt
-- DEF fmtStruct(struct(v0,v1,v2,v3,v4,v5,v6)) == ;(;(beg(2),lit("struct")),;(;(lit("("),;(;(;(;(;(;(;(fmtSeq(fmtPos)(v0),;(lit(", "),fmtOrigin(v1))),;(lit(", "),fmtDenotation(v2))),;(lit(", "),fmtMap(fmtInst,fmtSeq(fmtName))(v3))),;(lit(", "),fmtMap(fmtInst,fmtSeq(fmtName))(v4))),;(lit(", "),fmtMap(fmtIdent,fmtObject)(v5))),;(lit(", "),fmtMap(fmtIdent,fmtProperty)(v6))),lit(")"))),end))



-- this is output of ordinatrice verte for free type interOpal
/*
FUN < : interOpal ** interOpal -> bool
DEF <(interOpal(a,b),interOpal(A,B)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(<,<)(b,B) THEN true
IF <(<,<)(B,b) THEN false
ELSE
false
FI
FI

FUN = : interOpal ** interOpal -> bool
DEF =(interOpal(a,b),interOpal(A,B)) == IF =(a,A) THEN IF =(=,=)(b,B) THEN true
ELSE
false
FI
ELSE
false
FI
*/

-- FUN :=_structs : interOpal ** map[origin, <, struct] -> interOpal
DEF :=_structs(interOpal(1,_),new) == interOpal(1,new)

FUN :=_part : interOpal ** part -> interOpal
DEF :=_part(interOpal(_,v2),new) == interOpal(new,v2)

-- FUN fmtInterOpal : interOpal -> fmt
-- DEF fmtInterOpal(interOpal(v0,v1)) == ;(;(beg(2),lit("interOpal")),;(;(lit("("),;(;(fmtPart(v0),;(lit(", "),fmtMap(fmtOrigin,fmtStruct)(v1))),lit(")"))),end))



-- this is output of ordinatrice verte for free type pragma
FUN < : pragma ** pragma -> bool
DEF <(pragma(a),pragma(A)) == IF <(<)(a,A) THEN true
IF <(<)(A,a) THEN false
ELSE
false
FI

FUN = : pragma ** pragma -> bool
DEF =(pragma(a),pragma(A)) == IF =(=)(a,A) THEN true
ELSE
false
FI

FUN :=_items : pragma ** seq[pragmaItem] -> pragma
DEF :=_items(pragma(_),new) == pragma(new)

FUN fmtPragma : pragma -> fmt
DEF fmtPragma(pragma(v0)) == ;(;(beg(2),lit("pragma")),;(;(lit("("),;(fmtSeq(fmtPragmaItem)(v0),lit(")"))),end))



-- this is output of ordinatrice verte for free type pragmaItem
FUN < : pragmaItem ** pragmaItem -> bool
DEF <(objects(a),objects(A)) == IF <(<)(a,A) THEN true
IF <(<)(A,a) THEN false
ELSE
false
FI
DEF <(objects(_),token(_,_)) == true
DEF <(token(_,_),objects(_)) == false
DEF <(token(a,b),token(A,B)) == IF <(a,A) THEN true
IF <(A,a) THEN false
ELSE
IF <(b,B) THEN true
IF <(B,b) THEN false
ELSE
false
FI
FI

FUN = : pragmaItem ** pragmaItem -> bool
DEF =(objects(a),objects(A)) == IF =(=)(a,A) THEN true
ELSE
false
FI
DEF =(objects(_),token(_,_)) == false
DEF =(token(_,_),objects(_)) == false
DEF =(token(a,b),token(A,B)) == IF =(a,A) THEN IF =(b,B) THEN true
ELSE
false
FI
ELSE
false
FI

FUN :=_text : pragmaItem ** denotation -> pragmaItem
DEF :=_text(token(1,_),new) == token(1,new)

FUN :=_pos : pragmaItem ** pos -> pragmaItem
DEF :=_pos(token(_,2),new) == token(new,2)

FUN :=_objects : pragmaItem ** seq[name] -> pragmaItem
DEF :=_objects(objects(_),new) == objects(new)

FUN fmtPragmaItem : pragmaItem -> fmt
DEF fmtPragmaItem(objects(v0)) == ;(;(beg(2),lit("objects")),;(;(lit("("),;(fmtSeq(fmtName)(v0),lit(")"))),end))
DEF fmtPragmaItem(token(v0,v1)) == ;(;(beg(2),lit("token")),;(;(lit("("),;(;(fmtPos(v0),;(lit(", "),fmtDenotation(v1))),lit(")"))),end))

